/*
 * iaxxx-register-defs-cnr0.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_CNR0_H__
#define __IAXXX_REGISTER_DEFS_CNR0_H__

/*** The base address for this set of registers ***/
#define IAXXX_CNR0_REGS_ADDR (0x40040000)

/*** CNR0_AF_LPX_CLK_SC (0x40040000) ***/
/*
 * af_lpx_clk is sourced from pd0_lpx_clk. Divide af_lpx_clk by (SKIP_CNT+1)
 */
#define IAXXX_CNR0_AF_LPX_CLK_SC_ADDR (0x40040000)
#define IAXXX_CNR0_AF_LPX_CLK_SC_MASK_VAL 0x000003ff
#define IAXXX_CNR0_AF_LPX_CLK_SC_RMASK_VAL 0x000003ff
#define IAXXX_CNR0_AF_LPX_CLK_SC_WMASK_VAL 0x000003ff
#define IAXXX_CNR0_AF_LPX_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR0_AF_LPX_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR0_AF_LPX_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR0_AF_LPX_CLK_SC_EN_POS 0
#define IAXXX_CNR0_AF_LPX_CLK_SC_EN_SIZE 1
#define IAXXX_CNR0_AF_LPX_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR0_AF_LPX_CLK_SC_SKIP_CNT_MASK 0x000003fe
#define IAXXX_CNR0_AF_LPX_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR0_AF_LPX_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR0_AF_LPX_CLK_SC_SKIP_CNT_SIZE 9
#define IAXXX_CNR0_AF_LPX_CLK_SC_SKIP_CNT_DECL (9:1)

/*** CNR0_CNR0_APB_LPX_CLK_HW_CG (0x40040004) ***/
/*
 * Hardware Controlled enable for cnr0_apb_lpx_clk. This clock is sourced
 * from pd0_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access CNR0 APB registers
 */
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_ADDR (0x40040004)
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR0_CNR0_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR0_DMX_TIEQ_CLK_CG (0x40040008) ***/
/*
 * DMX Tieq Clock, the clock root is dmx_lpx_clk_i.
 */
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_ADDR (0x40040008)
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_EN_POS 0
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_DMX_TIEQ_CLK_CG_EN_DECL 0

/*** CNR0_HMD_TIEQ_CLK_CG (0x4004000c) ***/
/*
 * HMD Tieq Clock, the clock root is hmd_lpx_clk_i.
 */
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_ADDR (0x4004000c)
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_EN_POS 0
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_HMD_TIEQ_CLK_CG_EN_DECL 0

/*** CNR0_I2S_APB_LPX_CLK_CG (0x40040010) ***/
/*
 * Enable i2s_apb_lpx_clk clock for I2S clock, the clock root is pcm_lpx_clk
 */
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_ADDR (0x40040010)
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_I2S_APB_LPX_CLK_CG_EN_DECL 0

/*** CNR0_PCM_LPX_CLK_SC (0x40040014) ***/
/*
 * The clock source is pd0_lpx_clk. The clocks run at the speed of the
 * pd0_lpx_clk divided by (SKIP_CNT+1).
 */
#define IAXXX_CNR0_PCM_LPX_CLK_SC_ADDR (0x40040014)
#define IAXXX_CNR0_PCM_LPX_CLK_SC_MASK_VAL 0x000001ff
#define IAXXX_CNR0_PCM_LPX_CLK_SC_RMASK_VAL 0x000001ff
#define IAXXX_CNR0_PCM_LPX_CLK_SC_WMASK_VAL 0x000001ff
#define IAXXX_CNR0_PCM_LPX_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR0_PCM_LPX_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM_LPX_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_LPX_CLK_SC_EN_POS 0
#define IAXXX_CNR0_PCM_LPX_CLK_SC_EN_SIZE 1
#define IAXXX_CNR0_PCM_LPX_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR0_PCM_LPX_CLK_SC_SKIP_CNT_MASK 0x000001fe
#define IAXXX_CNR0_PCM_LPX_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_LPX_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR0_PCM_LPX_CLK_SC_SKIP_CNT_SIZE 8
#define IAXXX_CNR0_PCM_LPX_CLK_SC_SKIP_CNT_DECL (8:1)

/*** CNR0_PCM0_APB_LPX_CLK_HW_CG (0x40040018) ***/
/*
 * Hardware Controlled enable for pcm0_apb_lpx_clk. This clock is sourced
 * from pcm_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PCM0 APB registers
 */
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_ADDR (0x40040018)
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR0_PCM0_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR0_PCM0_LPX_CLK_CG (0x4004001c) ***/
/*
 * Enable pcm0_lpx_clk clock for PCM LPX clock, the clock root is pcm_lpx_clk
 */
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_ADDR (0x4004001c)
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM0_LPX_CLK_CG_EN_DECL 0

/*** CNR0_PCM1_APB_LPX_CLK_HW_CG (0x40040020) ***/
/*
 * Hardware Controlled enable for pcm1_apb_lpx_clk. This clock is sourced
 * from pcm_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PCM1 APB registers
 */
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_ADDR (0x40040020)
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR0_PCM1_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR0_PCM1_LPX_CLK_CG (0x40040024) ***/
/*
 * Enable pcm1_lpx_clk clock for PCM LPX clock, the clock root is pcm_lpx_clk
 */
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_ADDR (0x40040024)
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM1_LPX_CLK_CG_EN_DECL 0

/*** CNR0_PCM2_APB_LPX_CLK_HW_CG (0x40040028) ***/
/*
 * Hardware Controlled enable for pcm2_apb_lpx_clk. This clock is sourced
 * from pcm_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PCM2 APB registers
 */
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_ADDR (0x40040028)
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR0_PCM2_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR0_PCM2_LPX_CLK_CG (0x4004002c) ***/
/*
 * Enable pcm2_lpx_clk clock for PCM LPX clock, the clock root is pcm_lpx_clk
 */
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_ADDR (0x4004002c)
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR0_PCM2_LPX_CLK_CG_EN_DECL 0

/*** CNR0_APB_REG_SOFT_RST (0x40040030) ***/
/*
 * Resets APB registers
 */
#define IAXXX_CNR0_APB_REG_SOFT_RST_ADDR (0x40040030)
#define IAXXX_CNR0_APB_REG_SOFT_RST_MASK_VAL 0x00000032
#define IAXXX_CNR0_APB_REG_SOFT_RST_RMASK_VAL 0x00000000
#define IAXXX_CNR0_APB_REG_SOFT_RST_WMASK_VAL 0x00000000
#define IAXXX_CNR0_APB_REG_SOFT_RST_RESET_VAL 0x00000000

/*
 * Write 1 to reset H2P2 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2P2_APB_REG_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2P2_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2P2_APB_REG_SOFT_RST_POS 1
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2P2_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2P2_APB_REG_SOFT_RST_DECL 1

/*
 * Write 1 to reset I2SM APB registers only. It will always read back as 0
 */
#define IAXXX_CNR0_APB_REG_SOFT_RST_I2SM_APB_REG_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR0_APB_REG_SOFT_RST_I2SM_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR0_APB_REG_SOFT_RST_I2SM_APB_REG_SOFT_RST_POS 4
#define IAXXX_CNR0_APB_REG_SOFT_RST_I2SM_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR0_APB_REG_SOFT_RST_I2SM_APB_REG_SOFT_RST_DECL 4

/*
 * Write 1 to reset H2X (AHB to XLMI) module. It will always read back as 0
 */
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2X_APB_REG_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2X_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2X_APB_REG_SOFT_RST_POS 5
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2X_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR0_APB_REG_SOFT_RST_H2X_APB_REG_SOFT_RST_DECL 5

/*** CNR0_FUNC_SOFT_RST (0x40040034) ***/
/*
 * Reset the corresponding APB_REG_SOFT_RST when reprogramming the module
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_ADDR (0x40040034)
#define IAXXX_CNR0_FUNC_SOFT_RST_MASK_VAL 0x00007ff3
#define IAXXX_CNR0_FUNC_SOFT_RST_RMASK_VAL 0x00007ff3
#define IAXXX_CNR0_FUNC_SOFT_RST_WMASK_VAL 0x00007ff3
#define IAXXX_CNR0_FUNC_SOFT_RST_RESET_VAL 0x00007ff3

/*
 * AF reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_AF_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR0_FUNC_SOFT_RST_AF_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_AF_SOFT_RST_POS 0
#define IAXXX_CNR0_FUNC_SOFT_RST_AF_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_AF_SOFT_RST_DECL 0

/*
 * AUD WALL reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_AUD_WALL_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR0_FUNC_SOFT_RST_AUD_WALL_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_AUD_WALL_SOFT_RST_POS 1
#define IAXXX_CNR0_FUNC_SOFT_RST_AUD_WALL_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_AUD_WALL_SOFT_RST_DECL 1

/*
 * PCM0 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM0_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM0_SOFT_RST_POS 4
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM0_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM0_SOFT_RST_DECL 4

/*
 * PCM1 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM1_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM1_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM1_SOFT_RST_POS 5
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM1_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM1_SOFT_RST_DECL 5

/*
 * PCM2 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM2_SOFT_RST_MASK 0x00000040
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM2_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM2_SOFT_RST_POS 6
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM2_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_PCM2_SOFT_RST_DECL 6

/*
 * PDM reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_PDM_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR0_FUNC_SOFT_RST_PDM_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_PDM_SOFT_RST_POS 7
#define IAXXX_CNR0_FUNC_SOFT_RST_PDM_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_PDM_SOFT_RST_DECL 7

/*
 * I2S Master0 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM0_SOFT_RST_MASK 0x00000100
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM0_SOFT_RST_POS 8
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM0_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM0_SOFT_RST_DECL 8

/*
 * I2S Master1 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM1_SOFT_RST_MASK 0x00000200
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM1_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM1_SOFT_RST_POS 9
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM1_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM1_SOFT_RST_DECL 9

/*
 * I2S Master2 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM2_SOFT_RST_MASK 0x00000400
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM2_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM2_SOFT_RST_POS 10
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM2_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM2_SOFT_RST_DECL 10

/*
 * I2S Master3 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM3_SOFT_RST_MASK 0x00000800
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM3_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM3_SOFT_RST_POS 11
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM3_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM3_SOFT_RST_DECL 11

/*
 * I2S Master4 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM4_SOFT_RST_MASK 0x00001000
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM4_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM4_SOFT_RST_POS 12
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM4_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM4_SOFT_RST_DECL 12

/*
 * I2S Master5 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM5_SOFT_RST_MASK 0x00002000
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM5_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM5_SOFT_RST_POS 13
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM5_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM5_SOFT_RST_DECL 13

/*
 * I2S Master6 reset in PD0
 */
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM6_SOFT_RST_MASK 0x00004000
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM6_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM6_SOFT_RST_POS 14
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM6_SOFT_RST_SIZE 1
#define IAXXX_CNR0_FUNC_SOFT_RST_I2SM6_SOFT_RST_DECL 14

/*** CNR0_I2S_ENABLE (0x40040038) ***/
/*
 */
#define IAXXX_CNR0_I2S_ENABLE_ADDR (0x40040038)
#define IAXXX_CNR0_I2S_ENABLE_MASK_VAL 0x00007f7f
#define IAXXX_CNR0_I2S_ENABLE_RMASK_VAL 0x00007f7f
#define IAXXX_CNR0_I2S_ENABLE_WMASK_VAL 0x0000007f
#define IAXXX_CNR0_I2S_ENABLE_RESET_VAL 0x00000000

/*
 * Each bit corresponds to a I2S generator, bit[0/1/2/3/4/5/6] to
 * I2S0/1/2/3/4/5/6.
 * 0: I2S generator is disabled.
 * 1: I2S generator is enabled.
 * Note: The I2S generators are not enabled or disabled until
 * I2S_GEN(TRIGGER) is written to.
 */
#define IAXXX_CNR0_I2S_ENABLE_MASK_MASK 0x0000007f
#define IAXXX_CNR0_I2S_ENABLE_MASK_RESET_VAL 0x0
#define IAXXX_CNR0_I2S_ENABLE_MASK_POS 0
#define IAXXX_CNR0_I2S_ENABLE_MASK_SIZE 7
#define IAXXX_CNR0_I2S_ENABLE_MASK_DECL (6:0)

/*
 * Each bit corresponds to a I2S generator, bit[0/1/2/3/4/5/6] to
 * I2S0/1/2/3/4/5/6.
 * 0: I2S generator is not enabled
 * 1: I2S generator is enabled
 */
#define IAXXX_CNR0_I2S_ENABLE_STATUS_MASK 0x00007f00
#define IAXXX_CNR0_I2S_ENABLE_STATUS_RESET_VAL 0x0
#define IAXXX_CNR0_I2S_ENABLE_STATUS_POS 8
#define IAXXX_CNR0_I2S_ENABLE_STATUS_SIZE 7
#define IAXXX_CNR0_I2S_ENABLE_STATUS_DECL (14:8)

/*** CNR0_PCM_ACTIVE (0x4004003c) ***/
/*
 * PCM Active register turns off or activates each PCM unit.  By default, all
 * PCM units are off.  Supports read/write access.
 */
#define IAXXX_CNR0_PCM_ACTIVE_ADDR (0x4004003c)
#define IAXXX_CNR0_PCM_ACTIVE_MASK_VAL 0x00000007
#define IAXXX_CNR0_PCM_ACTIVE_RMASK_VAL 0x00000007
#define IAXXX_CNR0_PCM_ACTIVE_WMASK_VAL 0x00000007
#define IAXXX_CNR0_PCM_ACTIVE_RESET_VAL 0x00000000

/*
 * 0: Turn off PCM
 * 1: Activate PCM
 */
#define IAXXX_CNR0_PCM_ACTIVE_PCM_0_ACT_MASK 0x00000001
#define IAXXX_CNR0_PCM_ACTIVE_PCM_0_ACT_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ACTIVE_PCM_0_ACT_POS 0
#define IAXXX_CNR0_PCM_ACTIVE_PCM_0_ACT_SIZE 1
#define IAXXX_CNR0_PCM_ACTIVE_PCM_0_ACT_DECL 0

/*
 * 0: Turn off PCM
 * 1: Activate PCM
 */
#define IAXXX_CNR0_PCM_ACTIVE_PCM_1_ACT_MASK 0x00000002
#define IAXXX_CNR0_PCM_ACTIVE_PCM_1_ACT_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ACTIVE_PCM_1_ACT_POS 1
#define IAXXX_CNR0_PCM_ACTIVE_PCM_1_ACT_SIZE 1
#define IAXXX_CNR0_PCM_ACTIVE_PCM_1_ACT_DECL 1

/*
 * 0: Turn off PCM
 * 1: Activate PCM
 */
#define IAXXX_CNR0_PCM_ACTIVE_PCM_2_ACT_MASK 0x00000004
#define IAXXX_CNR0_PCM_ACTIVE_PCM_2_ACT_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ACTIVE_PCM_2_ACT_POS 2
#define IAXXX_CNR0_PCM_ACTIVE_PCM_2_ACT_SIZE 1
#define IAXXX_CNR0_PCM_ACTIVE_PCM_2_ACT_DECL 2

/*** CNR0_PCM_ENABLED (0x40040040) ***/
/*
 * PCM Enabled register shows the status of each pcm (enabled/disabled).
 * Supports read-only access.  The fields are not fully synchronized, so this
 * register should be read several times.
 */
#define IAXXX_CNR0_PCM_ENABLED_ADDR (0x40040040)
#define IAXXX_CNR0_PCM_ENABLED_MASK_VAL 0x00000007
#define IAXXX_CNR0_PCM_ENABLED_RMASK_VAL 0x00000007
#define IAXXX_CNR0_PCM_ENABLED_WMASK_VAL 0x00000000
#define IAXXX_CNR0_PCM_ENABLED_RESET_VAL 0x00000000

/*
 * 0: PCM Not Enabled
 * 1: PCM Enabled
 */
#define IAXXX_CNR0_PCM_ENABLED_PCM_0_MASK 0x00000001
#define IAXXX_CNR0_PCM_ENABLED_PCM_0_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ENABLED_PCM_0_POS 0
#define IAXXX_CNR0_PCM_ENABLED_PCM_0_SIZE 1
#define IAXXX_CNR0_PCM_ENABLED_PCM_0_DECL 0

/*
 * 0: PCM Not Enabled
 * 1: PCM Enabled
 */
#define IAXXX_CNR0_PCM_ENABLED_PCM_1_MASK 0x00000002
#define IAXXX_CNR0_PCM_ENABLED_PCM_1_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ENABLED_PCM_1_POS 1
#define IAXXX_CNR0_PCM_ENABLED_PCM_1_SIZE 1
#define IAXXX_CNR0_PCM_ENABLED_PCM_1_DECL 1

/*
 * 0: PCM Not Enabled
 * 1: PCM Enabled
 */
#define IAXXX_CNR0_PCM_ENABLED_PCM_2_MASK 0x00000004
#define IAXXX_CNR0_PCM_ENABLED_PCM_2_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_ENABLED_PCM_2_POS 2
#define IAXXX_CNR0_PCM_ENABLED_PCM_2_SIZE 1
#define IAXXX_CNR0_PCM_ENABLED_PCM_2_DECL 2

/*** CNR0_PCM_MX0 (0x40040044) ***/
/*
 * The PCM Multiplexer 1 register controls the routing for port input clock
 * and frame sync, to specified slave PCM units.  Note that there are 3 pcm
 * ports from pads which are used for pcm functions, and in the D4080, these
 * pcm port connections can come various actual IO PADS.
 */
#define IAXXX_CNR0_PCM_MX0_ADDR (0x40040044)
#define IAXXX_CNR0_PCM_MX0_MASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX0_RMASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX0_WMASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX0_RESET_VAL 0x00000024

/*
 * Select pcm0 clock and frame sync source.
 * For default value, routes pcm0_bclk/fs pins to internal slave pcm0.
 * 0: route pcm0_bclk/fs signals to internal slave pcm0 unit
 * 1: route pcm1_bclk/fs signals to internal slave pcm0 unit
 * 2: route pcm2_bclk/fs signals to internal slave pcm0 unit
 */
#define IAXXX_CNR0_PCM_MX0_P0RT_MASK 0x00000003
#define IAXXX_CNR0_PCM_MX0_P0RT_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX0_P0RT_POS 0
#define IAXXX_CNR0_PCM_MX0_P0RT_SIZE 2
#define IAXXX_CNR0_PCM_MX0_P0RT_DECL (1:0)

/*
 * Select pcm1 clock and frame sync source.
 * For default value, routes pcm1_bclk/fs pins to internal slave pcm1.
 * 0: route pcm0_bclk/fs signals to internal slave pcm1 unit
 * 1: route pcm1_bclk/fs signals to internal slave pcm1 unit
 * 2: route pcm2_bclk/fs signals to internal slave pcm1 unit
 */
#define IAXXX_CNR0_PCM_MX0_P1RT_MASK 0x0000000c
#define IAXXX_CNR0_PCM_MX0_P1RT_RESET_VAL 0x1
#define IAXXX_CNR0_PCM_MX0_P1RT_POS 2
#define IAXXX_CNR0_PCM_MX0_P1RT_SIZE 2
#define IAXXX_CNR0_PCM_MX0_P1RT_DECL (3:2)

/*
 * Select pcm2 clock and frame sync source.
 * For default value, routes pcm2_bclk/fs pins to internal slave pcm2.
 * 0: route pcm0_bclk/fs signals to internal slave pcm2 unit
 * 1: route pcm1_bclk/fs signals to internal slave pcm2 unit
 * 2: route pcm2_bclk/fs signals to internal slave pcm2 unit
 */
#define IAXXX_CNR0_PCM_MX0_P2RT_MASK 0x00000030
#define IAXXX_CNR0_PCM_MX0_P2RT_RESET_VAL 0x2
#define IAXXX_CNR0_PCM_MX0_P2RT_POS 4
#define IAXXX_CNR0_PCM_MX0_P2RT_SIZE 2
#define IAXXX_CNR0_PCM_MX0_P2RT_DECL (5:4)

/*** CNR0_PCM_MX1 (0x40040048) ***/
/*
 * The PCM Multiplexer 1 register controls the routing for port data signals
 * to specified slave PCM units.  Note that there are 3 pcm ports from pads
 * which are used for pcm functions, and in the D4080, these pcm port
 * connections can come various actual IO PADS.
 */
#define IAXXX_CNR0_PCM_MX1_ADDR (0x40040048)
#define IAXXX_CNR0_PCM_MX1_MASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX1_RMASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX1_WMASK_VAL 0x0000003f
#define IAXXX_CNR0_PCM_MX1_RESET_VAL 0x00000024

/*
 * Select pcm0_din source (for internal slave pcm0) from the pcm0_dr pins.
 * 0b00: pcm0_dr goes to internal slave pcm0 unit
 * 0b01: pcm1_dr goes to internal slave pcm0 unit
 * 0b10: pcm2_dr goes to internal slave pcm0 unit
 */
#define IAXXX_CNR0_PCM_MX1_PCM0_RXD_SEL_MASK 0x00000003
#define IAXXX_CNR0_PCM_MX1_PCM0_RXD_SEL_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX1_PCM0_RXD_SEL_POS 0
#define IAXXX_CNR0_PCM_MX1_PCM0_RXD_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX1_PCM0_RXD_SEL_DECL (1:0)

/*
 * Select pcm1_din source (for internal slave pcm1) from the pcm1_dr pins.
 * 0b00: pcm0_dr goes to internal slave pcm1 unit
 * 0b01: pcm1_dr goes to internal slave pcm1 unit
 * 0b10: pcm2_dr goes to internal slave pcm1 unit
 */
#define IAXXX_CNR0_PCM_MX1_PCM1_RXD_SEL_MASK 0x0000000c
#define IAXXX_CNR0_PCM_MX1_PCM1_RXD_SEL_RESET_VAL 0x1
#define IAXXX_CNR0_PCM_MX1_PCM1_RXD_SEL_POS 2
#define IAXXX_CNR0_PCM_MX1_PCM1_RXD_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX1_PCM1_RXD_SEL_DECL (3:2)

/*
 * Select pcm2_din source (for internal slave pcm2) from the pcm2_dr pins.
 * 0b00: pcm0_dr goes to internal slave pcm2 unit
 * 0b01: pcm1_dr goes to internal slave pcm2 unit
 * 0b10: pcm2_dr goes to internal slave pcm2 unit
 */
#define IAXXX_CNR0_PCM_MX1_PCM2_RXD_SEL_MASK 0x00000030
#define IAXXX_CNR0_PCM_MX1_PCM2_RXD_SEL_RESET_VAL 0x2
#define IAXXX_CNR0_PCM_MX1_PCM2_RXD_SEL_POS 4
#define IAXXX_CNR0_PCM_MX1_PCM2_RXD_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX1_PCM2_RXD_SEL_DECL (5:4)

/*** CNR0_PCM_MX2 (0x4004004c) ***/
/*
 * The PCM Multiplexer 2 register controls the PCM loopback source; and
 * routes output data from internal slave PCM units to specified output ports
 * or forces output data to 0.  Note that there are 3 pcm ports from pads
 * which are used for pcm functions, and in the D4080, these pcm port
 * connections can come various actual IO PADS.
 */
#define IAXXX_CNR0_PCM_MX2_ADDR (0x4004004c)
#define IAXXX_CNR0_PCM_MX2_MASK_VAL 0x00000fff
#define IAXXX_CNR0_PCM_MX2_RMASK_VAL 0x00000fff
#define IAXXX_CNR0_PCM_MX2_WMASK_VAL 0x00000fff
#define IAXXX_CNR0_PCM_MX2_RESET_VAL 0x00000120

/*
 * 0: Slave pcm0_din comes from regular external source (the pcm[(0:2)]_dr
 * pins).
 * 1: Slave pcm0_din comes from slave pcm0_do.
 */
#define IAXXX_CNR0_PCM_MX2_PCM0_LOOPBACK_MASK 0x00000001
#define IAXXX_CNR0_PCM_MX2_PCM0_LOOPBACK_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM0_LOOPBACK_POS 0
#define IAXXX_CNR0_PCM_MX2_PCM0_LOOPBACK_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM0_LOOPBACK_DECL 0

/*
 * 0: Slave pcm1_din comes from regular external source (the pcm[(0:2)]_dr
 * pins).
 * 1: Slave pcm1_din comes from slave pcm1_do.
 */
#define IAXXX_CNR0_PCM_MX2_PCM1_LOOPBACK_MASK 0x00000002
#define IAXXX_CNR0_PCM_MX2_PCM1_LOOPBACK_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM1_LOOPBACK_POS 1
#define IAXXX_CNR0_PCM_MX2_PCM1_LOOPBACK_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM1_LOOPBACK_DECL 1

/*
 * 0: Slave pcm2_din comes from regular external source (the pcm[(0:2)]_dr
 * pins).
 * 1: Slave pcm2_din comes from slave pcm2_do.
 */
#define IAXXX_CNR0_PCM_MX2_PCM2_LOOPBACK_MASK 0x00000004
#define IAXXX_CNR0_PCM_MX2_PCM2_LOOPBACK_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM2_LOOPBACK_POS 2
#define IAXXX_CNR0_PCM_MX2_PCM2_LOOPBACK_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM2_LOOPBACK_DECL 2

/*
 * Select source of pcm0dt pins from one of the 3 slave pcm units
 * 0b00: Route pcm0 internal slave unit output to pcm0dt,
 * 0b01: Route pcm1 internal slave unit output to pcm0dt,
 * 0b10: Route pcm2 internal slave unit output to pcm0dt,
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_SEL_MASK 0x00000018
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_SEL_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_SEL_POS 3
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_SEL_DECL (4:3)

/*
 * Select source of pcm1dt pins from one of the 3 slave pcm units
 * 0b00: Route pcm0 internal slave unit output to pcm1dt,
 * 0b01: Route pcm1 internal slave unit output to pcm1dt,
 * 0b10: Route pcm2 internal slave unit output to pcm1dt,
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_SEL_MASK 0x00000060
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_SEL_RESET_VAL 0x1
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_SEL_POS 5
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_SEL_DECL (6:5)

/*
 * Select source of pcm2dt pins from one of the 3 slave pcm units
 * 0b00: Route pcm0 internal slave unit output to pcm2dt,
 * 0b01: Route pcm1 internal slave unit output to pcm2dt,
 * 0b10: Route pcm2 internal slave unit output to pcm2dt,
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_SEL_MASK 0x00000180
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_SEL_RESET_VAL 0x2
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_SEL_POS 7
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_SEL_SIZE 2
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_SEL_DECL (8:7)

/*
 * If it is set to 1, force 0 data that goes to the mux (to select PCM
 * internal slave unit output or pcm_dr ports)
 * before going to pcm0_dt. It also forces pcm0_dt as output
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_FORCE0_MASK 0x00000200
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_FORCE0_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_FORCE0_POS 9
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_FORCE0_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM_PORT0_DO_FORCE0_DECL 9

/*
 * If it is set to 1, force 0 data that goes to the mux (to select PCM
 * internal slave unit output or pcm_dr ports)
 * before going to pcm1_dt. It also forces pcm1_dt as output
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_FORCE0_MASK 0x00000400
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_FORCE0_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_FORCE0_POS 10
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_FORCE0_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM_PORT1_DO_FORCE0_DECL 10

/*
 * If it is set to 1, force 0 data that goes to the mux (to select PCM
 * internal slave unit output or pcm_dr ports)
 * before going to pcm2_dt. It also forces pcm2_dt as output
 */
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_FORCE0_MASK 0x00000800
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_FORCE0_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_FORCE0_POS 11
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_FORCE0_SIZE 1
#define IAXXX_CNR0_PCM_MX2_PCM_PORT2_DO_FORCE0_DECL 11

/*** CNR0_PCM_MX3 (0x40040050) ***/
/*
 * The PCM Multiplexer 3 register controls the PCM master source; and routes
 * output data from I2S master units to specified PORT_CLK/PORT_FS.  Note
 * that there are 3 pcm ports from pads which are used for passthru
 * functions, and in the D4080, these pcm port pads can come various actual
 * IO PADS.
 */
#define IAXXX_CNR0_PCM_MX3_ADDR (0x40040050)
#define IAXXX_CNR0_PCM_MX3_MASK_VAL 0x001fffff
#define IAXXX_CNR0_PCM_MX3_RMASK_VAL 0x001fffff
#define IAXXX_CNR0_PCM_MX3_WMASK_VAL 0x001fffff
#define IAXXX_CNR0_PCM_MX3_RESET_VAL 0x001ac688

/*
 * 0x0: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT0_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT0_SEL_MASK 0x00000007
#define IAXXX_CNR0_PCM_MX3_I2S_PORT0_SEL_RESET_VAL 0x0
#define IAXXX_CNR0_PCM_MX3_I2S_PORT0_SEL_POS 0
#define IAXXX_CNR0_PCM_MX3_I2S_PORT0_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT0_SEL_DECL (2:0)

/*
 * 0x0: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT1_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT1_SEL_MASK 0x00000038
#define IAXXX_CNR0_PCM_MX3_I2S_PORT1_SEL_RESET_VAL 0x1
#define IAXXX_CNR0_PCM_MX3_I2S_PORT1_SEL_POS 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT1_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT1_SEL_DECL (5:3)

/*
 * 0x0: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT2_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT2_SEL_MASK 0x000001c0
#define IAXXX_CNR0_PCM_MX3_I2S_PORT2_SEL_RESET_VAL 0x2
#define IAXXX_CNR0_PCM_MX3_I2S_PORT2_SEL_POS 6
#define IAXXX_CNR0_PCM_MX3_I2S_PORT2_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT2_SEL_DECL (8:6)

/*
 * 0x0: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT3_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT3_SEL_MASK 0x00000e00
#define IAXXX_CNR0_PCM_MX3_I2S_PORT3_SEL_RESET_VAL 0x3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT3_SEL_POS 9
#define IAXXX_CNR0_PCM_MX3_I2S_PORT3_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT3_SEL_DECL (11:9)

/*
 * 0x0: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT4_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT4_SEL_MASK 0x00007000
#define IAXXX_CNR0_PCM_MX3_I2S_PORT4_SEL_RESET_VAL 0x4
#define IAXXX_CNR0_PCM_MX3_I2S_PORT4_SEL_POS 12
#define IAXXX_CNR0_PCM_MX3_I2S_PORT4_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT4_SEL_DECL (14:12)

/*
 * 0x0: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT5_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT5_SEL_MASK 0x00038000
#define IAXXX_CNR0_PCM_MX3_I2S_PORT5_SEL_RESET_VAL 0x5
#define IAXXX_CNR0_PCM_MX3_I2S_PORT5_SEL_POS 15
#define IAXXX_CNR0_PCM_MX3_I2S_PORT5_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT5_SEL_DECL (17:15)

/*
 * 0x0: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 0.
 * 0x1: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 1.
 * 0x2: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 2.
 * 0x3: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 3.
 * 0x4: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 4.
 * 0x5: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 5.
 * 0x6: The pd0 I2S_PORT6_CLK/FS comes from internal i2s master 6.
 */
#define IAXXX_CNR0_PCM_MX3_I2S_PORT6_SEL_MASK 0x001c0000
#define IAXXX_CNR0_PCM_MX3_I2S_PORT6_SEL_RESET_VAL 0x6
#define IAXXX_CNR0_PCM_MX3_I2S_PORT6_SEL_POS 18
#define IAXXX_CNR0_PCM_MX3_I2S_PORT6_SEL_SIZE 3
#define IAXXX_CNR0_PCM_MX3_I2S_PORT6_SEL_DECL (20:18)

/*** CNR0_CIC_CTRL (0x40040054) ***/
/*
 * This register has control registers for cic combo.  These are globals for
 * the cic, and not related to individual cic chains.
 */
#define IAXXX_CNR0_CIC_CTRL_ADDR (0x40040054)
#define IAXXX_CNR0_CIC_CTRL_MASK_VAL 0x00000002
#define IAXXX_CNR0_CIC_CTRL_RMASK_VAL 0x00000002
#define IAXXX_CNR0_CIC_CTRL_WMASK_VAL 0x00000002
#define IAXXX_CNR0_CIC_CTRL_RESET_VAL 0x00000000

/*
 * Allows passthru from cdc adc 0 and cdc adc 1 input channels to dmic0_do
 * output.  In order for this to work, the source for ADC0_CLK and DMIC0_CLK
 * must be the same; i.e. programmed to use the same i2s master generator.
 * In addition, the associated enables in ADC0_ENABLE (channels 0 and 1)
 * register and DMIC0_ENABLE (tx channels 0 and 1) register must be enabled.
 */
#define IAXXX_CNR0_CIC_CTRL_ADC_TO_DMIC_MASK 0x00000002
#define IAXXX_CNR0_CIC_CTRL_ADC_TO_DMIC_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CTRL_ADC_TO_DMIC_POS 1
#define IAXXX_CNR0_CIC_CTRL_ADC_TO_DMIC_SIZE 1
#define IAXXX_CNR0_CIC_CTRL_ADC_TO_DMIC_DECL 1

/*** CNR0_CIC_CLOCK_CTRL (0x40040058) ***/
/*
 * This register has clock control registers for cic combo and the trigger
 * circuits.
 * The following legend applies to all CIC related registers below. The
 * IO_CNTRL registers for pins are used to select cic-type functions for
 * those pins.
 * -
 * CLOCKS:
 * CDC0/1_CLK are clocks available from various chip pins.  The exact ones
 * are determined by the CDC0/1_CLK_AND_SEL fields in IO_CTRL.
 * DMIC0/1_CLK are clocks available from various chip pins.  The exact ones
 * are determined by the PDM0/1_CLK_AND_SEL fields in IO_CTRL.
 *
 SWRS0_CLK is the pins SWR_CLK.  SWRS0_CLK is not available in this chip.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_ADDR (0x40040058)
#define IAXXX_CNR0_CIC_CLOCK_CTRL_MASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RMASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_CLOCK_CTRL_WMASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RESET_VAL 0x00000000

/*
 * Alternate clock select for RX CIC0.  Works in concert with MIC_0, S_0 and
 * CLK_EN_0 fields in CIC_RX_RT_CTRL register.
 * 0: Chooses the base clock: either CDC0_CLK, DMIC0_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 * 1: Chooses the alt clock:  either CDC1_CLK, DMIC1_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_0_POS 0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_0_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_0_DECL 0

/*
 * Alternate clock select for RX CIC1.  Works in concert with MIC_1, S_1 and
 * CLK_EN_1 fields in CIC_RX_RT_CTRL register.
 * 0: Chooses the base clock: either CDC0_CLK, DMIC0_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 * 1: Chooses the alt clock:  either CDC1_CLK, DMIC1_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_1_MASK 0x00000002
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_1_POS 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_1_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_1_DECL 1

/*
 * Alternate clock select for RX CIC2.  Works in concert with MIC_2, S_2 and
 * CLK_EN_2 fields in CIC_RX_RT_CTRL register.
 * 0: Chooses the base clock: either CDC0_CLK, DMIC0_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 * 1: Chooses the alt clock:  either CDC1_CLK, DMIC1_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_2_MASK 0x00000004
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_2_POS 2
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_2_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_2_DECL 2

/*
 * Alternate clock select for RX CIC3.  Works in concert with MIC_3, S_3 and
 * CLK_EN_3 fields in CIC_RX_RT_CTRL register.
 * 0: Chooses the base clock: either CDC0_CLK, DMIC0_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 * 1: Chooses the alt clock:  either CDC1_CLK, DMIC1_CLK or SWRS0_CLK.
 * SWRS0_CLK is not available in this chip.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_3_MASK 0x00000008
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_3_POS 3
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_3_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_RX_AC_3_DECL 3

/*
 * Alternate clock select for TX CIC0. Works in concert with MIC_0, S_0 and
 * CLK_EN_0 fields in CIC_TX_RT_CTRL register.
 * If using DMICs, bits TX_AC_0 and TX_AC_1 normally MUST be programmed the
 * same way since DMICs are stereo pairs. However, current chip now supports
 * unpaired modes where they can programmed differently.
 * 0: Chooses the base clock: either CDC0_CLK, or DMIC0_CLK.
 * 1: Chooses the alt clock:  either CDC1_CLK, or DMIC1_CLK.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_0_MASK 0x00000010
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_0_POS 4
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_0_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_0_DECL 4

/*
 * Alternate clock select for TX CIC1. Works in concert with MIC_1, S_1 and
 * CLK_EN_1 fields in CIC_TX_RT_CTRL register.
 * If using DMICs, bits TX_AC_1 and TX_AC_2 normally MUST be programmed the
 * same way since DMICs are stereo pairs. However, current chip now supports
 * unpaired modes where they can programmed differently.
 * 0: Chooses the base clock: either CDC0_CLK, or DMIC0_CLK.
 * 1: Chooses the alt clock:  either CDC1_CLK, or DMIC1_CLK.
 */
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_1_MASK 0x00000020
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_1_POS 5
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_1_SIZE 1
#define IAXXX_CNR0_CIC_CLOCK_CTRL_TX_AC_1_DECL 5

/*** CNR0_CIC_POL_CTRL (0x4004005c) ***/
/*
 * This register has control registers for cic combo.
 * The following legend applies to all CIC related registers below. The
 * IO_CNTRL registers for pins are used to select cic-type functions for
 * those pins.
 * -
 * DATA INPUTS
 * Data inputs are routed to RX CIC0 - RX CIC3.
 *
 CDC_ADC0-CDC_ADC3 are mono data pins from various chip pins which are
 * selected with the CDC_ADC_IN*_AND_SEL fields in IO_CTRL.
 * They are routed to rx cic0 - rx cic3, in order.
 *
 DMIC0(L/R)-DMIC1(L/R) are stereo data pins various chip pins which are
 * selected with the DMIC_DI*_AND_SEL fields in IO_CTRL.  In the pinlist,
 * they are also referred to as functions: dmic_di0, dmic_di1, respectively
 * (each has L/R channels, since they are stereo).
 * They are routed to rx cic0 - rx cic3, in order.
 * -
 * DATA OUTPUTS
 * Data inputs are routed from TX CIC0 - TX CIC1.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_ADDR (0x4004005c)
#define IAXXX_CNR0_CIC_POL_CTRL_MASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_POL_CTRL_RMASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_POL_CTRL_WMASK_VAL 0x0000003f
#define IAXXX_CNR0_CIC_POL_CTRL_RESET_VAL 0x00000000

/*
 * If not set, input 1-bit data has polarity 1'b1->+1 and 1'b0->-1.  If set,
 * input 1-bit data has polarity 1'b1->-1 and 1'b0->+1.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_0_POS 0
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_0_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_0_DECL 0

/*
 * If not set, input 1-bit data has polarity 1'b1->+1 and 1'b0->-1.  If set,
 * input 1-bit data has polarity 1'b1->-1 and 1'b0->+1.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_1_MASK 0x00000002
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_1_POS 1
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_1_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_1_DECL 1

/*
 * If not set, input 1-bit data has polarity 1'b1->+1 and 1'b0->-1.  If set,
 * input 1-bit data has polarity 1'b1->-1 and 1'b0->+1.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_2_MASK 0x00000004
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_2_POS 2
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_2_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_2_DECL 2

/*
 * If not set, input 1-bit data has polarity 1'b1->+1 and 1'b0->-1.  If set,
 * input 1-bit data has polarity 1'b1->-1 and 1'b0->+1.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_3_MASK 0x00000008
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_3_POS 3
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_3_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_RX_POL_3_DECL 3

/*
 * If not set, input 1-bit data has polarity: 1'b1->+1 and 1'b0->-1.  If set,
 * output 1-bit data has polarity: 1'b1->-1 and 1'b0->+1.
 * If using DMICs, bits TX_POL_0 and TX_POL_1 MUST be programmed the same way
 * if the DMICs are stereo pairs. However, current chip now supports unpaired
 * modes where they can programmed differently.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_0_MASK 0x00000010
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_0_POS 4
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_0_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_0_DECL 4

/*
 * If not set, input 1-bit data has polarity: 1'b1->+1 and 1'b0->-1.  If set,
 * output 1-bit data has polarity: 1'b1->-1 and 1'b0->+1.
 * If using DMICs, bits TX_POL_1 and TX_POL_2 MUST be programmed the same way
 * if the DMICs are stereo pairs. However, current chip now supports unpaired
 * modes where they can programmed differently.
 */
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_1_MASK 0x00000020
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_1_POS 5
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_1_SIZE 1
#define IAXXX_CNR0_CIC_POL_CTRL_TX_POL_1_DECL 5

/*** CNR0_CIC_RX_RT_CTRL (0x40040060) ***/
/*
 * This register has all the route control for RX CIC0 - CIC1.  Fields are
 * MIC_[X] (chooses which mic interface to use (SWR Slave or DMIC), S_[X]
 * (chooses between mic interface and the cdc interface), and CLK_EN_[X]
 * (enables the similarly selected clock).  This register should be
 * quasi-static -> changing it is only allowed if the associated enable
 * registers are disabled.
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_ADDR (0x40040060)
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MASK_VAL 0x0000eeee
#define IAXXX_CNR0_CIC_RX_RT_CTRL_RMASK_VAL 0x0000eeee
#define IAXXX_CNR0_CIC_RX_RT_CTRL_WMASK_VAL 0x0000eeee
#define IAXXX_CNR0_CIC_RX_RT_CTRL_RESET_VAL 0x00000000

/*
 * Mic Interface Select for RX CIC0 (Clock and Input)
 * 0: DMIC (Channel 0L input) and DMIC[0/1]_CLK
 * 1: Swire Slave (Port 0 input) and SWRS[0/1]_CLK.  SWRS is not available in
 * this chip.
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_0_MASK 0x00000002
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_0_POS 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_0_DECL 1

/*
 * Interface Select for RX CIC0
 * 0: Codec (CDC ADC mono) Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_0_MASK 0x00000004
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_0_POS 2
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_0_DECL 2

/*
 * Clock Enable for RX CIC0
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_0_MASK 0x00000008
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_0_POS 3
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_0_DECL 3

/*
 * Mic Interface Select for RX CIC1 (Clock and Input)
 * 0: DMIC (Channel 0R input) and DMIC[0/1]_CLK
 * 1: Swire Slave (Port 1 input) and SWRS[0/1]_CLK.  SWRS is not available in
 * this chip.
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_1_MASK 0x00000020
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_1_POS 5
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_1_DECL 5

/*
 * Interface Select for RX CIC1
 * 0: Codec (CDC ADC mono) Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_1_MASK 0x00000040
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_1_POS 6
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_1_DECL 6

/*
 * Clock Enable for RX CIC1
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_1_MASK 0x00000080
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_1_POS 7
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_1_DECL 7

/*
 * Mic Interface Select for RX CIC2 (Clock and Input)
 * 0: DMIC (Channel 1L input) and DMIC[0/1]_CLK
 * 1: Swire Slave (Port 2 input) and SWRS[0/1]_CLK.  SWRS is not available in
 * this chip.
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_2_MASK 0x00000200
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_2_POS 9
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_2_DECL 9

/*
 * Interface Select for RX CIC2
 * 0: Codec (CDC ADC mono) Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_2_MASK 0x00000400
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_2_POS 10
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_2_DECL 10

/*
 * Clock Enable for RX CIC2
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_2_MASK 0x00000800
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_2_POS 11
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_2_DECL 11

/*
 * Mic Interface Select for RX CIC3 (Clock and Input)
 * 0: DMIC (Channel 1R input) and DMIC[0/1]_CLK
 * 1: Swire Slave (Port 3 input) and SWRS[0/1]_CLK.  SWRS is not available in
 * this chip.
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_3_MASK 0x00002000
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_3_POS 13
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_MIC_3_DECL 13

/*
 * Interface Select for RX CIC3
 * 0: Codec (CDC ADC mono) Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_3_MASK 0x00004000
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_3_POS 14
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_S_3_DECL 14

/*
 * Clock Enable for RX CIC3
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_3_MASK 0x00008000
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_3_POS 15
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_RT_CTRL_CLK_EN_3_DECL 15

/*** CNR0_CIC_TX_RT_CTRL (0x40040064) ***/
/*
 * This register has all the route control for TX CIC0 - CIC1.  Fields are
 * MIC_[X] (chooses which mic interface to use (SWR Slave or DMIC), S_[X]
 * (chooses between mic interface and the cdc interface), and CLK_EN_[X]
 * (enables the similarly selected clock).  This register should be
 * quasi-static -> changing it is only allowed if the associated enable
 * registers are disabled.  MUST be programmed to the same value for stereo
 * (paired) operation.  However, current chip now supports unpaired modes
 * where they can programmed differently.
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_ADDR (0x40040064)
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MASK_VAL 0x010000ee
#define IAXXX_CNR0_CIC_TX_RT_CTRL_RMASK_VAL 0x010000ee
#define IAXXX_CNR0_CIC_TX_RT_CTRL_WMASK_VAL 0x010000ee
#define IAXXX_CNR0_CIC_TX_RT_CTRL_RESET_VAL 0x00000044

/*
 * Mic Interface Select for TX CIC0 (Clock and Output)
 * 0: DMIC (Channel 0L output) and DMIC[0/1]_CLK
 * 1: Swire Slave (Channel 0 port output) and SWRS[0/1]_CLK.  SWRS is not
 * available in this chip.
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_0_MASK 0x00000002
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_0_POS 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_0_DECL 1

/*
 * Interface Select for TX CIC0
 * 0: Codec Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_0_MASK 0x00000004
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_0_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_0_POS 2
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_0_DECL 2

/*
 * Clock Enable for TX CIC0
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_0_MASK 0x00000008
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_0_POS 3
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_0_DECL 3

/*
 * Mic Interface Select for TX CIC1 (Clock and Output)
 * 0: DMIC (Channel 0R output) and DMIC[0/1]_CLK
 * 1: Swire Slave (Channel 0.5 port output) and SWRS[0/1]_CLK.  SWRS is not
 * available in this chip.
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_1_MASK 0x00000020
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_1_POS 5
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_MIC_1_DECL 5

/*
 * Interface Select for TX CIC1
 * 0: Codec Interface Select (Clock and Input)
 * 1: Mic Interface Select (Clock and Input)
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_1_MASK 0x00000040
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_1_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_1_POS 6
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_S_1_DECL 6

/*
 * Clock Enable for TX CIC1
 * 0: Clock Disabled
 * 1: Clock Enabled
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_1_MASK 0x00000080
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_1_POS 7
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_CLK_EN_1_DECL 7

/*
 * NOTE -> this bit is only for non-paired modes!  In non-paired modes, the
 * CIC TX0 is routed to the first dmic output, with CIC TX1 routing to the
 * second dmic output.  This bit flips that so that TX1 is seen on the first
 * dmic output and TX0 on the second dmic output.
 */
#define IAXXX_CNR0_CIC_TX_RT_CTRL_FLIP_DATA_0_1_MASK 0x01000000
#define IAXXX_CNR0_CIC_TX_RT_CTRL_FLIP_DATA_0_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_RT_CTRL_FLIP_DATA_0_1_POS 24
#define IAXXX_CNR0_CIC_TX_RT_CTRL_FLIP_DATA_0_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_RT_CTRL_FLIP_DATA_0_1_DECL 24

/*** CNR0_CIC_TRG_CTRL (0x40040068) ***/
/*
 * This register has control for clock polarity of generator and detector.
 * This register should be quasi-static -> changing it is only allowed if the
 * associated enable registers are disabled.
 */
#define IAXXX_CNR0_CIC_TRG_CTRL_ADDR (0x40040068)
#define IAXXX_CNR0_CIC_TRG_CTRL_MASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TRG_CTRL_RMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TRG_CTRL_WMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TRG_CTRL_RESET_VAL 0x00000001

/*
 * Clock polarity for generator.
 * 0: Posedge
 * 1: Negedge
 */
#define IAXXX_CNR0_CIC_TRG_CTRL_GEN_CLK_POL_MASK 0x00000001
#define IAXXX_CNR0_CIC_TRG_CTRL_GEN_CLK_POL_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_TRG_CTRL_GEN_CLK_POL_POS 0
#define IAXXX_CNR0_CIC_TRG_CTRL_GEN_CLK_POL_SIZE 1
#define IAXXX_CNR0_CIC_TRG_CTRL_GEN_CLK_POL_DECL 0

/*
 * Interface Select for trigger generator
 * 0: Posedge
 * 1: Negedge
 */
#define IAXXX_CNR0_CIC_TRG_CTRL_DET_CLK_POL_MASK 0x00000002
#define IAXXX_CNR0_CIC_TRG_CTRL_DET_CLK_POL_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TRG_CTRL_DET_CLK_POL_POS 1
#define IAXXX_CNR0_CIC_TRG_CTRL_DET_CLK_POL_SIZE 1
#define IAXXX_CNR0_CIC_TRG_CTRL_DET_CLK_POL_DECL 1

/*** CNR0_CIC_RX_0_1 (0x4004006c) ***/
/*
 * This register has the control state for CIC RX 0 and CIC RX 1.
 */
#define IAXXX_CNR0_CIC_RX_0_1_ADDR (0x4004006c)
#define IAXXX_CNR0_CIC_RX_0_1_MASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_0_1_RMASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_0_1_WMASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_0_1_RESET_VAL 0x00000000

/*
 * Clear state value for CIC RX 0.
 */
#define IAXXX_CNR0_CIC_RX_0_1_CLR_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_RX_0_1_CLR_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_CLR_0_POS 0
#define IAXXX_CNR0_CIC_RX_0_1_CLR_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_0_1_CLR_0_DECL 0

/*
 * Left shift for CIC RX 0 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_0_MASK 0x0000003c
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_0_POS 2
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_0_SIZE 4
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_0_DECL (5:2)

/*
 * Decimation ratio for CIC RX 0 -> Output 1 sample for every M+1 input
 * samples
 */
#define IAXXX_CNR0_CIC_RX_0_1_M_0_MASK 0x000007c0
#define IAXXX_CNR0_CIC_RX_0_1_M_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_M_0_POS 6
#define IAXXX_CNR0_CIC_RX_0_1_M_0_SIZE 5
#define IAXXX_CNR0_CIC_RX_0_1_M_0_DECL (10:6)

/*
 * 0: Order of CIC filter for CIC RX 0 is 3.
 * 1: Order of CIC filter for CIC RX 0 is 4.
 */
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_0_MASK 0x00000800
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_0_POS 11
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_0_DECL 11

/*
 * Clear state value for CIC RX 1.
 */
#define IAXXX_CNR0_CIC_RX_0_1_CLR_1_MASK 0x00001000
#define IAXXX_CNR0_CIC_RX_0_1_CLR_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_CLR_1_POS 12
#define IAXXX_CNR0_CIC_RX_0_1_CLR_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_0_1_CLR_1_DECL 12

/*
 * Left shift for CIC RX 1 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_1_MASK 0x0003c000
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_1_POS 14
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_1_SIZE 4
#define IAXXX_CNR0_CIC_RX_0_1_LSHIFT_1_DECL (17:14)

/*
 * Decimation ratio for CIC RX 1 -> Output 1 sample for every M+1 input
 * samples
 */
#define IAXXX_CNR0_CIC_RX_0_1_M_1_MASK 0x007c0000
#define IAXXX_CNR0_CIC_RX_0_1_M_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_M_1_POS 18
#define IAXXX_CNR0_CIC_RX_0_1_M_1_SIZE 5
#define IAXXX_CNR0_CIC_RX_0_1_M_1_DECL (22:18)

/*
 * 0: Order of CIC filter for CIC RX 1 is 3.
 * 1: Order of CIC filter for CIC RX 1 is 4.
 */
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_1_MASK 0x00800000
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_1_POS 23
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_0_1_ORDER_1_DECL 23

/*** CNR0_CIC_RX_2_3 (0x40040070) ***/
/*
 * This register has the control state for CIC RX 2 and CIC RX 3.
 */
#define IAXXX_CNR0_CIC_RX_2_3_ADDR (0x40040070)
#define IAXXX_CNR0_CIC_RX_2_3_MASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_2_3_RMASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_2_3_WMASK_VAL 0x00ffdffd
#define IAXXX_CNR0_CIC_RX_2_3_RESET_VAL 0x00000000

/*
 * Clear state value for CIC RX 2.
 */
#define IAXXX_CNR0_CIC_RX_2_3_CLR_2_MASK 0x00000001
#define IAXXX_CNR0_CIC_RX_2_3_CLR_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_CLR_2_POS 0
#define IAXXX_CNR0_CIC_RX_2_3_CLR_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_2_3_CLR_2_DECL 0

/*
 * Left shift for CIC RX 2 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_2_MASK 0x0000003c
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_2_POS 2
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_2_SIZE 4
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_2_DECL (5:2)

/*
 * Decimation ratio for CIC RX 2 -> Output 1 sample for every M+1 input
 * samples
 */
#define IAXXX_CNR0_CIC_RX_2_3_M_2_MASK 0x000007c0
#define IAXXX_CNR0_CIC_RX_2_3_M_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_M_2_POS 6
#define IAXXX_CNR0_CIC_RX_2_3_M_2_SIZE 5
#define IAXXX_CNR0_CIC_RX_2_3_M_2_DECL (10:6)

/*
 * 0: Order of CIC filter for CIC RX 2 is 3.
 * 1: Order of CIC filter for CIC RX 2 is 4.
 */
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_2_MASK 0x00000800
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_2_POS 11
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_2_DECL 11

/*
 * Clear state value for CIC RX 3.
 */
#define IAXXX_CNR0_CIC_RX_2_3_CLR_3_MASK 0x00001000
#define IAXXX_CNR0_CIC_RX_2_3_CLR_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_CLR_3_POS 12
#define IAXXX_CNR0_CIC_RX_2_3_CLR_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_2_3_CLR_3_DECL 12

/*
 * Left shift for CIC RX 3 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_3_MASK 0x0003c000
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_3_POS 14
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_3_SIZE 4
#define IAXXX_CNR0_CIC_RX_2_3_LSHIFT_3_DECL (17:14)

/*
 * Decimation ratio for CIC RX 3 -> Output 1 sample for every M+1 input
 * samples
 */
#define IAXXX_CNR0_CIC_RX_2_3_M_3_MASK 0x007c0000
#define IAXXX_CNR0_CIC_RX_2_3_M_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_M_3_POS 18
#define IAXXX_CNR0_CIC_RX_2_3_M_3_SIZE 5
#define IAXXX_CNR0_CIC_RX_2_3_M_3_DECL (22:18)

/*
 * 0: Order of CIC filter for CIC RX 3 is 3.
 * 1: Order of CIC filter for CIC RX 3 is 4.
 */
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_3_MASK 0x00800000
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_3_POS 23
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_2_3_ORDER_3_DECL 23

/*** CNR0_CIC_TX_0_1 (0x40040074) ***/
/*
 * This register has the control state for CIC TX 0 and CIC TX 1.  MUST be
 * programmed to the same values for stereo (paired) operation.  However,
 * current chip now supports unpaired modes where they can programmed
 * differently.
 */
#define IAXXX_CNR0_CIC_TX_0_1_ADDR (0x40040074)
#define IAXXX_CNR0_CIC_TX_0_1_MASK_VAL 0xffffffff
#define IAXXX_CNR0_CIC_TX_0_1_RMASK_VAL 0xffffffff
#define IAXXX_CNR0_CIC_TX_0_1_WMASK_VAL 0xffffffff
#define IAXXX_CNR0_CIC_TX_0_1_RESET_VAL 0x00000000

/*
 * Clear state value for CIC TX 0.
 */
#define IAXXX_CNR0_CIC_TX_0_1_CLR_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_TX_0_1_CLR_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_CLR_0_POS 0
#define IAXXX_CNR0_CIC_TX_0_1_CLR_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_CLR_0_DECL 0

/*
 * 0: Order of CIC filter for CIC TX 0 is 3.
 * 1: Order of CIC filter for CIC TX 0 is 4.
 */
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_0_MASK 0x00000002
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_0_POS 1
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_0_DECL 1

/*
 * 0: Output enable is 0.
 * 1: Output enable is 1. Associated channel (L or R) is driven out depending
 * ond the DMIC0/1_ENABLE value for the TX channels.  In non-paired mode,
 * refers to TX0 output enable on first dmic output.
 */
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_0_MASK 0x00000004
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_0_POS 2
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_0_DECL 2

/*
 * Interpolation ratio for CIC TX 0 -> Output L+1 sample for every input
 * sample
 */
#define IAXXX_CNR0_CIC_TX_0_1_L_0_MASK 0x000000f8
#define IAXXX_CNR0_CIC_TX_0_1_L_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_L_0_POS 3
#define IAXXX_CNR0_CIC_TX_0_1_L_0_SIZE 5
#define IAXXX_CNR0_CIC_TX_0_1_L_0_DECL (7:3)

/*
 * Left shift for CIC TX 0 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_0_MASK 0x00000f00
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_0_POS 8
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_0_SIZE 4
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_0_DECL (11:8)

/*
 * Set to 1 to enable Dither on CIC TX0 output, or set to 0 if no dither is
 * to be used.  This dither is added at the SDM stage of the filter chain.
 */
#define IAXXX_CNR0_CIC_TX_0_1_D_0_MASK 0x00001000
#define IAXXX_CNR0_CIC_TX_0_1_D_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_D_0_POS 12
#define IAXXX_CNR0_CIC_TX_0_1_D_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_D_0_DECL 12

/*
 * Dither Scale on CIC TX0 output.
 */
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_0_MASK 0x00006000
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_0_POS 13
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_0_SIZE 2
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_0_DECL (14:13)

/*
 * 0: TX0 data on both clock phases.
 * 1: TX0 data on low clock phase, TX1 data on high phase.  In non-paired
 * mode, TX0 is always selected (unless the associated
 * CIC_TX_RT_CTRL_FLIP_DATA bit is set.
 */
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_0_MASK 0x00008000
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_0_POS 15
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_0_DECL 15

/*
 * Clear state value for CIC TX 1.
 */
#define IAXXX_CNR0_CIC_TX_0_1_CLR_1_MASK 0x00010000
#define IAXXX_CNR0_CIC_TX_0_1_CLR_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_CLR_1_POS 16
#define IAXXX_CNR0_CIC_TX_0_1_CLR_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_CLR_1_DECL 16

/*
 * 0: Order of CIC filter for CIC TX 1 is 3.
 * 1: Order of CIC filter for CIC TX 1 is 4.
 */
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_1_MASK 0x00020000
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_1_POS 17
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_ORDER_1_DECL 17

/*
 * In stereo (paired) mode, this bit ignored and the PHASE_0 is used.  In
 * non-paired mode, refers to TX0 output enable on second dmic output.
 */
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_1_MASK 0x00040000
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_1_POS 18
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_PHASE_1_DECL 18

/*
 * Interpolation ratio for CIC TX 1 -> Output L+1 sample for every input
 * sample
 */
#define IAXXX_CNR0_CIC_TX_0_1_L_1_MASK 0x00f80000
#define IAXXX_CNR0_CIC_TX_0_1_L_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_L_1_POS 19
#define IAXXX_CNR0_CIC_TX_0_1_L_1_SIZE 5
#define IAXXX_CNR0_CIC_TX_0_1_L_1_DECL (23:19)

/*
 * Left shift for CIC TX 1 -> Shift the CIC Output left by LSHIFT bits
 */
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_1_MASK 0x0f000000
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_1_POS 24
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_1_SIZE 4
#define IAXXX_CNR0_CIC_TX_0_1_LSHIFT_1_DECL (27:24)

/*
 * Set to 1 to enable Dither on CIC 1 output, or set to 0 if no dither is to
 * be used.  This dither is added at the SDM stage of the filter chain.
 */
#define IAXXX_CNR0_CIC_TX_0_1_D_1_MASK 0x10000000
#define IAXXX_CNR0_CIC_TX_0_1_D_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_D_1_POS 28
#define IAXXX_CNR0_CIC_TX_0_1_D_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_D_1_DECL 28

/*
 * Dither Scale on CIC TX 1 output.
 */
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_1_MASK 0x60000000
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_1_POS 29
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_1_SIZE 2
#define IAXXX_CNR0_CIC_TX_0_1_DSCALE_1_DECL (30:29)

/*
 * In stereo (paired) mode, this bit ignored and the DSEL_0 is used.  In
 * non-paired mode, TX1 is always selected (unless the associated
 * CIC_TX_RT_CTRL_FLIP_DATA bit is set.
 */
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_1_MASK 0x80000000
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_1_POS 31
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_0_1_DSEL_1_DECL 31

/*** CNR0_CIC_RX_ADTL_CTRL (0x40040078) ***/
/*
 * This register has additional control state for all the rx cics.
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_ADDR (0x40040078)
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_MASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_RMASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_WMASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_RESET_VAL 0x000000aa

/*
 * Scale CIC_RX_0 before HB by 64/81 .
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_0_POS 0
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_0_DECL 0

/*
 * Debug mode for CIC_RX_0.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_RX_0 by setting based on the decimation ratio.
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_0_MASK 0x00000002
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_0_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_0_POS 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_0_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_0_DECL 1

/*
 * Scale CIC_RX_1 before HB by 64/81 .
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_1_MASK 0x00000004
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_1_POS 2
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_1_DECL 2

/*
 * Debug mode for CIC_RX_1.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_RX_1 by setting based on the decimation ratio.
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_1_MASK 0x00000008
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_1_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_1_POS 3
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_1_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_1_DECL 3

/*
 * Scale CIC_RX_2 before HB by 64/81 .
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_2_MASK 0x00000010
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_2_POS 4
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_2_DECL 4

/*
 * Debug mode for CIC_RX_2.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_RX_2 by setting based on the decimation ratio.
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_2_MASK 0x00000020
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_2_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_2_POS 5
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_2_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_2_DECL 5

/*
 * Scale CIC_RX_3 before HB by 64/81 .
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_3_MASK 0x00000040
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_3_POS 6
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_G_RX_3_DECL 6

/*
 * Debug mode for CIC_RX_3.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_RX_3 by setting based on the decimation ratio.
 */
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_3_MASK 0x00000080
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_3_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_3_POS 7
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_3_SIZE 1
#define IAXXX_CNR0_CIC_RX_ADTL_CTRL_DBG_RX_3_DECL 7

/*** CNR0_CIC_TX_ADTL_CTRL (0x4004007c) ***/
/*
 * This register has additional control state for all the tx cics.
 */
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_ADDR (0x4004007c)
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_MASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_RMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_WMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_RESET_VAL 0x0000000a

/*
 * Scale CIC_TX_0 before HB by 8/9
 * If using DMICs, bits G_TX_0 and G_TX_1 must be programmed the same way
 * since DMICs are stereo pairs.
 */
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_0_POS 0
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_0_DECL 0

/*
 * Debug mode for CIC_TX_0.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_TX_0 by setting based on the interpolation ratio.
 * If using DMICs, bits DBG_TX_0 and DBG_TX_1 must be programmed the same way
 * since DMICs are stereo pairs.
 */
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_0_MASK 0x00000002
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_0_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_0_POS 1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_0_SIZE 1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_0_DECL 1

/*
 * Scale CIC_TX_1 before HB by 8/9
 */
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_1_MASK 0x00000004
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_1_POS 2
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_G_TX_1_DECL 2

/*
 * Debug mode for CIC_TX_1.  If set, all parameters need user programming
 * (this is equivalent to previous chip setup). If not set, we override
 * order, lshift and G_TX_1 by setting based on the interpolation ratio.
 */
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_1_MASK 0x00000008
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_1_RESET_VAL 0x1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_1_POS 3
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_1_SIZE 1
#define IAXXX_CNR0_CIC_TX_ADTL_CTRL_DBG_TX_1_DECL 3

/*** CNR0_CIC_RX_HB (0x40040080) ***/
/*
 * This register has the control for all the CIC RX HalfBand filters:
 * CIC_RX_0 - CIC_RX_3
 */
#define IAXXX_CNR0_CIC_RX_HB_ADDR (0x40040080)
#define IAXXX_CNR0_CIC_RX_HB_MASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_HB_RMASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_HB_WMASK_VAL 0x000000ff
#define IAXXX_CNR0_CIC_RX_HB_RESET_VAL 0x000000ff

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 */
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_0_MASK 0x00000003
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_0_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_0_POS 0
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_0_SIZE 2
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_0_DECL (1:0)

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 */
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_1_MASK 0x0000000c
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_1_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_1_POS 2
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_1_SIZE 2
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_1_DECL (3:2)

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 */
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_2_MASK 0x00000030
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_2_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_2_POS 4
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_2_SIZE 2
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_2_DECL (5:4)

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 */
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_3_MASK 0x000000c0
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_3_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_3_POS 6
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_3_SIZE 2
#define IAXXX_CNR0_CIC_RX_HB_CIC_RX_3_DECL (7:6)

/*** CNR0_CIC_TX_HB (0x40040084) ***/
/*
 * This register has the control for all the CIC TX HalfBand filters:
 * CIC_TX_0 - CIC_TX_1.
 */
#define IAXXX_CNR0_CIC_TX_HB_ADDR (0x40040084)
#define IAXXX_CNR0_CIC_TX_HB_MASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_HB_RMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_HB_WMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_TX_HB_RESET_VAL 0x0000000f

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 * If using DMICs, bits CIC_TX_0 and CIC_TX_1 MUST be programmed the same way
 * since DMICs are stereo pairs.  However, current chip now supports unpaired
 * modes where they can programmed differently.
 */
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_0_MASK 0x00000003
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_0_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_0_POS 0
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_0_SIZE 2
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_0_DECL (1:0)

/*
 * 00: Passthru.
 * 01: Decimate by 2.
 * 10: Decimate by 4.
 * 11: Reserved (mux bypass the HB for testing).
 */
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_1_MASK 0x0000000c
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_1_RESET_VAL 0x3
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_1_POS 2
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_1_SIZE 2
#define IAXXX_CNR0_CIC_TX_HB_CIC_TX_1_DECL (3:2)

/*** CNR0_CDC0_EXT_SYNC_MODE (0x40040088) ***/
/*
 * This register has setup bits for various external synchronization modes.
 * NOTE -> to correctly synchronize a write to this register, read access to
 * CDC0_EXT_SYNC_MODE_BUSY until it reads back a 0 is REQUIRED!.
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_ADDR (0x40040088)
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_MASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_RMASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_WMASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_RESET_VAL 0x00000000

/*
 * Allow external synchronization detection operation for CDC0 CLK paths,
 * where we enable synchronously from an external DETected synchronization
 * event instead of the current regular register write.  This only sets the
 * mode, and it must be armed by a write to the CDC0_ENABLE_BUSY register.
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_MASK 0x00000001
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_POS 0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SIZE 1
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_DECL 0

/*
 * Enable external synchronization generation operation for CDC0 CLK paths,
 * where we enable a synchronous external synchronization event in this clock
 * domain.  If this bit is set, no equivalent bit in other _EXT_SYNC_MODE
 * register should be set since we have only 1 external sync out.
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_GEN_MASK 0x00000002
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_GEN_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_GEN_POS 1
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_GEN_SIZE 1
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_GEN_DECL 1

/*
 * CDC0 detector source.
 * PCM ON Enable 0-2 : 0-2
 * PCM Fsync 0-2  : 3-5
 * Ext sync       : 6
 * None           : 7
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SRC_MASK 0x000001c0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SRC_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SRC_POS 6
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SRC_SIZE 3
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_SRC_DECL (8:6)

/*
 * CDC0 detector edge.
 * 00 - Rising Edge
 * 01 - Falling Edge
 * 10 - Both Edges
 * 11 - No detection
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_EDGE_MASK 0x00000c00
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_EDGE_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_EDGE_POS 10
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_EDGE_SIZE 2
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_DET_EDGE_DECL (11:10)

/*** CNR0_CDC0_EXT_SYNC_MODE_BUSY (0x4004008c) ***/
/*
 * This register indicates, if not busy, that a write to CDC0_EXT_SYNC_MODE
 * was correctly done.  Access to CDC0_ENABLE can then be done with external
 * synchronization modes now available.
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_ADDR (0x4004008c)
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to CDC0_EXT_SYNC_MODE is NOT busy.
 * 1: Write to CDC0_EXT_SYNC_MODE is busy.
 */
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_B_POS 0
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_B_SIZE 1
#define IAXXX_CNR0_CDC0_EXT_SYNC_MODE_BUSY_B_DECL 0

/*** CNR0_CDC0_ENABLE (0x40040090) ***/
/*
 * This register has the enables for CDC0 paths -> for paths clocked by
 * CDC0_CLK.  NOTE -> to correctly synchronize a write to this register, an
 * access to a CNR0 register is required, with CDC0_ENABLE_BUSY read being
 * recommended.  Normally, writing this register triggers synchronization.
 * However, if we want external synchronization, set CDC0_EXT_SYNC_MODE.DET
 * first before accessing this register. A write to this register will arm
 * the detector.  NOTE -> Writing all zeros the the enables serves as an
 * asynchronous reset for all CDC0_CLK circuits.
 */
#define IAXXX_CNR0_CDC0_ENABLE_ADDR (0x40040090)
#define IAXXX_CNR0_CDC0_ENABLE_MASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC0_ENABLE_RMASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC0_ENABLE_WMASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC0_ENABLE_RESET_VAL 0x00000000

/*
 * Enable CDC0 CLK paths.  For TX ports, bits [(9:8)] are not currently used.
 * For RX ports, bits [3/2/1/0] which are
 * [CDC_ADC_3/CDC_ADC2/CDC_ADC1/CDC_ADC0].
 */
#define IAXXX_CNR0_CDC0_ENABLE_E_MASK 0x000003ff
#define IAXXX_CNR0_CDC0_ENABLE_E_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_ENABLE_E_POS 0
#define IAXXX_CNR0_CDC0_ENABLE_E_SIZE 10
#define IAXXX_CNR0_CDC0_ENABLE_E_DECL (9:0)

/*
 * CDC0_CLK debug enable. This is a clock enable override.
 */
#define IAXXX_CNR0_CDC0_ENABLE_DBG_MASK 0x80000000
#define IAXXX_CNR0_CDC0_ENABLE_DBG_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_ENABLE_DBG_POS 31
#define IAXXX_CNR0_CDC0_ENABLE_DBG_SIZE 1
#define IAXXX_CNR0_CDC0_ENABLE_DBG_DECL 31

/*** CNR0_CDC0_ENABLE_BUSY (0x40040094) ***/
/*
 * This register indicates, if not busy, that a write to CDC0_ENABLE can be
 * safely made.  NOTE -> if CDC0_EXT_SYNC_MODE DET is set, the busy will be
 * cleared by the external synchronization trigger, and this readback value
 * isn't as useful.
 */
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_ADDR (0x40040094)
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to CDC0_ENABLE is NOT busy.
 * 1: Write to CDC0_ENABLE is busy.
 */
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_B_POS 0
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_B_SIZE 1
#define IAXXX_CNR0_CDC0_ENABLE_BUSY_B_DECL 0

/*** CNR0_CDC1_EXT_SYNC_MODE (0x40040098) ***/
/*
 * This register has setup bits for various external synchronization modes.
 * NOTE -> to correctly synchronize a write to this register, read access to
 * CDC1_EXT_SYNC_MODE_BUSY until it reads back a 0 is REQUIRED!.
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_ADDR (0x40040098)
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_MASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_RMASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_WMASK_VAL 0x00000dc3
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_RESET_VAL 0x00000000

/*
 * Allow external synchronization detection operation for CDC1 CLK paths,
 * where we enable synchronously from an external DETected synchronization
 * event instead of the current regular register write.  This only sets the
 * mode, and it must be armed by a write to the CDC1_ENABLE_BUSY register.
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_MASK 0x00000001
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_POS 0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SIZE 1
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_DECL 0

/*
 * Enable external synchronization generation operation for CDC1 CLK paths,
 * where we enable a synchronous external synchronization event in this clock
 * domain.  If this bit is set, no equivalent bit in other _EXT_SYNC_MODE
 * register should be set since we have only 1 external sync out.
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_GEN_MASK 0x00000002
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_GEN_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_GEN_POS 1
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_GEN_SIZE 1
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_GEN_DECL 1

/*
 * CDC1 detector source.
 * PCM ON Enable 0-2 : 0-2
 * PCM Fsync 0-2  : 3-5
 * Ext sync       : 6
 * None           : 7
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SRC_MASK 0x000001c0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SRC_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SRC_POS 6
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SRC_SIZE 3
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_SRC_DECL (8:6)

/*
 * CDC1 detector edge.
 * 00 - Rising Edge
 * 01 - Falling Edge
 * 10 - Both Edges
 * 11 - No detection
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_EDGE_MASK 0x00000c00
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_EDGE_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_EDGE_POS 10
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_EDGE_SIZE 2
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_DET_EDGE_DECL (11:10)

/*** CNR0_CDC1_EXT_SYNC_MODE_BUSY (0x4004009c) ***/
/*
 * This register indicates, if not busy, that a write to CDC1_EXT_SYNC_MODE
 * was correctly done.  Access to CDC1_ENABLE can then be done with external
 * synchronization modes now available.
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_ADDR (0x4004009c)
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to CDC1_EXT_SYNC_MODE is NOT busy.
 * 1: Write to CDC1_EXT_SYNC_MODE is busy.
 */
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_B_POS 0
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_B_SIZE 1
#define IAXXX_CNR0_CDC1_EXT_SYNC_MODE_BUSY_B_DECL 0

/*** CNR0_CDC1_ENABLE (0x400400a0) ***/
/*
 * This register has the enables for CDC1 paths -> for paths clocked by
 * CDC1_CLK.  NOTE -> to correctly synchronize a write to this register, an
 * access to a CNR0 register is required, with CDC1_ENABLE_BUSY read being
 * recommended.  Normally, writing this register triggers synchronization.
 * However, if we want external synchronization, set CDC1_EXT_SYNC_MODE.DET
 * first before accessing this register. A write to this register will arm
 * the detector.  NOTE -> Writing all zeros the the enables serves as an
 * asynchronous reset for all CDC1_CLK circuits.
 */
#define IAXXX_CNR0_CDC1_ENABLE_ADDR (0x400400a0)
#define IAXXX_CNR0_CDC1_ENABLE_MASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC1_ENABLE_RMASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC1_ENABLE_WMASK_VAL 0x800003ff
#define IAXXX_CNR0_CDC1_ENABLE_RESET_VAL 0x00000000

/*
 * Enable CDC1 CLK paths.  For TX ports, bits [(9:8)] are not currently used.
 * For RX ports, bits [3/2/1/0] which are
 * [CDC_ADC_3/CDC_ADC2/CDC_ADC1/CDC_ADC0].
 */
#define IAXXX_CNR0_CDC1_ENABLE_E_MASK 0x000003ff
#define IAXXX_CNR0_CDC1_ENABLE_E_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_ENABLE_E_POS 0
#define IAXXX_CNR0_CDC1_ENABLE_E_SIZE 10
#define IAXXX_CNR0_CDC1_ENABLE_E_DECL (9:0)

/*
 * CDC1_CLK debug enable. This is a clock enable override.
 */
#define IAXXX_CNR0_CDC1_ENABLE_DBG_MASK 0x80000000
#define IAXXX_CNR0_CDC1_ENABLE_DBG_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_ENABLE_DBG_POS 31
#define IAXXX_CNR0_CDC1_ENABLE_DBG_SIZE 1
#define IAXXX_CNR0_CDC1_ENABLE_DBG_DECL 31

/*** CNR0_CDC1_ENABLE_BUSY (0x400400a4) ***/
/*
 * This register indicates, if not busy, that a write to CDC1_ENABLE can be
 * safely made.  NOTE -> if CDC1_EXT_SYNC_MODE DET is set, the busy will be
 * cleared by the external synchronization trigger, and this readback value
 * isn't as useful.
 */
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_ADDR (0x400400a4)
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to CDC1_ENABLE is NOT busy.
 * 1: Write to CDC1_ENABLE is busy.
 */
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_B_POS 0
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_B_SIZE 1
#define IAXXX_CNR0_CDC1_ENABLE_BUSY_B_DECL 0

/*** CNR0_DMIC0_EXT_SYNC_MODE (0x400400a8) ***/
/*
 * This register has setup bits for various external synchronization modes.
 * NOTE -> to correctly synchronize a write to this register, read access to
 * CDC0_EXT_SYNC_MODE_BUSY until it reads back a 0 is REQUIRED!.
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_ADDR (0x400400a8)
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_MASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_RMASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_WMASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_RESET_VAL 0x00000000

/*
 * Allow external synchronization detection operation for DMIC0 CLK paths,
 * where we enable synchronously from an external DETected synchronization
 * event instead of the current regular register write.  This only sets the
 * mode, and it must be armed by a write to the DMIC0_ENABLE_BUSY register.
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_MASK 0x00000001
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_POS 0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SIZE 1
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_DECL 0

/*
 * Enable external synchronization generation operation for DMIC0 CLK paths,
 * where we enable a synchronous external synchronization event in this clock
 * domain.  If this bit is set, no equivalent bit in other _EXT_SYNC_MODE
 * register should be set since we have only 1 external sync out.
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_GEN_MASK 0x00000002
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_GEN_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_GEN_POS 1
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_GEN_SIZE 1
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_GEN_DECL 1

/*
 * DMIC0 detector source.
 * PCM ON Enable 0-2 : 0-2
 * PCM Fsync 0-2  : 3-5
 * Ext sync       : 6
 * None           : 7
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SRC_MASK 0x000001c0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SRC_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SRC_POS 6
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SRC_SIZE 3
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_SRC_DECL (8:6)

/*
 * DMIC0 detector edge.
 * 00 - Rising Edge
 * 01 - Falling Edge
 * 10 - Both Edges
 * 11 - No detection
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_EDGE_MASK 0x00000c00
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_EDGE_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_EDGE_POS 10
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_EDGE_SIZE 2
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_DET_EDGE_DECL (11:10)

/*** CNR0_DMIC0_EXT_SYNC_MODE_BUSY (0x400400ac) ***/
/*
 * This register indicates, if not busy, that a write to DMIC0_EXT_SYNC_MODE
 * was correctly done.  Access to DMIC0_ENABLE can then be done with external
 * synchronization mode now available.
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_ADDR (0x400400ac)
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to DMIC0_EXT_SYNC_MODE is NOT busy.
 * 1: Write to DMIC0_EXT_SYNC_MODE is busy.
 */
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_B_POS 0
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_B_SIZE 1
#define IAXXX_CNR0_DMIC0_EXT_SYNC_MODE_BUSY_B_DECL 0

/*** CNR0_DMIC0_ENABLE (0x400400b0) ***/
/*
 * This register has the enables for DMIC0 paths -> for paths clocked by
 * DMIC0_CLK.  NOTE -> to correctly synchronize a write to this register, an
 * access to a CNR0 register is required, with DMIC0_ENABLE_BUSY read being
 * recommended.  Normally, writing this register triggers synchronization.
 * However, if we want external synchronization, set DMIC0_EXT_SYNC_MODE.DET
 * first before accessing this register. A write to this register will arm
 * the detector.  NOTE -> Writing all zeros the the enables serves as an
 * asynchronous reset for all DMIC0_CLK circuits.
 */
#define IAXXX_CNR0_DMIC0_ENABLE_ADDR (0x400400b0)
#define IAXXX_CNR0_DMIC0_ENABLE_MASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC0_ENABLE_RMASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC0_ENABLE_WMASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC0_ENABLE_RESET_VAL 0x00000000

/*
 * Enable DMIC0_CLK paths. For TX ports, bits [(9:8)] are 0R/0L, and for RX
 * ports, bits [3/2/1/0] are 1R/1L//2R/2L/1R/1L/0R/0L -> L is left channel, R
 * is right channel.
 */
#define IAXXX_CNR0_DMIC0_ENABLE_E_MASK 0x000003ff
#define IAXXX_CNR0_DMIC0_ENABLE_E_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_ENABLE_E_POS 0
#define IAXXX_CNR0_DMIC0_ENABLE_E_SIZE 10
#define IAXXX_CNR0_DMIC0_ENABLE_E_DECL (9:0)

/*
 * DMIC0_CLK debug enable. This is a clock enable override.
 */
#define IAXXX_CNR0_DMIC0_ENABLE_DBG_MASK 0x80000000
#define IAXXX_CNR0_DMIC0_ENABLE_DBG_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_ENABLE_DBG_POS 31
#define IAXXX_CNR0_DMIC0_ENABLE_DBG_SIZE 1
#define IAXXX_CNR0_DMIC0_ENABLE_DBG_DECL 31

/*** CNR0_DMIC0_ENABLE_BUSY (0x400400b4) ***/
/*
 * This register indicates, if not busy, that a write to DMIC0_ENABLE can be
 * safely made.  NOTE -> if DMIC0_EXT_SYNC_MODE DET is set, the busy will be
 * cleared by the external synchronization trigger, and this readback value
 * isn't as useful.
 */
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_ADDR (0x400400b4)
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to DMIC0_ENABLE is NOT busy.
 * 1: Write to DMIC0_ENABLE is busy.
 */
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_B_POS 0
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_B_SIZE 1
#define IAXXX_CNR0_DMIC0_ENABLE_BUSY_B_DECL 0

/*** CNR0_DMIC1_EXT_SYNC_MODE (0x400400b8) ***/
/*
 * This register has setup bits for various external synchronization modes.
 * NOTE -> to correctly synchronize a write to this register, read access to
 * CDC1_EXT_SYNC_MODE_BUSY until it reads back a 0 is REQUIRED!.
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_ADDR (0x400400b8)
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_MASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_RMASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_WMASK_VAL 0x00000dc3
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_RESET_VAL 0x00000000

/*
 * Allow external synchronization detection operation for DMIC1 CLK paths,
 * where we enable synchronously from an external DETected synchronization
 * event instead of the current regular register write.  This only sets the
 * mode, and it must be armed by a write to the DMIC1_ENABLE_BUSY register.
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_MASK 0x00000001
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_POS 0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SIZE 1
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_DECL 0

/*
 * Enable external synchronization generation operation for DMIC1 CLK paths,
 * where we enable a synchronous external synchronization event in this clock
 * domain.  If this bit is set, no equivalent bit in other _EXT_SYNC_MODE
 * register should be set since we have only 1 external sync out.
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_GEN_MASK 0x00000002
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_GEN_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_GEN_POS 1
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_GEN_SIZE 1
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_GEN_DECL 1

/*
 * DMIC1 detector source.
 * PCM ON Enable 0-2 : 0-2
 * PCM Fsync 0-2  : 3-5
 * Ext sync       : 6
 * None           : 7
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SRC_MASK 0x000001c0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SRC_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SRC_POS 6
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SRC_SIZE 3
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_SRC_DECL (8:6)

/*
 * DMIC1 detector edge.
 * 00 - Rising Edge
 * 01 - Falling Edge
 * 10 - Both Edges
 * 11 - No detection
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_EDGE_MASK 0x00000c00
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_EDGE_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_EDGE_POS 10
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_EDGE_SIZE 2
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_DET_EDGE_DECL (11:10)

/*** CNR0_DMIC1_EXT_SYNC_MODE_BUSY (0x400400bc) ***/
/*
 * This register indicates, if not busy, that a write to DMIC1_EXT_SYNC_MODE
 * was correctly done.  Access to DMIC1_ENABLE can then be done with external
 * synchronization mode now available.
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_ADDR (0x400400bc)
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to DMIC1_EXT_SYNC_MODE is NOT busy.
 * 1: Write to DMIC1_EXT_SYNC_MODE is busy.
 */
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_B_POS 0
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_B_SIZE 1
#define IAXXX_CNR0_DMIC1_EXT_SYNC_MODE_BUSY_B_DECL 0

/*** CNR0_DMIC1_ENABLE (0x400400c0) ***/
/*
 * This register has the enables for DMIC1 paths -> for paths clocked by
 * DMIC1_CLK.  NOTE -> to correctly synchronize a write to this register, an
 * access to a CNR0 register is required, with DMIC1_ENABLE_BUSY read being
 * recommended.  Normally, writing this register triggers synchronization.
 * However, if we want external synchronization, set DMIC1_EXT_SYNC_MODE.DET
 * first before accessing this register. A write to this register will arm
 * the detector.  NOTE -> Writing all zeros the the enables serves as an
 * asynchronous reset for all DMIC1_CLK circuits.
 */
#define IAXXX_CNR0_DMIC1_ENABLE_ADDR (0x400400c0)
#define IAXXX_CNR0_DMIC1_ENABLE_MASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC1_ENABLE_RMASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC1_ENABLE_WMASK_VAL 0x800003ff
#define IAXXX_CNR0_DMIC1_ENABLE_RESET_VAL 0x00000000

/*
 * Enable DMIC1_CLK paths. For TX ports, bits [(9:8)] are 0R/0L, and for RX
 * ports, bits [3/2/1/0] are 1R/1L//2R/2L/1R/1L/0R/0L -> L is left channel, R
 * is right channel.
 */
#define IAXXX_CNR0_DMIC1_ENABLE_E_MASK 0x000003ff
#define IAXXX_CNR0_DMIC1_ENABLE_E_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_ENABLE_E_POS 0
#define IAXXX_CNR0_DMIC1_ENABLE_E_SIZE 10
#define IAXXX_CNR0_DMIC1_ENABLE_E_DECL (9:0)

/*
 * DMIC1_CLK debug enable. This is a clock enable override.
 */
#define IAXXX_CNR0_DMIC1_ENABLE_DBG_MASK 0x80000000
#define IAXXX_CNR0_DMIC1_ENABLE_DBG_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_ENABLE_DBG_POS 31
#define IAXXX_CNR0_DMIC1_ENABLE_DBG_SIZE 1
#define IAXXX_CNR0_DMIC1_ENABLE_DBG_DECL 31

/*** CNR0_DMIC1_ENABLE_BUSY (0x400400c4) ***/
/*
 * This register indicates, if not busy, that a write to DMIC1_ENABLE can be
 * safely made.  NOTE -> if DMIC1_EXT_SYNC_MODE DET is set, the busy will be
 * cleared by the external synchronization trigger, and this readback value
 * isn't as useful.
 */
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_ADDR (0x400400c4)
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_MASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_RMASK_VAL 0x00000001
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to DMIC1_ENABLE is NOT busy.
 * 1: Write to DMIC1_ENABLE is busy.
 */
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_B_MASK 0x00000001
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_B_RESET_VAL 0x0
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_B_POS 0
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_B_SIZE 1
#define IAXXX_CNR0_DMIC1_ENABLE_BUSY_B_DECL 0

/*** CNR0_EXT_SYNC_GEN (0x400400d8) ***/
/*
 * Normally, writing this register triggers a external synchronization
 * trigger event.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_ADDR (0x400400d8)
#define IAXXX_CNR0_EXT_SYNC_GEN_MASK_VAL 0x00000001
#define IAXXX_CNR0_EXT_SYNC_GEN_RMASK_VAL 0x00000000
#define IAXXX_CNR0_EXT_SYNC_GEN_WMASK_VAL 0x00000001
#define IAXXX_CNR0_EXT_SYNC_GEN_RESET_VAL 0x00000000

/*
 * A write of 1 to this register generates a trigger that serves as the
 * external synchronization event.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_TRG_MASK 0x00000001
#define IAXXX_CNR0_EXT_SYNC_GEN_TRG_RESET_VAL 0x0
#define IAXXX_CNR0_EXT_SYNC_GEN_TRG_POS 0
#define IAXXX_CNR0_EXT_SYNC_GEN_TRG_SIZE 1
#define IAXXX_CNR0_EXT_SYNC_GEN_TRG_DECL 0

/*** CNR0_EXT_SYNC_GEN_BUSY (0x400400dc) ***/
/*
 * This register indicates, if not busy, that a write to EXT_SYNC_GEN can be
 * safely made and we can generate another external synchronization event.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_ADDR (0x400400dc)
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_MASK_VAL 0x0000000f
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_RMASK_VAL 0x0000000f
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_WMASK_VAL 0x00000000
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_RESET_VAL 0x00000000

/*
 * 0: Write to EXT_SYNC_GEN is NOT busy for CDC0.
 * 1: Write to EXT_SYNC_GEN is busy for CDC0.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC0_MASK 0x00000001
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC0_RESET_VAL 0x0
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC0_POS 0
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC0_SIZE 1
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC0_DECL 0

/*
 * 0: Write to EXT_SYNC_GEN is NOT busy for CDC1.
 * 1: Write to EXT_SYNC_GEN is busy for CDC1.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC1_MASK 0x00000002
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC1_RESET_VAL 0x0
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC1_POS 1
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC1_SIZE 1
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_CDC1_DECL 1

/*
 * 0: Write to EXT_SYNC_GEN is NOT busy for DMIC0.
 * 1: Write to EXT_SYNC_GEN is busy for DMIC0.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC0_MASK 0x00000004
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC0_RESET_VAL 0x0
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC0_POS 2
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC0_SIZE 1
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC0_DECL 2

/*
 * 0: Write to EXT_SYNC_GEN is NOT busy for DMIC1.
 * 1: Write to EXT_SYNC_GEN is busy for DMIC1.
 */
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC1_MASK 0x00000008
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC1_RESET_VAL 0x0
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC1_POS 3
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC1_SIZE 1
#define IAXXX_CNR0_EXT_SYNC_GEN_BUSY_B_DMIC1_DECL 3

/*** CNR0_CIC_RX_HOS (0x400400e0) ***/
/*
 * This register is used to configure the CIC RX fifos and ports into
 * phyiscal streams.  This registers should be quasi-static.
 */
#define IAXXX_CNR0_CIC_RX_HOS_ADDR (0x400400e0)
#define IAXXX_CNR0_CIC_RX_HOS_MASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RX_HOS_RMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RX_HOS_WMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RX_HOS_RESET_VAL 0x00000000

/*
 * 0: Port is not a head of stream.
 * 1: Port is a head of stream.
 */
#define IAXXX_CNR0_CIC_RX_HOS_VAL_MASK 0x0000000f
#define IAXXX_CNR0_CIC_RX_HOS_VAL_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RX_HOS_VAL_POS 0
#define IAXXX_CNR0_CIC_RX_HOS_VAL_SIZE 4
#define IAXXX_CNR0_CIC_RX_HOS_VAL_DECL (3:0)

/*** CNR0_CIC_TX_HOS (0x400400e4) ***/
/*
 * This register is used to configure the CIC TX fifos and ports into
 * phyiscal streams.  This registers should be quasi-static.
 */
#define IAXXX_CNR0_CIC_TX_HOS_ADDR (0x400400e4)
#define IAXXX_CNR0_CIC_TX_HOS_MASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TX_HOS_RMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TX_HOS_WMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_TX_HOS_RESET_VAL 0x00000000

/*
 * 0: Port is not a head of stream.
 * 1: Port is a head of stream.
 */
#define IAXXX_CNR0_CIC_TX_HOS_VAL_MASK 0x00000003
#define IAXXX_CNR0_CIC_TX_HOS_VAL_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_TX_HOS_VAL_POS 0
#define IAXXX_CNR0_CIC_TX_HOS_VAL_SIZE 2
#define IAXXX_CNR0_CIC_TX_HOS_VAL_DECL (1:0)

/*** CNR0_CIC_RAW_RXCOHERR (0x400400e8) ***/
/*
 * Contains the RAW latched (sticky bit) RX coherency error flags for each
 * cic.  A write of a "1" to any bit will clear that bit.
 */
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_ADDR (0x400400e8)
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_MASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_RMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_WMASK_VAL 0x0000000f
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_RESET_VAL 0x00000000

/*
 * A Raw RX coherency  Error Condition has occurred for CIC 0.
 */
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_0_POS 0
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_0_SIZE 1
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_0_DECL 0

/*
 * A Raw RX coherency  Error Condition has occurred for CIC 1.
 */
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_1_MASK 0x00000002
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_1_POS 1
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_1_SIZE 1
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_1_DECL 1

/*
 * A Raw RX coherency  Error Condition has occurred for CIC 2.
 */
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_2_MASK 0x00000004
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_2_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_2_POS 2
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_2_SIZE 1
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_2_DECL 2

/*
 * A Raw RX coherency  Error Condition has occurred for CIC 3.
 */
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_3_MASK 0x00000008
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_3_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_3_POS 3
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_3_SIZE 1
#define IAXXX_CNR0_CIC_RAW_RXCOHERR_E_3_DECL 3

/*** CNR0_CIC_RAW_TXCOHERR (0x400400ec) ***/
/*
 * Contains the RAW latched (sticky bit) TX coherency error flags for each
 * cic.  A write of a "1" to any bit will clear that bit.
 */
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_ADDR (0x400400ec)
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_MASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_RMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_WMASK_VAL 0x00000003
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_RESET_VAL 0x00000000

/*
 * A Raw TX coherency  Error Condition has occurred for CIC 0.
 */
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_0_MASK 0x00000001
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_0_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_0_POS 0
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_0_SIZE 1
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_0_DECL 0

/*
 * A Raw TX coherency  Error Condition has occurred for CIC 1.
 */
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_1_MASK 0x00000002
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_1_RESET_VAL 0x0
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_1_POS 1
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_1_SIZE 1
#define IAXXX_CNR0_CIC_RAW_TXCOHERR_E_1_DECL 1

/*** CNR0_SPARE_GATES_0 (0x400400f0) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_CNR0_SPARE_GATES_0_ADDR (0x400400f0)
#define IAXXX_CNR0_SPARE_GATES_0_MASK_VAL 0xffffffff
#define IAXXX_CNR0_SPARE_GATES_0_RMASK_VAL 0xffffffff
#define IAXXX_CNR0_SPARE_GATES_0_WMASK_VAL 0x0000ffff
#define IAXXX_CNR0_SPARE_GATES_0_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_1_MASK 0x0000ffff
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_1_RESET_VAL 0x0
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_1_POS 0
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_1_SIZE 16
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_2_MASK 0xffff0000
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_2_RESET_VAL 0x0
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_2_POS 16
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_2_SIZE 16
#define IAXXX_CNR0_SPARE_GATES_0_FIELD_2_DECL (31:16)

/*** CNR0_SPARE_GATES_1 (0x400400f4) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_CNR0_SPARE_GATES_1_ADDR (0x400400f4)
#define IAXXX_CNR0_SPARE_GATES_1_MASK_VAL 0xffffffff
#define IAXXX_CNR0_SPARE_GATES_1_RMASK_VAL 0xffffffff
#define IAXXX_CNR0_SPARE_GATES_1_WMASK_VAL 0x0000ffff
#define IAXXX_CNR0_SPARE_GATES_1_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_1_MASK 0x0000ffff
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_1_RESET_VAL 0x0
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_1_POS 0
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_1_SIZE 16
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_2_MASK 0xffff0000
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_2_RESET_VAL 0x0
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_2_POS 16
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_2_SIZE 16
#define IAXXX_CNR0_SPARE_GATES_1_FIELD_2_DECL (31:16)

/* Number of registers in the module */
#define IAXXX_CNR0_REG_NUM 58

#endif /* __IAXXX_REGISTER_DEFS_CNR0_H__*/
