/*
 * iaxxx-register-defs-spi1.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_SPI1_H__
#define __IAXXX_REGISTER_DEFS_SPI1_H__

/*** The base address for this set of registers ***/
#define IAXXX_SPI1_REGS_ADDR (0x40061000)

/*** SPI1_CTRL (0x40061000) ***/
/*
 * SPI Control register to control basic configuration of SPI
 */
#define IAXXX_SPI1_CTRL_ADDR (0x40061000)
#define IAXXX_SPI1_CTRL_MASK_VAL 0x007f1fff
#define IAXXX_SPI1_CTRL_RMASK_VAL 0x001f1fff
#define IAXXX_SPI1_CTRL_WMASK_VAL 0x001f1fff
#define IAXXX_SPI1_CTRL_RESET_VAL 0x0001001f

/*
 * Word Length
 * Has to be set in the range 3 - 31
 * This means word length is WLEN+1 bits
 * Impact of this register is seen on Shift Register, Data in FIFO
 * Shift register will have a range of WLEN+1 number of bits i.e., WLEN-(1:0)
 * MSBs of data filled in the FIFO will be 0s.
 * In Tx mode, [WLEN-(1:0)] of each FIFO level is transmitted (rest of the bits
 * are discarded)
 */
#define IAXXX_SPI1_CTRL_WLEN_MASK 0x0000001f
#define IAXXX_SPI1_CTRL_WLEN_RESET_VAL 0x1f
#define IAXXX_SPI1_CTRL_WLEN_POS 0
#define IAXXX_SPI1_CTRL_WLEN_SIZE 5
#define IAXXX_SPI1_CTRL_WLEN_DECL (4:0)

/*
 * Serial Clock Phase. Selects Clock Phase for Data sampling
 * 0: When SCPOL is 0, data is captured on rising edge and launched on
 * falling edge
 *    When SCPOL is 1, data is captured on falling edge and launched on
 * rising edge
 * 1: When SCPOL is 0, data is captured on falling edge and launched on
 * rising edge
 *    When SCPOL is 1, data is captured on rising edge and launched on
 * falling edge
 */
#define IAXXX_SPI1_CTRL_SCPH_MASK 0x00000020
#define IAXXX_SPI1_CTRL_SCPH_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_SCPH_POS 5
#define IAXXX_SPI1_CTRL_SCPH_SIZE 1
#define IAXXX_SPI1_CTRL_SCPH_DECL 5

/*
 * Serial Clock Polarity. Selects Clock Polarity when inactive.
 * 0: When 0, inactive state of clock pin is 0
 * 1: When 1, inactive state of clock pin is 1
 */
#define IAXXX_SPI1_CTRL_SCPL_MASK 0x00000040
#define IAXXX_SPI1_CTRL_SCPL_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_SCPL_POS 6
#define IAXXX_SPI1_CTRL_SCPL_SIZE 1
#define IAXXX_SPI1_CTRL_SCPL_DECL 6

/*
 * Transmit Mode
 * 1: Transmit mode is enabled
 * 0: Transmit mode is disabled
 * When this bit is set to 0,
 */
#define IAXXX_SPI1_CTRL_TXMOD_MASK 0x00000080
#define IAXXX_SPI1_CTRL_TXMOD_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_TXMOD_POS 7
#define IAXXX_SPI1_CTRL_TXMOD_SIZE 1
#define IAXXX_SPI1_CTRL_TXMOD_DECL 7

/*
 * Receive Mode
 * 1: Receive mode is enabled
 * 0: Receive mode is disabled
 */
#define IAXXX_SPI1_CTRL_RXMOD_MASK 0x00000100
#define IAXXX_SPI1_CTRL_RXMOD_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_RXMOD_POS 8
#define IAXXX_SPI1_CTRL_RXMOD_SIZE 1
#define IAXXX_SPI1_CTRL_RXMOD_DECL 8

/*
 * Slave Output Enable.
 * Configuration independent on TXMOD
 * When set to 0, output is enabled by forcing pad OEN to 0
 * When set to 1, even if TXMOD is 1, data out pin is tristated
 * Note:This feature in master mode only.
 *      This feature is taken from Oban SPI where multi-master mode was
 * supported.
 *      Naming convention also was adopted from Oban SPI.
 *      In later versions, multi-master mode is not supported.
 *      Therefore in slave mode, this feature is no longer supported.
 */
#define IAXXX_SPI1_CTRL_SLV_OE_N_MASK 0x00000200
#define IAXXX_SPI1_CTRL_SLV_OE_N_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_SLV_OE_N_POS 9
#define IAXXX_SPI1_CTRL_SLV_OE_N_SIZE 1
#define IAXXX_SPI1_CTRL_SLV_OE_N_DECL 9

/*
 * Loopback mode.
 * 1: Loopback is enabled
 * 0: Loopback is disabled
 * MOSI port is connected to MISO port in this mode internally
 * When in slave mode, clock and chip select have to be provided by an
 * external source
 * Data loopback happens internally
 */
#define IAXXX_SPI1_CTRL_SRL_MASK 0x00000400
#define IAXXX_SPI1_CTRL_SRL_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_SRL_POS 10
#define IAXXX_SPI1_CTRL_SRL_SIZE 1
#define IAXXX_SPI1_CTRL_SRL_DECL 10

/*
 * Toggle Select Mode
 * 1: Toggle Select mode is enabled
 * 0: Toggle Select mode is disabled
 * When enabled, chip select toggle inbetween frames and words is expected
 */
#define IAXXX_SPI1_CTRL_TOGGLE_SS_MASK 0x00000800
#define IAXXX_SPI1_CTRL_TOGGLE_SS_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_TOGGLE_SS_POS 11
#define IAXXX_SPI1_CTRL_TOGGLE_SS_SIZE 1
#define IAXXX_SPI1_CTRL_TOGGLE_SS_DECL 11

/*
 * Mode Selection
 * 1: Master Mode
 * 0: Slave Mode
 * In Master mode, clock and chip select are generated by SPI.
 * In Slave mode, clock and chip select are sampled from pins.
 */
#define IAXXX_SPI1_CTRL_MSTR_SLV_MASK 0x00001000
#define IAXXX_SPI1_CTRL_MSTR_SLV_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_MSTR_SLV_POS 12
#define IAXXX_SPI1_CTRL_MSTR_SLV_SIZE 1
#define IAXXX_SPI1_CTRL_MSTR_SLV_DECL 12

/*
 * Slave select when in Master Mode - 1 bit per slave
 * SPI in D4100s can connect to as many as 4 slaves
 * Defaults to 1
 * Used only in Master Mode
 */
#define IAXXX_SPI1_CTRL_MSTR_SLV_SEL_MASK 0x000f0000
#define IAXXX_SPI1_CTRL_MSTR_SLV_SEL_RESET_VAL 0x1
#define IAXXX_SPI1_CTRL_MSTR_SLV_SEL_POS 16
#define IAXXX_SPI1_CTRL_MSTR_SLV_SEL_SIZE 4
#define IAXXX_SPI1_CTRL_MSTR_SLV_SEL_DECL (19:16)

/*
 * APB Clock Request generated by SPI is overridden when this bit is set
 * When set to '1', APB clock request will be '1' when SPI_EN is set to '1'
 * Note that the override is for clock request and the actual clock gate is
 * in CNR
 */
#define IAXXX_SPI1_CTRL_APB_CLK_EN_OVRD_MASK 0x00100000
#define IAXXX_SPI1_CTRL_APB_CLK_EN_OVRD_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_APB_CLK_EN_OVRD_POS 20
#define IAXXX_SPI1_CTRL_APB_CLK_EN_OVRD_SIZE 1
#define IAXXX_SPI1_CTRL_APB_CLK_EN_OVRD_DECL 20

/*
 * When written with 1, clears TxFIFO only
 * Read always returns '0'
 * TxFIFO clear takes 8 clock cycles and 1 in SR:CLK_IN_PROG indicates that
 * the FIFO clear operation is in progress
 * Note that RxFIFO state will remain unchanged after this operation
 */
#define IAXXX_SPI1_CTRL_TXFIFO_CLR_MASK 0x00200000
#define IAXXX_SPI1_CTRL_TXFIFO_CLR_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_TXFIFO_CLR_POS 21
#define IAXXX_SPI1_CTRL_TXFIFO_CLR_SIZE 1
#define IAXXX_SPI1_CTRL_TXFIFO_CLR_DECL 21

/*
 * When written with 1, clears RxFIFO only
 * Read always returns '0'
 * RxFIFO clear takes 8 clock cycles and 1 in SR:CLK_IN_PROG indicates that
 * the FIFO clear operation is in progress
 * Note that TxFIFO state will remain unchanged after this operation
 */
#define IAXXX_SPI1_CTRL_RXFIFO_CLR_MASK 0x00400000
#define IAXXX_SPI1_CTRL_RXFIFO_CLR_RESET_VAL 0x0
#define IAXXX_SPI1_CTRL_RXFIFO_CLR_POS 22
#define IAXXX_SPI1_CTRL_RXFIFO_CLR_SIZE 1
#define IAXXX_SPI1_CTRL_RXFIFO_CLR_DECL 22

/*** SPI1_SPIEN (0x40061004) ***/
/*
 * SPI Enable Register. Enables SPI. Must be written to '1' only after all
 * configuration is complete. 1->0 transition on this register clears FIFOs.
 */
#define IAXXX_SPI1_SPIEN_ADDR (0x40061004)
#define IAXXX_SPI1_SPIEN_MASK_VAL 0x00000001
#define IAXXX_SPI1_SPIEN_RMASK_VAL 0x00000001
#define IAXXX_SPI1_SPIEN_WMASK_VAL 0x00000001
#define IAXXX_SPI1_SPIEN_RESET_VAL 0x00000000

/*
 * SPI Enabled
 * 1: SPI is enabled
 * 0: SPI is disabled
 * A higher level control on SPI
 * When set to 1, SPI will remain functional.
 * When set to 0, SPI doesnt respond to any triggers - slave or master i.e.,
 * communication will not happen
 * Static configuration should be done before this bit is wrritten with '1'
 * When set to '1', APB reads are allowed by APB writes should not be done to
 * control registers
 * If a write '0' happens when this bit is set to '1' i.e., a 1->0 transition
 * happens, FIFOs are cleared
 * Register configuration can be changed when set to 1 but new configuration
 * will take affect only when SPI_EN sees a rising edge
 */
#define IAXXX_SPI1_SPIEN_SPI_EN_MASK 0x00000001
#define IAXXX_SPI1_SPIEN_SPI_EN_RESET_VAL 0x0
#define IAXXX_SPI1_SPIEN_SPI_EN_POS 0
#define IAXXX_SPI1_SPIEN_SPI_EN_SIZE 1
#define IAXXX_SPI1_SPIEN_SPI_EN_DECL 0

/*** SPI1_TXFL (0x40061008) ***/
/*
 * Used to Control TxFIFO. Note that it is recommended to program TFTH to a
 * lower value compared to TFDW. This will provide for optimum use of DMA and
 * FIFO when DMA is in use. Also note that DMA burst size should be the same
 * as TFDW for the same reason.
 */
#define IAXXX_SPI1_TXFL_ADDR (0x40061008)
#define IAXXX_SPI1_TXFL_MASK_VAL 0x00000f0f
#define IAXXX_SPI1_TXFL_RMASK_VAL 0x00000f0f
#define IAXXX_SPI1_TXFL_WMASK_VAL 0x00000f0f
#define IAXXX_SPI1_TXFL_RESET_VAL 0x00000000

/*
 * Transmit FIFO Threshold.
 * Threshold level controls FIFO fill level. Defined by SW to control Tx
 * flow.
 * Width must match FIFO depth in RTL.
 */
#define IAXXX_SPI1_TXFL_TFTH_MASK 0x0000000f
#define IAXXX_SPI1_TXFL_TFTH_RESET_VAL 0x0
#define IAXXX_SPI1_TXFL_TFTH_POS 0
#define IAXXX_SPI1_TXFL_TFTH_SIZE 4
#define IAXXX_SPI1_TXFL_TFTH_DECL (3:0)

/*
 * Transmit FIFO DMA Watermark level.
 * DMA Watermark level controls DMA accesses. Defined by SW to control Tx
 * flow.
 * Width must match FIFO depth in RTL.
 */
#define IAXXX_SPI1_TXFL_TFDW_MASK 0x00000f00
#define IAXXX_SPI1_TXFL_TFDW_RESET_VAL 0x0
#define IAXXX_SPI1_TXFL_TFDW_POS 8
#define IAXXX_SPI1_TXFL_TFDW_SIZE 4
#define IAXXX_SPI1_TXFL_TFDW_DECL (11:8)

/*** SPI1_RXFL (0x4006100c) ***/
/*
 * Used to Control RxFIFO. Note that it is recommended to program RFTH to a
 * lower value compared to RFDW. This will provide for optimum use of DMA and
 * FIFO when DMA is in use. Also note that DMA burst size should be the same
 * as RFDW for the same reason.
 */
#define IAXXX_SPI1_RXFL_ADDR (0x4006100c)
#define IAXXX_SPI1_RXFL_MASK_VAL 0x00000f0f
#define IAXXX_SPI1_RXFL_RMASK_VAL 0x00000f0f
#define IAXXX_SPI1_RXFL_WMASK_VAL 0x00000f0f
#define IAXXX_SPI1_RXFL_RESET_VAL 0x00000000

/*
 * Receive FIFO Threshold.
 * Threshold level controls FIFO fill level. Defined by SW to control Tx
 * flow.
 * Width must match FIFO depth in RTL.
 */
#define IAXXX_SPI1_RXFL_RFTH_MASK 0x0000000f
#define IAXXX_SPI1_RXFL_RFTH_RESET_VAL 0x0
#define IAXXX_SPI1_RXFL_RFTH_POS 0
#define IAXXX_SPI1_RXFL_RFTH_SIZE 4
#define IAXXX_SPI1_RXFL_RFTH_DECL (3:0)

/*
 * Receive FIFO DMA Watermark level.
 * DMA Watermark level controls DMA accesses. Defined by SW to control Tx
 * flow.
 * Width must match FIFO depth in RTL.
 */
#define IAXXX_SPI1_RXFL_RFDW_MASK 0x00000f00
#define IAXXX_SPI1_RXFL_RFDW_RESET_VAL 0x0
#define IAXXX_SPI1_RXFL_RFDW_POS 8
#define IAXXX_SPI1_RXFL_RFDW_SIZE 4
#define IAXXX_SPI1_RXFL_RFDW_DECL (11:8)

/*** SPI1_TXFLR (0x40061010) ***/
/*
 * Reflects the current fill level of TxFIFO.
 */
#define IAXXX_SPI1_TXFLR_ADDR (0x40061010)
#define IAXXX_SPI1_TXFLR_MASK_VAL 0x0000001f
#define IAXXX_SPI1_TXFLR_RMASK_VAL 0x0000001f
#define IAXXX_SPI1_TXFLR_WMASK_VAL 0x00000000
#define IAXXX_SPI1_TXFLR_RESET_VAL 0x00000000

/*
 * Transmit FIFO Current Level.
 */
#define IAXXX_SPI1_TXFLR_TXTFL_MASK 0x0000001f
#define IAXXX_SPI1_TXFLR_TXTFL_RESET_VAL 0x0
#define IAXXX_SPI1_TXFLR_TXTFL_POS 0
#define IAXXX_SPI1_TXFLR_TXTFL_SIZE 5
#define IAXXX_SPI1_TXFLR_TXTFL_DECL (4:0)

/*** SPI1_RXFLR (0x40061014) ***/
/*
 * Reflects the current fill level of RxFIFO.
 */
#define IAXXX_SPI1_RXFLR_ADDR (0x40061014)
#define IAXXX_SPI1_RXFLR_MASK_VAL 0x0000001f
#define IAXXX_SPI1_RXFLR_RMASK_VAL 0x0000001f
#define IAXXX_SPI1_RXFLR_WMASK_VAL 0x00000000
#define IAXXX_SPI1_RXFLR_RESET_VAL 0x00000000

/*
 * Receive FIFO Current Level.
 */
#define IAXXX_SPI1_RXFLR_RXTFL_MASK 0x0000001f
#define IAXXX_SPI1_RXFLR_RXTFL_RESET_VAL 0x0
#define IAXXX_SPI1_RXFLR_RXTFL_POS 0
#define IAXXX_SPI1_RXFLR_RXTFL_SIZE 5
#define IAXXX_SPI1_RXFLR_RXTFL_DECL (4:0)

/*** SPI1_SR (0x40061018) ***/
/*
 * Status Register. Status of SPI, status of FIFOs and indication of any
 * errors (for aborted transactions).
 */
#define IAXXX_SPI1_SR_ADDR (0x40061018)
#define IAXXX_SPI1_SR_MASK_VAL 0x0000003f
#define IAXXX_SPI1_SR_RMASK_VAL 0x0000003f
#define IAXXX_SPI1_SR_WMASK_VAL 0x00000000
#define IAXXX_SPI1_SR_RESET_VAL 0x0000000a

/*
 * SPI Busy Flag.
 * Indicates that SPI is active and is in active transaction
 */
#define IAXXX_SPI1_SR_BUSY_MASK 0x00000001
#define IAXXX_SPI1_SR_BUSY_RESET_VAL 0x0
#define IAXXX_SPI1_SR_BUSY_POS 0
#define IAXXX_SPI1_SR_BUSY_SIZE 1
#define IAXXX_SPI1_SR_BUSY_DECL 0

/*
 * TxFIFO Empty
 */
#define IAXXX_SPI1_SR_TFE_MASK 0x00000002
#define IAXXX_SPI1_SR_TFE_RESET_VAL 0x1
#define IAXXX_SPI1_SR_TFE_POS 1
#define IAXXX_SPI1_SR_TFE_SIZE 1
#define IAXXX_SPI1_SR_TFE_DECL 1

/*
 * TxFIFO Full
 */
#define IAXXX_SPI1_SR_TFF_MASK 0x00000004
#define IAXXX_SPI1_SR_TFF_RESET_VAL 0x0
#define IAXXX_SPI1_SR_TFF_POS 2
#define IAXXX_SPI1_SR_TFF_SIZE 1
#define IAXXX_SPI1_SR_TFF_DECL 2

/*
 * RxFIFO Empty
 */
#define IAXXX_SPI1_SR_RFE_MASK 0x00000008
#define IAXXX_SPI1_SR_RFE_RESET_VAL 0x1
#define IAXXX_SPI1_SR_RFE_POS 3
#define IAXXX_SPI1_SR_RFE_SIZE 1
#define IAXXX_SPI1_SR_RFE_DECL 3

/*
 * RxFIFO Full
 */
#define IAXXX_SPI1_SR_RFF_MASK 0x00000010
#define IAXXX_SPI1_SR_RFF_RESET_VAL 0x0
#define IAXXX_SPI1_SR_RFF_POS 4
#define IAXXX_SPI1_SR_RFF_SIZE 1
#define IAXXX_SPI1_SR_RFF_DECL 4

/*
 * FIFO clear in progress
 * When a 1->0 trasition happens on SPI_EN, FIFOs are cleared
 * FIFOs take 16 APB clocks to clear
 * This bit is an indication that FIFO clear is in progress
 * Note that writing or reading from FIFOs when this bit is set is hazardous
 * and could cause FIFO levels to get affected in adverse way
 * It is recommended that FW polls this bit before enabling SPI again (by
 * writing 1 to SPI_EN)
 */
#define IAXXX_SPI1_SR_CLR_IN_PROG_MASK 0x00000020
#define IAXXX_SPI1_SR_CLR_IN_PROG_RESET_VAL 0x0
#define IAXXX_SPI1_SR_CLR_IN_PROG_POS 5
#define IAXXX_SPI1_SR_CLR_IN_PROG_SIZE 1
#define IAXXX_SPI1_SR_CLR_IN_PROG_DECL 5

/*** SPI1_IMR (0x4006101c) ***/
/*
 * Interrupt Masking for SPI Interrupt. Each of the potential interrupt
 * sources has a mask. The mask is ANDed with corresponding RISR bit and the
 * result is provided as a read-only register - ISR. The interrupt generated
 * by SPI is OR of all the ISR bits
 */
#define IAXXX_SPI1_IMR_ADDR (0x4006101c)
#define IAXXX_SPI1_IMR_MASK_VAL 0x0003ffff
#define IAXXX_SPI1_IMR_RMASK_VAL 0x0003ffff
#define IAXXX_SPI1_IMR_WMASK_VAL 0x0003ffff
#define IAXXX_SPI1_IMR_RESET_VAL 0x00000000

/*
 * Transmit FIFO Threshold Interrupt Mask
 * 1: TxFIFO Threshold Interrupt is not masked
 * 0: TxFIFO Threshold Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXTHIM_MASK 0x00000001
#define IAXXX_SPI1_IMR_TXTHIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXTHIM_POS 0
#define IAXXX_SPI1_IMR_TXTHIM_SIZE 1
#define IAXXX_SPI1_IMR_TXTHIM_DECL 0

/*
 * Receive FIFO Threshold Interrupt Mask
 * 1: RxFIFO Threshold Interrupt is not masked
 * 0: RxFIFO Threshold Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXTHIM_MASK 0x00000002
#define IAXXX_SPI1_IMR_RXTHIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXTHIM_POS 1
#define IAXXX_SPI1_IMR_RXTHIM_SIZE 1
#define IAXXX_SPI1_IMR_RXTHIM_DECL 1

/*
 * Transmit FIFO DMA Watermark Interrupt Mask
 * 1: TxFIFO DMA Watermark Interrupt is not masked
 * 0: TxFIFO Watermak Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXDWIM_MASK 0x00000004
#define IAXXX_SPI1_IMR_TXDWIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXDWIM_POS 2
#define IAXXX_SPI1_IMR_TXDWIM_SIZE 1
#define IAXXX_SPI1_IMR_TXDWIM_DECL 2

/*
 * Receive FIFO DMA Watermark Interrupt Mask
 * 1: RxFIFO DMA Watermark Interrupt is not masked
 * 0: RxFIFO Watermak Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXDWIM_MASK 0x00000008
#define IAXXX_SPI1_IMR_RXDWIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXDWIM_POS 3
#define IAXXX_SPI1_IMR_RXDWIM_SIZE 1
#define IAXXX_SPI1_IMR_RXDWIM_DECL 3

/*
 * Transmit FIFO Underflow Interrupt Mask
 * 1: TxFIFO Underflow Interrupt is not masked
 * 0: TxFIFO Underflow Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXUIM_MASK 0x00000010
#define IAXXX_SPI1_IMR_TXUIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXUIM_POS 4
#define IAXXX_SPI1_IMR_TXUIM_SIZE 1
#define IAXXX_SPI1_IMR_TXUIM_DECL 4

/*
 * Receive FIFO Underflow Interrupt Mask
 * 1: RxFIFO Underflow Interrupt is not masked
 * 0: RxFIFO Underflow Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXUIM_MASK 0x00000020
#define IAXXX_SPI1_IMR_RXUIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXUIM_POS 5
#define IAXXX_SPI1_IMR_RXUIM_SIZE 1
#define IAXXX_SPI1_IMR_RXUIM_DECL 5

/*
 * Transmit FIFO Overflow Interrupt Mask
 * 1: TxFIFO Overflow Interrupt is not masked
 * 0: TxFIFO Overflow Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXOIM_MASK 0x00000040
#define IAXXX_SPI1_IMR_TXOIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXOIM_POS 6
#define IAXXX_SPI1_IMR_TXOIM_SIZE 1
#define IAXXX_SPI1_IMR_TXOIM_DECL 6

/*
 * Receive FIFO Overflow Interrupt Mask
 * 1: RxFIFO Overflow Interrupt is not masked
 * 0: RxFIFO Overflow Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXOIM_MASK 0x00000080
#define IAXXX_SPI1_IMR_RXOIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXOIM_POS 7
#define IAXXX_SPI1_IMR_RXOIM_SIZE 1
#define IAXXX_SPI1_IMR_RXOIM_DECL 7

/*
 * Transmit FIFO Full Interrupt Mask
 * 1: TxFIFO Full Interrupt is not masked
 * 0: TxFIFO Full Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXFIM_MASK 0x00000100
#define IAXXX_SPI1_IMR_TXFIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXFIM_POS 8
#define IAXXX_SPI1_IMR_TXFIM_SIZE 1
#define IAXXX_SPI1_IMR_TXFIM_DECL 8

/*
 * Receive FIFO Full Interrupt Mask
 * 1: RxFIFO Full Interrupt is not masked
 * 0: RxFIFO Full Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXFIM_MASK 0x00000200
#define IAXXX_SPI1_IMR_RXFIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXFIM_POS 9
#define IAXXX_SPI1_IMR_RXFIM_SIZE 1
#define IAXXX_SPI1_IMR_RXFIM_DECL 9

/*
 * Transmit FIFO Empty Interrupt Mask
 * 1: TxFIFO Empty Interrupt is not masked
 * 0: TxFIFO Empty Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TXEIM_MASK 0x00000400
#define IAXXX_SPI1_IMR_TXEIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TXEIM_POS 10
#define IAXXX_SPI1_IMR_TXEIM_SIZE 1
#define IAXXX_SPI1_IMR_TXEIM_DECL 10

/*
 * Receive FIFO Empty Interrupt Mask
 * 1: RxFIFO Empty Interrupt is not masked
 * 0: RxFIFO Empty Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RXEIM_MASK 0x00000800
#define IAXXX_SPI1_IMR_RXEIM_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RXEIM_POS 11
#define IAXXX_SPI1_IMR_RXEIM_SIZE 1
#define IAXXX_SPI1_IMR_RXEIM_DECL 11

/*
 * Clock Sampling Error Interrupt Mask
 * 1: Clock Sampling Error Interrupt is not masked
 * 0: Clock Sampling Interrupt is masked
 */
#define IAXXX_SPI1_IMR_CLK_SAMP_ERR_MASK 0x00001000
#define IAXXX_SPI1_IMR_CLK_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_CLK_SAMP_ERR_POS 12
#define IAXXX_SPI1_IMR_CLK_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_IMR_CLK_SAMP_ERR_DECL 12

/*
 * Data Sampling Error Interrupt Mask
 * 1: Data Sampling Error Interrupt is not masked
 * 0: Data Sampling Error Interrupt is masked
 */
#define IAXXX_SPI1_IMR_DATA_SAMP_ERR_MASK 0x00002000
#define IAXXX_SPI1_IMR_DATA_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_DATA_SAMP_ERR_POS 13
#define IAXXX_SPI1_IMR_DATA_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_IMR_DATA_SAMP_ERR_DECL 13

/*
 * Chip Select Fall Interrupt Mask
 * 1: Chip Select Fall Interrupt is not masked
 * 0: Chip Select Fall Interrupt is masked
 */
#define IAXXX_SPI1_IMR_CS_FALL_MASK 0x00004000
#define IAXXX_SPI1_IMR_CS_FALL_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_CS_FALL_POS 14
#define IAXXX_SPI1_IMR_CS_FALL_SIZE 1
#define IAXXX_SPI1_IMR_CS_FALL_DECL 14

/*
 * Chip Select Rise Interrupt Mask
 * 1: Chip Select Rise Interrupt is not masked
 * 0: Chip Select Rise Interrupt is masked
 */
#define IAXXX_SPI1_IMR_CS_RISE_MASK 0x00008000
#define IAXXX_SPI1_IMR_CS_RISE_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_CS_RISE_POS 15
#define IAXXX_SPI1_IMR_CS_RISE_SIZE 1
#define IAXXX_SPI1_IMR_CS_RISE_DECL 15

/*
 * Transmit Error interrupt Mask
 * 1: Transmit Error Interrupt is not masked
 * 0: Transmit Error Interrupt is masked
 */
#define IAXXX_SPI1_IMR_TX_ERR_MASK 0x00010000
#define IAXXX_SPI1_IMR_TX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_TX_ERR_POS 16
#define IAXXX_SPI1_IMR_TX_ERR_SIZE 1
#define IAXXX_SPI1_IMR_TX_ERR_DECL 16

/*
 * Receive Error interrupt Mask
 * 1: Receive Error Interrupt is not masked
 * 0: Receive Error Interrupt is masked
 */
#define IAXXX_SPI1_IMR_RX_ERR_MASK 0x00020000
#define IAXXX_SPI1_IMR_RX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_IMR_RX_ERR_POS 17
#define IAXXX_SPI1_IMR_RX_ERR_SIZE 1
#define IAXXX_SPI1_IMR_RX_ERR_DECL 17

/*** SPI1_ISR (0x40061020) ***/
/*
 * SPI Interrupt Status. Each of the potential interrupt sources have a mask.
 * The mask is ANDed with corresponding RISR bit and the result is provided
 * as a read-only register - ISR. The interrupt generated by SPI is OR of all
 * the ISR bits. Note that ISR is a read-only register. Interrupts, except
 * threshold interrupts, can be cleared by write 1 to RISR register.
 */
#define IAXXX_SPI1_ISR_ADDR (0x40061020)
#define IAXXX_SPI1_ISR_MASK_VAL 0x0003ffff
#define IAXXX_SPI1_ISR_RMASK_VAL 0x0003ffff
#define IAXXX_SPI1_ISR_WMASK_VAL 0x00000000
#define IAXXX_SPI1_ISR_RESET_VAL 0x00000000

/*
 * Transmit FIFO Threshold Interrupt Status
 * (IMR:TXTHIM & RISR:TXTHIR)
 * 1: TxFIFO Threshold Interrupt is active
 * 0: TxFIFO Threshold Interrupt is not active
 * It is recommended that, when TxFIFO threshold interrupt is received, FW
 * checks that threshold interrupt is active in ISR.
 * Note that the interrupt is non-sticky. So the interrupt always reflects
 * current status of the interrupt
 */
#define IAXXX_SPI1_ISR_TXTHIS_MASK 0x00000001
#define IAXXX_SPI1_ISR_TXTHIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXTHIS_POS 0
#define IAXXX_SPI1_ISR_TXTHIS_SIZE 1
#define IAXXX_SPI1_ISR_TXTHIS_DECL 0

/*
 * Receive FIFO Threshold Interrupt Status
 * (IMR:RXTHIM & RISR:RXTHIR)
 * 1: RxFIFO Threshold Interrupt is active
 * 0: RxFIFO Threshold Interrupt is not active
 * It is recommended that, when RxFIFO threshold interrupt is received, FW
 * checks that threshold interrupt is active in ISR.
 * Note that the interrupt is non-sticky. So the interrupt always reflects
 * current status of the interrupt
 */
#define IAXXX_SPI1_ISR_RXTHIS_MASK 0x00000002
#define IAXXX_SPI1_ISR_RXTHIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXTHIS_POS 1
#define IAXXX_SPI1_ISR_RXTHIS_SIZE 1
#define IAXXX_SPI1_ISR_RXTHIS_DECL 1

/*
 * Transmit FIFO DMA Watermark Interrupt Status
 * (IMR:TXDWIM & RISR:TXDWIR)
 * 1: TxFIFO DMA Watermark Interrupt is active
 * 0: TxFIFO Watermak Interrupt is not active
 */
#define IAXXX_SPI1_ISR_TXDWIS_MASK 0x00000004
#define IAXXX_SPI1_ISR_TXDWIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXDWIS_POS 2
#define IAXXX_SPI1_ISR_TXDWIS_SIZE 1
#define IAXXX_SPI1_ISR_TXDWIS_DECL 2

/*
 * Receive FIFO DMA Watermark Interrupt Status
 * (IMR:RXDWIM & RISR:RXDWIR)
 * 1: RxFIFO DMA Watermark Interrupt is active
 * 0: RxFIFO Watermak Interrupt is not active
 */
#define IAXXX_SPI1_ISR_RXDWIS_MASK 0x00000008
#define IAXXX_SPI1_ISR_RXDWIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXDWIS_POS 3
#define IAXXX_SPI1_ISR_RXDWIS_SIZE 1
#define IAXXX_SPI1_ISR_RXDWIS_DECL 3

/*
 * Transmit FIFO Underflow Interrupt Status
 * (IMR:TXUIM & RISR:TXUIR)
 * 1: TxFIFO Underflow Interrupt is active
 * 0: TxFIFO Underflow Interrupt is not active
 */
#define IAXXX_SPI1_ISR_TXUIS_MASK 0x00000010
#define IAXXX_SPI1_ISR_TXUIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXUIS_POS 4
#define IAXXX_SPI1_ISR_TXUIS_SIZE 1
#define IAXXX_SPI1_ISR_TXUIS_DECL 4

/*
 * Receive FIFO Underflow Interrupt Status
 * (IMR:RXUIM & RISR:RXUIR)
 * 1: RxFIFO Underflow Interrupt is active
 * 0: RxFIFO Underflow Interrupt is not active
 */
#define IAXXX_SPI1_ISR_RXUIS_MASK 0x00000020
#define IAXXX_SPI1_ISR_RXUIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXUIS_POS 5
#define IAXXX_SPI1_ISR_RXUIS_SIZE 1
#define IAXXX_SPI1_ISR_RXUIS_DECL 5

/*
 * Transmit FIFO Overflow Interrupt Status
 * (IMR:TXOIM & RISR:TXOIR)
 * 1: TxFIFO Overflow Interrupt is active
 * 0: TxFIFO Overflow Interrupt is not active
 */
#define IAXXX_SPI1_ISR_TXOIS_MASK 0x00000040
#define IAXXX_SPI1_ISR_TXOIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXOIS_POS 6
#define IAXXX_SPI1_ISR_TXOIS_SIZE 1
#define IAXXX_SPI1_ISR_TXOIS_DECL 6

/*
 * Receive FIFO Overflow Interrupt Status
 * (IMR:RXOIM & RISR:RXOIR)
 * 1: RxFIFO Overflow Interrupt is active
 * 0: RxFIFO Overflow Interrupt is not active
 */
#define IAXXX_SPI1_ISR_RXOIS_MASK 0x00000080
#define IAXXX_SPI1_ISR_RXOIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXOIS_POS 7
#define IAXXX_SPI1_ISR_RXOIS_SIZE 1
#define IAXXX_SPI1_ISR_RXOIS_DECL 7

/*
 * Transmit FIFO Full Interrupt Status
 * (IMR:TXFIM & RISR:TXFIR)
 * 1: TxFIFO Full Interrupt is active
 * 0: TxFIFO Full Interrupt is not active
 */
#define IAXXX_SPI1_ISR_TXFIS_MASK 0x00000100
#define IAXXX_SPI1_ISR_TXFIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXFIS_POS 8
#define IAXXX_SPI1_ISR_TXFIS_SIZE 1
#define IAXXX_SPI1_ISR_TXFIS_DECL 8

/*
 * Receive FIFO Full Interrupt Status
 * (IMR:RXFIM & RISR:RXFIR)
 * 1: RxFIFO Full Interrupt is active
 * 0: RxFIFO Full Interrupt is not active
 */
#define IAXXX_SPI1_ISR_RXFIS_MASK 0x00000200
#define IAXXX_SPI1_ISR_RXFIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXFIS_POS 9
#define IAXXX_SPI1_ISR_RXFIS_SIZE 1
#define IAXXX_SPI1_ISR_RXFIS_DECL 9

/*
 * Transmit FIFO Empty Interrupt Status
 * (IMR:TXEIM & RISR:TXEIR)
 * 1: TxFIFO Empty Interrupt is active
 * 0: TxFIFO Empty Interrupt is not active
 */
#define IAXXX_SPI1_ISR_TXEIS_MASK 0x00000400
#define IAXXX_SPI1_ISR_TXEIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TXEIS_POS 10
#define IAXXX_SPI1_ISR_TXEIS_SIZE 1
#define IAXXX_SPI1_ISR_TXEIS_DECL 10

/*
 * Receive FIFO Empty Interrupt Status
 * (IMR:RXEIM & RISR:RXEIR)
 * 1: RxFIFO Empty Interrupt is active
 * 0: RxFIFO Empty Interrupt is not active
 */
#define IAXXX_SPI1_ISR_RXEIS_MASK 0x00000800
#define IAXXX_SPI1_ISR_RXEIS_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RXEIS_POS 11
#define IAXXX_SPI1_ISR_RXEIS_SIZE 1
#define IAXXX_SPI1_ISR_RXEIS_DECL 11

/*
 * Clock Sampling Error Interrupt Status
 * (IMR:CLK_SAMP_ERR & RISR:CLK_SAMP_ERR)
 * 1: Clock Sampling Error Interrupt is active
 * 0: Clock Sampling Interrupt is not active
 */
#define IAXXX_SPI1_ISR_CLK_SAMP_ERR_MASK 0x00001000
#define IAXXX_SPI1_ISR_CLK_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_CLK_SAMP_ERR_POS 12
#define IAXXX_SPI1_ISR_CLK_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_ISR_CLK_SAMP_ERR_DECL 12

/*
 * Data Sampling Error Interrupt Status
 * (IMR:DATA_SAMP_ERR & RISR:DATA_SAMP_ERR)
 * 1: Data Sampling Error Interrupt is active
 * 0: Data Sampling Error Interrupt is not active
 */
#define IAXXX_SPI1_ISR_DATA_SAMP_ERR_MASK 0x00002000
#define IAXXX_SPI1_ISR_DATA_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_DATA_SAMP_ERR_POS 13
#define IAXXX_SPI1_ISR_DATA_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_ISR_DATA_SAMP_ERR_DECL 13

/*
 * Chip Select Fall Interrupt Status
 * (IMR:CS_FALL & RISR:CS_FALL)
 * 1: Chip Select Fall Interrupt is active
 * 0: Chip Select Fall Interrupt is not active
 */
#define IAXXX_SPI1_ISR_CS_FALL_MASK 0x00004000
#define IAXXX_SPI1_ISR_CS_FALL_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_CS_FALL_POS 14
#define IAXXX_SPI1_ISR_CS_FALL_SIZE 1
#define IAXXX_SPI1_ISR_CS_FALL_DECL 14

/*
 * Chip Select Rise Interrupt Status
 * (IMR:CS_RISE & RISR:CS_RISE)
 * 1: Chip Select Rise Interrupt is active
 * 0: Chip Select Rise Interrupt is not active
 */
#define IAXXX_SPI1_ISR_CS_RISE_MASK 0x00008000
#define IAXXX_SPI1_ISR_CS_RISE_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_CS_RISE_POS 15
#define IAXXX_SPI1_ISR_CS_RISE_SIZE 1
#define IAXXX_SPI1_ISR_CS_RISE_DECL 15

/*
 * Transmit Error
 * 1: Number of bits transmitted is not equal to integer multiple of WLEN+1
 * 0: No transmit error
 */
#define IAXXX_SPI1_ISR_TX_ERR_MASK 0x00010000
#define IAXXX_SPI1_ISR_TX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_TX_ERR_POS 16
#define IAXXX_SPI1_ISR_TX_ERR_SIZE 1
#define IAXXX_SPI1_ISR_TX_ERR_DECL 16

/*
 * Receive Error
 * 1: Number of bits received is not equal to integer multiple of WLEN+1
 * 0: No receive error
 */
#define IAXXX_SPI1_ISR_RX_ERR_MASK 0x00020000
#define IAXXX_SPI1_ISR_RX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_ISR_RX_ERR_POS 17
#define IAXXX_SPI1_ISR_RX_ERR_SIZE 1
#define IAXXX_SPI1_ISR_RX_ERR_DECL 17

/*** SPI1_RISR (0x40061024) ***/
/*
 * SPI Interrupt sources. Each of the potential interrupt sources have a
 * mask. The mask is ANDed with corresponding RISR bit and the result is
 * provided as a read-only register - ISR. The interrupt generated by SPI is
 * OR of all the ISR bits. Note that all interrupts, except threshold
 * interrupts, can be cleared by write 1 to RISR register only.
 */
#define IAXXX_SPI1_RISR_ADDR (0x40061024)
#define IAXXX_SPI1_RISR_MASK_VAL 0x0003ffff
#define IAXXX_SPI1_RISR_RMASK_VAL 0x0003ffff
#define IAXXX_SPI1_RISR_WMASK_VAL 0x0003fffc
#define IAXXX_SPI1_RISR_RESET_VAL 0x00000000

/*
 * Transmit FIFO Threshold Raw Interrupt Status
 * 1: TxFIFO Threshold Interrupt is active
 * 0: TxFIFO Threshold Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXTHIR_MASK 0x00000001
#define IAXXX_SPI1_RISR_TXTHIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXTHIR_POS 0
#define IAXXX_SPI1_RISR_TXTHIR_SIZE 1
#define IAXXX_SPI1_RISR_TXTHIR_DECL 0

/*
 * Receive FIFO Threshold Raw Interrupt Status
 * 1: RxFIFO Threshold Interrupt is active
 * 0: RxFIFO Threshold Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXTHIR_MASK 0x00000002
#define IAXXX_SPI1_RISR_RXTHIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXTHIR_POS 1
#define IAXXX_SPI1_RISR_RXTHIR_SIZE 1
#define IAXXX_SPI1_RISR_RXTHIR_DECL 1

/*
 * Transmit FIFO DMA Watermark Raw Interrupt Status
 * 1: TxFIFO DMA Watermark Interrupt is active
 * 0: TxFIFO Watermak Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXDWIR_MASK 0x00000004
#define IAXXX_SPI1_RISR_TXDWIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXDWIR_POS 2
#define IAXXX_SPI1_RISR_TXDWIR_SIZE 1
#define IAXXX_SPI1_RISR_TXDWIR_DECL 2

/*
 * Receive FIFO DMA Watermark Raw Interrupt Status
 * 1: RxFIFO DMA Watermark Interrupt is active
 * 0: RxFIFO Watermak Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXDWIR_MASK 0x00000008
#define IAXXX_SPI1_RISR_RXDWIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXDWIR_POS 3
#define IAXXX_SPI1_RISR_RXDWIR_SIZE 1
#define IAXXX_SPI1_RISR_RXDWIR_DECL 3

/*
 * Transmit FIFO Underflow Raw Interrupt Status
 * 1: TxFIFO Underflow Interrupt is active
 * 0: TxFIFO Underflow Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXUIR_MASK 0x00000010
#define IAXXX_SPI1_RISR_TXUIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXUIR_POS 4
#define IAXXX_SPI1_RISR_TXUIR_SIZE 1
#define IAXXX_SPI1_RISR_TXUIR_DECL 4

/*
 * Receive FIFO Underflow Raw Interrupt Status
 * 1: RxFIFO Underflow Interrupt is active
 * 0: RxFIFO Underflow Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXUIR_MASK 0x00000020
#define IAXXX_SPI1_RISR_RXUIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXUIR_POS 5
#define IAXXX_SPI1_RISR_RXUIR_SIZE 1
#define IAXXX_SPI1_RISR_RXUIR_DECL 5

/*
 * Transmit FIFO Overflow Raw Interrupt Status
 * 1: TxFIFO Overflow Interrupt is active
 * 0: TxFIFO Overflow Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXOIR_MASK 0x00000040
#define IAXXX_SPI1_RISR_TXOIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXOIR_POS 6
#define IAXXX_SPI1_RISR_TXOIR_SIZE 1
#define IAXXX_SPI1_RISR_TXOIR_DECL 6

/*
 * Receive FIFO Overflow Raw Interrupt Status
 * 1: RxFIFO Overflow Interrupt is active
 * 0: RxFIFO Overflow Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXOIR_MASK 0x00000080
#define IAXXX_SPI1_RISR_RXOIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXOIR_POS 7
#define IAXXX_SPI1_RISR_RXOIR_SIZE 1
#define IAXXX_SPI1_RISR_RXOIR_DECL 7

/*
 * Transmit FIFO Full Raw Interrupt Status
 * 1: TxFIFO Full Interrupt is active
 * 0: TxFIFO Full Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXFIR_MASK 0x00000100
#define IAXXX_SPI1_RISR_TXFIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXFIR_POS 8
#define IAXXX_SPI1_RISR_TXFIR_SIZE 1
#define IAXXX_SPI1_RISR_TXFIR_DECL 8

/*
 * Receive FIFO Full Raw Interrupt Status
 * 1: RxFIFO Full Interrupt is active
 * 0: RxFIFO Full Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXFIR_MASK 0x00000200
#define IAXXX_SPI1_RISR_RXFIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXFIR_POS 9
#define IAXXX_SPI1_RISR_RXFIR_SIZE 1
#define IAXXX_SPI1_RISR_RXFIR_DECL 9

/*
 * Transmit FIFO Empty Raw Interrupt Status
 * 1: TxFIFO Empty Interrupt is active
 * 0: TxFIFO Empty Interrupt is not active
 */
#define IAXXX_SPI1_RISR_TXEIR_MASK 0x00000400
#define IAXXX_SPI1_RISR_TXEIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TXEIR_POS 10
#define IAXXX_SPI1_RISR_TXEIR_SIZE 1
#define IAXXX_SPI1_RISR_TXEIR_DECL 10

/*
 * Receive FIFO Empty Raw Interrupt Status
 * 1: RxFIFO Empty Interrupt is active
 * 0: RxFIFO Empty Interrupt is not active
 */
#define IAXXX_SPI1_RISR_RXEIR_MASK 0x00000800
#define IAXXX_SPI1_RISR_RXEIR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RXEIR_POS 11
#define IAXXX_SPI1_RISR_RXEIR_SIZE 1
#define IAXXX_SPI1_RISR_RXEIR_DECL 11

/*
 * Clock Sampling Error Raw Interrupt Status
 * 1: Clock Sampling Error Interrupt is active
 * 0: Clock Sampling Interrupt is not active
 */
#define IAXXX_SPI1_RISR_CLK_SAMP_ERR_MASK 0x00001000
#define IAXXX_SPI1_RISR_CLK_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_CLK_SAMP_ERR_POS 12
#define IAXXX_SPI1_RISR_CLK_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_RISR_CLK_SAMP_ERR_DECL 12

/*
 * Data Sampling Error Raw Interrupt Status
 * 1: Data Sampling Error Interrupt is active
 * 0: Data Sampling Error Interrupt is not active
 */
#define IAXXX_SPI1_RISR_DATA_SAMP_ERR_MASK 0x00002000
#define IAXXX_SPI1_RISR_DATA_SAMP_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_DATA_SAMP_ERR_POS 13
#define IAXXX_SPI1_RISR_DATA_SAMP_ERR_SIZE 1
#define IAXXX_SPI1_RISR_DATA_SAMP_ERR_DECL 13

/*
 * Chip Select Fall Raw Interrupt Status
 * 1: Chip Select Fall Interrupt is active
 * 0: Chip Select Fall Interrupt is not active
 */
#define IAXXX_SPI1_RISR_CS_FALL_MASK 0x00004000
#define IAXXX_SPI1_RISR_CS_FALL_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_CS_FALL_POS 14
#define IAXXX_SPI1_RISR_CS_FALL_SIZE 1
#define IAXXX_SPI1_RISR_CS_FALL_DECL 14

/*
 * Chip Select Rise Raw Interrupt Status
 * 1: Chip Select Rise Interrupt is active
 * 0: Chip Select Rise Interrupt is not active
 */
#define IAXXX_SPI1_RISR_CS_RISE_MASK 0x00008000
#define IAXXX_SPI1_RISR_CS_RISE_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_CS_RISE_POS 15
#define IAXXX_SPI1_RISR_CS_RISE_SIZE 1
#define IAXXX_SPI1_RISR_CS_RISE_DECL 15

/*
 * Transmit Error
 * 1: Number of bits transmitted is not equal to integer multiple of WLEN+1
 * 0: No transmit error
 */
#define IAXXX_SPI1_RISR_TX_ERR_MASK 0x00010000
#define IAXXX_SPI1_RISR_TX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_TX_ERR_POS 16
#define IAXXX_SPI1_RISR_TX_ERR_SIZE 1
#define IAXXX_SPI1_RISR_TX_ERR_DECL 16

/*
 * Receive Error
 * 1: Number of bits received is not equal to integer multiple of WLEN+1
 * 0: No receive error
 */
#define IAXXX_SPI1_RISR_RX_ERR_MASK 0x00020000
#define IAXXX_SPI1_RISR_RX_ERR_RESET_VAL 0x0
#define IAXXX_SPI1_RISR_RX_ERR_POS 17
#define IAXXX_SPI1_RISR_RX_ERR_SIZE 1
#define IAXXX_SPI1_RISR_RX_ERR_DECL 17

/*** SPI1_SPI_ID (0x40061028) ***/
/*
 * Identification Register.
 */
#define IAXXX_SPI1_SPI_ID_ADDR (0x40061028)
#define IAXXX_SPI1_SPI_ID_MASK_VAL 0xffffffff
#define IAXXX_SPI1_SPI_ID_RMASK_VAL 0xffffffff
#define IAXXX_SPI1_SPI_ID_WMASK_VAL 0xffffffff
#define IAXXX_SPI1_SPI_ID_RESET_VAL 0x00000000

/*
 * Identification Code.
 */
#define IAXXX_SPI1_SPI_ID_VERSION_ID_MASK 0xffffffff
#define IAXXX_SPI1_SPI_ID_VERSION_ID_RESET_VAL 0x0
#define IAXXX_SPI1_SPI_ID_VERSION_ID_POS 0
#define IAXXX_SPI1_SPI_ID_VERSION_ID_SIZE 32
#define IAXXX_SPI1_SPI_ID_VERSION_ID_DECL (31:0)

/*** SPI1_DR (0x4006102c) ***/
/*
 * Data Register. Writes to TxFIFO. Reads from RxFIFO.
 */
#define IAXXX_SPI1_DR_ADDR (0x4006102c)
#define IAXXX_SPI1_DR_MASK_VAL 0xffffffff
#define IAXXX_SPI1_DR_RMASK_VAL 0xffffffff
#define IAXXX_SPI1_DR_WMASK_VAL 0xffffffff
#define IAXXX_SPI1_DR_RESET_VAL 0x00000000

/*
 * Data Register.
 * Write to this Register will result in data push into TxFIFO
 * Read from this register will result in data pop from RxFIFO
 */
#define IAXXX_SPI1_DR_DR_MASK 0xffffffff
#define IAXXX_SPI1_DR_DR_RESET_VAL 0x0
#define IAXXX_SPI1_DR_DR_POS 0
#define IAXXX_SPI1_DR_DR_SIZE 32
#define IAXXX_SPI1_DR_DR_DECL (31:0)

/*** SPI1_SAMP_CFG (0x40061030) ***/
/*
 * Timing characterstics of SPI interface signals may differ based on system
 * characteristics. Also, SPI Interface Ports are completely asynchronous to
 * SPI sample clock. Therefore, all input signals (RxD, CLK and CS) are
 * synchronized into sample clock domain before they are used. At rates
 * comparable to SPI sample clock, synchronized events will be at least 2
 * sample cycle delayed form the actual event on the interface. These
 * characteristics need to be compensated for by SPI to have a robust
 * communication system. SAMP_CFG configuration register defines how to
 * compensate for these timing characteristics. Both launch and capture
 * characteristics can be compensated for using this register. In Master
 * mode, this register also defines the interface clock frequency that has to
 * be generated by SPI. Apart from these features, SAMP_CFG register also
 * determines the window lengths to find errors in sample data and clock. In
 * Master mode, this register also defines the timing parameters that may be
 * needed for different SPI components. Programming these parameters as per
 * the requirements of the slave would be required depending on the target
 * bit rate.
 */
#define IAXXX_SPI1_SAMP_CFG_ADDR (0x40061030)
#define IAXXX_SPI1_SAMP_CFG_MASK_VAL 0x007fffff
#define IAXXX_SPI1_SAMP_CFG_RMASK_VAL 0x007fffff
#define IAXXX_SPI1_SAMP_CFG_WMASK_VAL 0x007fffff
#define IAXXX_SPI1_SAMP_CFG_RESET_VAL 0x00460010

/*
 * Data Capture Offset
 * Defines the offset of the actual capture point from the observed capture
 * edge
 * To compensate for any delay characteristics seen at system level, an
 * offset can be provided
 * The programmed offset will shift the data capture point
 * The programmed value should take into account that there will be 2 cycle
 * delay introduced by HW for synchronization of clock and/or data.
 * Therefore, if the intended shift from the actual edge on the interface is
 * 6 SPI Sample clock cycles, for instance, the programmed value should be 4
 * Note that capture offset is an unsigned integer
 */
#define IAXXX_SPI1_SAMP_CFG_DATA_CAPT_OFFST_MASK 0x0000000f
#define IAXXX_SPI1_SAMP_CFG_DATA_CAPT_OFFST_RESET_VAL 0x0
#define IAXXX_SPI1_SAMP_CFG_DATA_CAPT_OFFST_POS 0
#define IAXXX_SPI1_SAMP_CFG_DATA_CAPT_OFFST_SIZE 4
#define IAXXX_SPI1_SAMP_CFG_DATA_CAPT_OFFST_DECL (3:0)

/*
 * Clock Window Length
 * Defines the length of the window where 0 to 1 trasition is expected on
 * Clock
 * The window is chosen around the capture point selected by
 * SPIx_SAMP_CFG:DATA_CAPT_OFFST
 * Note that configured number of samples will be taken both left and right
 * of the selected capture point
 * Window is chosen symmetrically around the capture point
 * Note that clock window length is an unsigned integer
 */
#define IAXXX_SPI1_SAMP_CFG_CLK_WIN_LEN_MASK 0x000000f0
#define IAXXX_SPI1_SAMP_CFG_CLK_WIN_LEN_RESET_VAL 0x1
#define IAXXX_SPI1_SAMP_CFG_CLK_WIN_LEN_POS 4
#define IAXXX_SPI1_SAMP_CFG_CLK_WIN_LEN_SIZE 4
#define IAXXX_SPI1_SAMP_CFG_CLK_WIN_LEN_DECL (7:4)

/*
 * Data Window Length
 * Defines the length of the window where consecutive 1s/0s are expected to
 * be observed
 * The window is chosen around the capture point selected by
 * SPIx_SAMP_CFG:DATA_CAPT_OFFST
 * Note that configured number of samples will be taken on both left and
 * right of the selected capture point
 * Window is chosen symmetrically around the capture point
 * Note that data window length is an unsigned integer
 */
#define IAXXX_SPI1_SAMP_CFG_DATA_WIN_LEN_MASK 0x00000f00
#define IAXXX_SPI1_SAMP_CFG_DATA_WIN_LEN_RESET_VAL 0x0
#define IAXXX_SPI1_SAMP_CFG_DATA_WIN_LEN_POS 8
#define IAXXX_SPI1_SAMP_CFG_DATA_WIN_LEN_SIZE 4
#define IAXXX_SPI1_SAMP_CFG_DATA_WIN_LEN_DECL (11:8)

/*
 * Data Launch Offset
 * Defines the offset of the actual launch point right of the observed
 * launch/capture edge
 * To compensate for any delays characteristics seen at system level, an
 * offset can be provided
 * This offset changes the launch point on Tx Path
 * If SAMP_CFG:LAUNCH_ON_CAPT_EDGE is 0, offset is to be considered from the
 * observed launch edge
 * If SAMP_CFG:LAUNCH_ON_CAPT_EDGE is 1, offset is to be considered from the
 * observed capture edge
 * Bits[(3:0)] is the actual position of data launch
 * Samples are always taken right of the observed launch/capture edge
 * When Bits[(3:0)] is 0, data is launched on the observed launch or capture
 * edge
 * The programmed value should take into account that there will be 2 cycle
 * delay introduced by HW to for synchronization of clock and/or data.
 * Therefore, if the intended shift from the actual edge on the interface is
 * 6 SPI Sample clock cycles, for instance, the programmed value should be 4
 * Note that launch offset is an unsigned integer
 */
#define IAXXX_SPI1_SAMP_CFG_DATA_LAUNCH_OFFST_MASK 0x0000f000
#define IAXXX_SPI1_SAMP_CFG_DATA_LAUNCH_OFFST_RESET_VAL 0x0
#define IAXXX_SPI1_SAMP_CFG_DATA_LAUNCH_OFFST_POS 12
#define IAXXX_SPI1_SAMP_CFG_DATA_LAUNCH_OFFST_SIZE 4
#define IAXXX_SPI1_SAMP_CFG_DATA_LAUNCH_OFFST_DECL (15:12)

/*
 * Launch On Capture Edge
 * It may be required for high bit rate scenarios to launch data on observed
 * capture edge instead of launching data on observed launch edge
 * This bit configures HW to launch data on observed capture edge
 * 1: Launch data on observed capture edge
 * 0: Launch data on observed launch edge
 * Note that this configuration is indepedent of what is programmed in
 * SAMP_CFG:DATA_LAUNCH_OFFST
 */
#define IAXXX_SPI1_SAMP_CFG_LAUNCH_ON_CAPT_EDGE_MASK 0x00010000
#define IAXXX_SPI1_SAMP_CFG_LAUNCH_ON_CAPT_EDGE_RESET_VAL 0x0
#define IAXXX_SPI1_SAMP_CFG_LAUNCH_ON_CAPT_EDGE_POS 16
#define IAXXX_SPI1_SAMP_CFG_LAUNCH_ON_CAPT_EDGE_SIZE 1
#define IAXXX_SPI1_SAMP_CFG_LAUNCH_ON_CAPT_EDGE_DECL 16

/*
 * Master Mode Clock Rate Configuration
 * Used only in master mode to define IAXXX_the frequency of SPI clock that has to
 * be generated by SPI.
 * SPI interface clock frequency = SPI sample clock frequency divided by
 * 2*(MSTR_CLK_DIV+1)
 */
#define IAXXX_SPI1_SAMP_CFG_MSTR_CLK_DIV_MASK 0x003e0000
#define IAXXX_SPI1_SAMP_CFG_MSTR_CLK_DIV_RESET_VAL 0x3
#define IAXXX_SPI1_SAMP_CFG_MSTR_CLK_DIV_POS 17
#define IAXXX_SPI1_SAMP_CFG_MSTR_CLK_DIV_SIZE 5
#define IAXXX_SPI1_SAMP_CFG_MSTR_CLK_DIV_DECL (21:17)

/*
 * Drive Edge Detect Enable
 * For high bit rate scenarios, when minimum timing parameter requirements
 * are adhered to on SPI interface, SPI can determine if data has to be
 * driven on observed capture edge instead of observed launch edge to
 * compensate for the synchronization delays. This configuration can disable
 * HW from making this decision.
 * 0: Disable detection of drive edge
 * 1: Enable detection of drive edge
 * Note that this configuration is independent on SAMP_CFG:DATA_LAUNCH_OFFST
 * configuration
 * Therefore, even if this bit is enabled, data driven will be offset from
 * the observed edge as per SAMP_DATA_LAUNCH_OFFST
 */
#define IAXXX_SPI1_SAMP_CFG_DRIVE_EDGE_DET_EN_MASK 0x00400000
#define IAXXX_SPI1_SAMP_CFG_DRIVE_EDGE_DET_EN_RESET_VAL 0x1
#define IAXXX_SPI1_SAMP_CFG_DRIVE_EDGE_DET_EN_POS 22
#define IAXXX_SPI1_SAMP_CFG_DRIVE_EDGE_DET_EN_SIZE 1
#define IAXXX_SPI1_SAMP_CFG_DRIVE_EDGE_DET_EN_DECL 22

/*** SPI1_DMA_USAGE (0x40061034) ***/
/*
 * SPI DMA Usage Control. Enable DMA, Trigger DMA access. Functionality of
 * DMA trigger may vary in timing in master and slave modes
 */
#define IAXXX_SPI1_DMA_USAGE_ADDR (0x40061034)
#define IAXXX_SPI1_DMA_USAGE_MASK_VAL 0x00000003
#define IAXXX_SPI1_DMA_USAGE_RMASK_VAL 0x00000001
#define IAXXX_SPI1_DMA_USAGE_WMASK_VAL 0x00000003
#define IAXXX_SPI1_DMA_USAGE_RESET_VAL 0x00000000

/*
 * Use DMA Configuration.
 * 1: DMA handshake will be done for data transfer.
 * 0: DMA is not used for data transfer i.e., Control processor handles data
 * push/pop to/from SPI.
 */
#define IAXXX_SPI1_DMA_USAGE_USE_DMA_MASK 0x00000001
#define IAXXX_SPI1_DMA_USAGE_USE_DMA_RESET_VAL 0x0
#define IAXXX_SPI1_DMA_USAGE_USE_DMA_POS 0
#define IAXXX_SPI1_DMA_USAGE_USE_DMA_SIZE 1
#define IAXXX_SPI1_DMA_USAGE_USE_DMA_DECL 0

/*
 * DMA Access Trigger
 * Self Clear register. Always returns '0'.
 * When written with 1, DMA access will be armed.
 * DMA access trigger effects TxFIFO alone. RxFIFO is unaffected by this
 * trigger.
 * Therefore, trigger will have impact only if TXMOD is 1.
 * When in slave mode, for SPI Tx, DMA handshake will take place whenever
 * threshold level is reached.
 * When in master mode, for SPI Tx, DMA handshake will happen immediately
 * when DMA access is armed and will take place again when threshold level is
 * reached.
 */
#define IAXXX_SPI1_DMA_USAGE_DMA_ACCESS_TRIG_MASK 0x00000002
#define IAXXX_SPI1_DMA_USAGE_DMA_ACCESS_TRIG_RESET_VAL 0x0
#define IAXXX_SPI1_DMA_USAGE_DMA_ACCESS_TRIG_POS 1
#define IAXXX_SPI1_DMA_USAGE_DMA_ACCESS_TRIG_SIZE 1
#define IAXXX_SPI1_DMA_USAGE_DMA_ACCESS_TRIG_DECL 1

/*** SPI1_RX_WORD_CNT (0x40061038) ***/
/*
 * Rx Word Count. Used in Rx only cases. Indicates how many words are to be
 * received on Rx path. Provides an indiciation when the desired number of
 * words have been received. 1 word = (CTRL:WLEN+1) number of bits.
 */
#define IAXXX_SPI1_RX_WORD_CNT_ADDR (0x40061038)
#define IAXXX_SPI1_RX_WORD_CNT_MASK_VAL 0x0001ffff
#define IAXXX_SPI1_RX_WORD_CNT_RMASK_VAL 0x0001ffff
#define IAXXX_SPI1_RX_WORD_CNT_WMASK_VAL 0x0001ffff
#define IAXXX_SPI1_RX_WORD_CNT_RESET_VAL 0x00000000

/*
 * Number of words to expect from master/slave
 * When the set number of bits is received from master/slave, it indicates
 * that intended number of words have been received
 * The register RX_DONE goes to '1' when the configured number of bits is
 * received
 * Note that number of bits received will be equal to (NUM_OF_WORDS *
 * (WLEN+1)).
 */
#define IAXXX_SPI1_RX_WORD_CNT_NUM_OF_WORDS_MASK 0x0000ffff
#define IAXXX_SPI1_RX_WORD_CNT_NUM_OF_WORDS_RESET_VAL 0x0
#define IAXXX_SPI1_RX_WORD_CNT_NUM_OF_WORDS_POS 0
#define IAXXX_SPI1_RX_WORD_CNT_NUM_OF_WORDS_SIZE 16
#define IAXXX_SPI1_RX_WORD_CNT_NUM_OF_WORDS_DECL (15:0)

/*
 * Use when TxMOD is set to '0' and RxMOD is set to '1'
 * When '1', it indicates that programmed number of Rx words have been
 * received
 * Cleared either by write '1' by SW or when SPI_EN is set to 0
 */
#define IAXXX_SPI1_RX_WORD_CNT_RX_DONE_MASK 0x00010000
#define IAXXX_SPI1_RX_WORD_CNT_RX_DONE_RESET_VAL 0x0
#define IAXXX_SPI1_RX_WORD_CNT_RX_DONE_POS 16
#define IAXXX_SPI1_RX_WORD_CNT_RX_DONE_SIZE 1
#define IAXXX_SPI1_RX_WORD_CNT_RX_DONE_DECL 16

/*** SPI1_MST_TIMING_PARAMS (0x4006103c) ***/
/*
 * Timing Parameters for Master Mode. In master mode, different slaves may
 * require adherence to different timing constrains. Note that values less
 * than default values are illegal since minimum requirement on most SPIs is
 * at least 0.5 SPI Interface Clocks for each parameter. T_CSL_CLK controls
 * the desired delay from chip select assertion to first clock. T_CLK_CSH
 * controls the desired delay from last clock to chip select deassertion.
 * T_CSH_CSL controls desired delay from chip select deassertion to chip
 * select assertion. T_DLY_BYTE controls the desired delay in between
 * consecutive bytes in a frame. All these configuration fields are unsigned
 * integers.
 */
#define IAXXX_SPI1_MST_TIMING_PARAMS_ADDR (0x4006103c)
#define IAXXX_SPI1_MST_TIMING_PARAMS_MASK_VAL 0xffffffff
#define IAXXX_SPI1_MST_TIMING_PARAMS_RMASK_VAL 0xffffffff
#define IAXXX_SPI1_MST_TIMING_PARAMS_WMASK_VAL 0xffffffff
#define IAXXX_SPI1_MST_TIMING_PARAMS_RESET_VAL 0x00010101

/*
 * Timing parameter in master mode for chip-select low to first clock event
 * Specify number of SPI Interface Clocks to wait before starting clock after
 * asserting slave chip-select
 * Default value is 1, which means after chip-select is asserted, master will
 * wait for 1 SPI Interface Clock before starting clock
 */
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSL_CLK_MASK 0x000000ff
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSL_CLK_RESET_VAL 0x1
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSL_CLK_POS 0
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSL_CLK_SIZE 8
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSL_CLK_DECL (7:0)

/*
 * Timing parameter in master mode for last clock to chip-select high event
 * Specify number of SPI Interface Clocks to wait after last clock before
 * de-asserting slave chip-select
 * Default value is 1, which means after last clock, master will wait for 1
 * SPI Interface Clock before de-asserting chip-select
 */
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CLK_CSH_MASK 0x0000ff00
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CLK_CSH_RESET_VAL 0x1
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CLK_CSH_POS 8
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CLK_CSH_SIZE 8
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CLK_CSH_DECL (15:8)

/*
 * Timing parameter in master mode for chip-select high to chip-select low
 * event
 * Specify number of SPI Interface Clocks to wait before starting a new
 * transaction after current transaction ends
 * Default value is 1, which means after chip-select is de-asserted, master
 * will wait for 1 SPI Interface Clock before asserting chip-select again (if
 * there is a new transaction request)
 */
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSH_CSL_MASK 0x00ff0000
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSH_CSL_RESET_VAL 0x1
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSH_CSL_POS 16
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSH_CSL_SIZE 8
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_CSH_CSL_DECL (23:16)

/*
 * Timing parameter in master mode to insert delay between bytes
 * After every 8 SPI clock cycles, clock is set to initial state and a wait
 * period of configured SPI cycles is inserted
 * Default value is 0. Delay = Configured value * SPI Interface Clocks.
 * NOTE: The value of this timing parameter should adhere to the following
 * condition - T_DLY_BYTE <= T_CSL_CLK
 */
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_DLY_BYTE_MASK 0xff000000
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_DLY_BYTE_RESET_VAL 0x0
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_DLY_BYTE_POS 24
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_DLY_BYTE_SIZE 8
#define IAXXX_SPI1_MST_TIMING_PARAMS_T_DLY_BYTE_DECL (31:24)

/* Number of registers in the module */
#define IAXXX_SPI1_REG_NUM 16

#endif /* __IAXXX_REGISTER_DEFS_SPI1_H__*/
