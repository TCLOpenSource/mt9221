/*
 * iaxxx-register-defs-hdmac.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_HDMAC_H__
#define __IAXXX_REGISTER_DEFS_HDMAC_H__

/*** The base address for this set of registers ***/
#define IAXXX_HDMAC_REGS_ADDR (0x40080000)

/*** HDMAC_CH0_SAR (0x40080000) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH0_SAR_ADDR (0x40080000)
#define IAXXX_HDMAC_CH0_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH0_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH0_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH0_SAR_SAR_DECL (31:0)

/*** HDMAC_CH0_DAR (0x40080008) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH0_DAR_ADDR (0x40080008)
#define IAXXX_HDMAC_CH0_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH0_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH0_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH0_DAR_DAR_DECL (31:0)

/*** HDMAC_CH0_LLP (0x40080010) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH0_LLP_ADDR (0x40080010)
#define IAXXX_HDMAC_CH0_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH0_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH0_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH0_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH0_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH0_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH0_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH0_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH0_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH0_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH0_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH0_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH0_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH0_LLP_LOC_DECL (31:2)

/*** HDMAC_CH0_CTL (0x40080018) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH0_CTL_ADDR (0x40080018)
#define IAXXX_HDMAC_CH0_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH0_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH0_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH0_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH0_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH0_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH0_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH0_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH0_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH0_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH0_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH0_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH0_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH0_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH0_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH0_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH0_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH0_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH0_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH0_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH0_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH0_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH0_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH0_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH0_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH0_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH0_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH0_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH0_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH0_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH0_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH0_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH0_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH0_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH0_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH0_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH0_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH0_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH0_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH0_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH0_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH0_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH0_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH0_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH0_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH0_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH0_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH0_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH0_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH0_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH0_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH0_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH0_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH0_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH0_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH0_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH0_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH0_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH0_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH0_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH0_CTL_H (0x4008001c) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH0_CTL_H_ADDR (0x4008001c)
#define IAXXX_HDMAC_CH0_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH0_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH0_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH0_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH0_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH0_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH0_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH0_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH0_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH0_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH0_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH0_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH0_CTL_H_DONE_DECL 12

/*** HDMAC_CH0_SSTAT (0x40080020) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH0_SSTAT_ADDR (0x40080020)
#define IAXXX_HDMAC_CH0_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH0_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH0_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH0_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH0_DSTAT (0x40080028) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH0_DSTAT_ADDR (0x40080028)
#define IAXXX_HDMAC_CH0_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH0_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH0_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH0_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH0_SSTATAR (0x40080030) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH0_SSTATAR_ADDR (0x40080030)
#define IAXXX_HDMAC_CH0_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH0_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH0_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH0_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH0_DSTATAR (0x40080038) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH0_DSTATAR_ADDR (0x40080038)
#define IAXXX_HDMAC_CH0_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH0_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH0_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH0_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH0_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH0_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH0_CFG (0x40080040) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH0_CFG_ADDR (0x40080040)
#define IAXXX_HDMAC_CH0_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH0_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH0_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH0_CFG_RESET_VAL 0x00000e00

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH0_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH0_CFG_CH_PRIOR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH0_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH0_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH0_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH0_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH0_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH0_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH0_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH0_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH0_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH0_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH0_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH0_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH0_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH0_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH0_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH0_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH0_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH0_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH0_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH0_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH0_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH0_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH0_CFG_H (0x40080044) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH0_CFG_H_ADDR (0x40080044)
#define IAXXX_HDMAC_CH0_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH0_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH0_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH0_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH0_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH0_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH0_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH0_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH0_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH0_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH0_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH0_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH0_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH0_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH0_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH0_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH0_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH0_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH0_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH0_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH0_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH0_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH0_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH0_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH0_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH0_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH0_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH0_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH0_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH0_SGR (0x40080048) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH0_SGR_ADDR (0x40080048)
#define IAXXX_HDMAC_CH0_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH0_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH0_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH0_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH0_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH0_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH0_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH0_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH0_SGR_SGC_DECL (30:20)

/*** HDMAC_CH0_DSR (0x40080050) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH0_DSR_ADDR (0x40080050)
#define IAXXX_HDMAC_CH0_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH0_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH0_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH0_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH0_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH0_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH0_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH0_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH0_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH0_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH0_DSR_DSC_DECL (30:20)

/*** HDMAC_CH1_SAR (0x40080058) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH1_SAR_ADDR (0x40080058)
#define IAXXX_HDMAC_CH1_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH1_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH1_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH1_SAR_SAR_DECL (31:0)

/*** HDMAC_CH1_DAR (0x40080060) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH1_DAR_ADDR (0x40080060)
#define IAXXX_HDMAC_CH1_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH1_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH1_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH1_DAR_DAR_DECL (31:0)

/*** HDMAC_CH1_LLP (0x40080068) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH1_LLP_ADDR (0x40080068)
#define IAXXX_HDMAC_CH1_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH1_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH1_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH1_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH1_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH1_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH1_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH1_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH1_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH1_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH1_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH1_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH1_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH1_LLP_LOC_DECL (31:2)

/*** HDMAC_CH1_CTL (0x40080070) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH1_CTL_ADDR (0x40080070)
#define IAXXX_HDMAC_CH1_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH1_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH1_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH1_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH1_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH1_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH1_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH1_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH1_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH1_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH1_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH1_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH1_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH1_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH1_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH1_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH1_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH1_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH1_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH1_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH1_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH1_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH1_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH1_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH1_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH1_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH1_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH1_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH1_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH1_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH1_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH1_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH1_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH1_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH1_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH1_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH1_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH1_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH1_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH1_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH1_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH1_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH1_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH1_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH1_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH1_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH1_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH1_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH1_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH1_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH1_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH1_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH1_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH1_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH1_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH1_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH1_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH1_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH1_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH1_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH1_CTL_H (0x40080074) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH1_CTL_H_ADDR (0x40080074)
#define IAXXX_HDMAC_CH1_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH1_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH1_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH1_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH1_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH1_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH1_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH1_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH1_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH1_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH1_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH1_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH1_CTL_H_DONE_DECL 12

/*** HDMAC_CH1_SSTAT (0x40080078) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH1_SSTAT_ADDR (0x40080078)
#define IAXXX_HDMAC_CH1_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH1_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH1_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH1_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH1_DSTAT (0x40080080) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH1_DSTAT_ADDR (0x40080080)
#define IAXXX_HDMAC_CH1_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH1_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH1_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH1_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH1_SSTATAR (0x40080088) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH1_SSTATAR_ADDR (0x40080088)
#define IAXXX_HDMAC_CH1_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH1_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH1_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH1_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH1_DSTATAR (0x40080090) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH1_DSTATAR_ADDR (0x40080090)
#define IAXXX_HDMAC_CH1_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH1_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH1_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH1_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH1_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH1_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH1_CFG (0x40080098) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH1_CFG_ADDR (0x40080098)
#define IAXXX_HDMAC_CH1_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH1_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH1_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH1_CFG_RESET_VAL 0x00000e20

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH1_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH1_CFG_CH_PRIOR_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH1_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH1_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH1_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH1_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH1_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH1_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH1_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH1_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH1_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH1_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH1_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH1_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH1_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH1_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH1_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH1_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH1_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH1_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH1_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH1_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH1_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH1_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH1_CFG_H (0x4008009c) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH1_CFG_H_ADDR (0x4008009c)
#define IAXXX_HDMAC_CH1_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH1_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH1_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH1_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH1_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH1_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH1_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH1_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH1_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH1_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH1_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH1_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH1_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH1_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH1_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH1_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH1_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH1_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH1_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH1_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH1_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH1_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH1_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH1_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH1_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH1_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH1_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH1_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH1_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH1_SGR (0x400800a0) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH1_SGR_ADDR (0x400800a0)
#define IAXXX_HDMAC_CH1_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH1_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH1_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH1_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH1_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH1_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH1_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH1_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH1_SGR_SGC_DECL (30:20)

/*** HDMAC_CH1_DSR (0x400800a8) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH1_DSR_ADDR (0x400800a8)
#define IAXXX_HDMAC_CH1_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH1_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH1_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH1_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH1_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH1_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH1_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH1_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH1_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH1_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH1_DSR_DSC_DECL (30:20)

/*** HDMAC_CH2_SAR (0x400800b0) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH2_SAR_ADDR (0x400800b0)
#define IAXXX_HDMAC_CH2_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH2_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH2_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH2_SAR_SAR_DECL (31:0)

/*** HDMAC_CH2_DAR (0x400800b8) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH2_DAR_ADDR (0x400800b8)
#define IAXXX_HDMAC_CH2_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH2_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH2_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH2_DAR_DAR_DECL (31:0)

/*** HDMAC_CH2_LLP (0x400800c0) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH2_LLP_ADDR (0x400800c0)
#define IAXXX_HDMAC_CH2_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH2_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH2_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH2_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH2_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH2_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH2_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH2_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH2_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH2_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH2_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH2_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH2_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH2_LLP_LOC_DECL (31:2)

/*** HDMAC_CH2_CTL (0x400800c8) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH2_CTL_ADDR (0x400800c8)
#define IAXXX_HDMAC_CH2_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH2_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH2_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH2_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH2_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH2_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH2_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH2_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH2_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH2_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH2_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH2_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH2_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH2_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH2_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH2_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH2_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH2_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH2_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH2_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH2_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH2_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH2_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH2_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH2_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH2_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH2_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH2_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH2_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH2_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH2_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH2_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH2_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH2_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH2_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH2_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH2_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH2_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH2_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH2_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH2_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH2_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH2_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH2_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH2_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH2_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH2_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH2_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH2_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH2_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH2_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH2_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH2_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH2_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH2_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH2_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH2_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH2_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH2_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH2_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH2_CTL_H (0x400800cc) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH2_CTL_H_ADDR (0x400800cc)
#define IAXXX_HDMAC_CH2_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH2_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH2_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH2_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH2_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH2_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH2_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH2_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH2_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH2_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH2_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH2_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH2_CTL_H_DONE_DECL 12

/*** HDMAC_CH2_SSTAT (0x400800d0) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH2_SSTAT_ADDR (0x400800d0)
#define IAXXX_HDMAC_CH2_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH2_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH2_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH2_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH2_DSTAT (0x400800d8) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH2_DSTAT_ADDR (0x400800d8)
#define IAXXX_HDMAC_CH2_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH2_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH2_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH2_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH2_SSTATAR (0x400800e0) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH2_SSTATAR_ADDR (0x400800e0)
#define IAXXX_HDMAC_CH2_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH2_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH2_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH2_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH2_DSTATAR (0x400800e8) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH2_DSTATAR_ADDR (0x400800e8)
#define IAXXX_HDMAC_CH2_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH2_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH2_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH2_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH2_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH2_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH2_CFG (0x400800f0) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH2_CFG_ADDR (0x400800f0)
#define IAXXX_HDMAC_CH2_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH2_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH2_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH2_CFG_RESET_VAL 0x00000e40

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH2_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH2_CFG_CH_PRIOR_RESET_VAL 0x2
#define IAXXX_HDMAC_CH2_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH2_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH2_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH2_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH2_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH2_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH2_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH2_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH2_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH2_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH2_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH2_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH2_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH2_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH2_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH2_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH2_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH2_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH2_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH2_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH2_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH2_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH2_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH2_CFG_H (0x400800f4) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH2_CFG_H_ADDR (0x400800f4)
#define IAXXX_HDMAC_CH2_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH2_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH2_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH2_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH2_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH2_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH2_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH2_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH2_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH2_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH2_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH2_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH2_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH2_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH2_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH2_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH2_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH2_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH2_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH2_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH2_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH2_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH2_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH2_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH2_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH2_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH2_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH2_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH2_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH2_SGR (0x400800f8) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH2_SGR_ADDR (0x400800f8)
#define IAXXX_HDMAC_CH2_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH2_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH2_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH2_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH2_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH2_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH2_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH2_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH2_SGR_SGC_DECL (30:20)

/*** HDMAC_CH2_DSR (0x40080100) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH2_DSR_ADDR (0x40080100)
#define IAXXX_HDMAC_CH2_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH2_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH2_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH2_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH2_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH2_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH2_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH2_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH2_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH2_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH2_DSR_DSC_DECL (30:20)

/*** HDMAC_CH3_SAR (0x40080108) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH3_SAR_ADDR (0x40080108)
#define IAXXX_HDMAC_CH3_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH3_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH3_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH3_SAR_SAR_DECL (31:0)

/*** HDMAC_CH3_DAR (0x40080110) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH3_DAR_ADDR (0x40080110)
#define IAXXX_HDMAC_CH3_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH3_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH3_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH3_DAR_DAR_DECL (31:0)

/*** HDMAC_CH3_LLP (0x40080118) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH3_LLP_ADDR (0x40080118)
#define IAXXX_HDMAC_CH3_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH3_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH3_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH3_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH3_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH3_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH3_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH3_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH3_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH3_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH3_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH3_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH3_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH3_LLP_LOC_DECL (31:2)

/*** HDMAC_CH3_CTL (0x40080120) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH3_CTL_ADDR (0x40080120)
#define IAXXX_HDMAC_CH3_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH3_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH3_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH3_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH3_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH3_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH3_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH3_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH3_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH3_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH3_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH3_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH3_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH3_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH3_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH3_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH3_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH3_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH3_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH3_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH3_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH3_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH3_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH3_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH3_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH3_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH3_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH3_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH3_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH3_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH3_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH3_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH3_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH3_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH3_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH3_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH3_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH3_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH3_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH3_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH3_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH3_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH3_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH3_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH3_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH3_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH3_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH3_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH3_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH3_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH3_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH3_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH3_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH3_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH3_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH3_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH3_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH3_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH3_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH3_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH3_CTL_H (0x40080124) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH3_CTL_H_ADDR (0x40080124)
#define IAXXX_HDMAC_CH3_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH3_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH3_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH3_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH3_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH3_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH3_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH3_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH3_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH3_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH3_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH3_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH3_CTL_H_DONE_DECL 12

/*** HDMAC_CH3_SSTAT (0x40080128) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH3_SSTAT_ADDR (0x40080128)
#define IAXXX_HDMAC_CH3_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH3_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH3_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH3_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH3_DSTAT (0x40080130) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH3_DSTAT_ADDR (0x40080130)
#define IAXXX_HDMAC_CH3_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH3_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH3_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH3_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH3_SSTATAR (0x40080138) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH3_SSTATAR_ADDR (0x40080138)
#define IAXXX_HDMAC_CH3_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH3_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH3_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH3_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH3_DSTATAR (0x40080140) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH3_DSTATAR_ADDR (0x40080140)
#define IAXXX_HDMAC_CH3_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH3_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH3_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH3_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH3_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH3_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH3_CFG (0x40080148) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH3_CFG_ADDR (0x40080148)
#define IAXXX_HDMAC_CH3_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH3_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH3_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH3_CFG_RESET_VAL 0x00000e60

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH3_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH3_CFG_CH_PRIOR_RESET_VAL 0x3
#define IAXXX_HDMAC_CH3_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH3_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH3_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH3_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH3_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH3_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH3_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH3_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH3_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH3_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH3_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH3_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH3_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH3_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH3_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH3_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH3_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH3_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH3_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH3_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH3_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH3_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH3_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH3_CFG_H (0x4008014c) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH3_CFG_H_ADDR (0x4008014c)
#define IAXXX_HDMAC_CH3_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH3_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH3_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH3_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH3_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH3_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH3_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH3_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH3_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH3_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH3_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH3_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH3_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH3_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH3_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH3_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH3_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH3_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH3_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH3_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH3_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH3_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH3_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH3_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH3_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH3_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH3_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH3_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH3_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH3_SGR (0x40080150) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH3_SGR_ADDR (0x40080150)
#define IAXXX_HDMAC_CH3_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH3_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH3_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH3_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH3_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH3_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH3_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH3_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH3_SGR_SGC_DECL (30:20)

/*** HDMAC_CH3_DSR (0x40080158) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH3_DSR_ADDR (0x40080158)
#define IAXXX_HDMAC_CH3_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH3_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH3_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH3_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH3_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH3_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH3_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH3_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH3_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH3_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH3_DSR_DSC_DECL (30:20)

/*** HDMAC_CH4_SAR (0x40080160) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH4_SAR_ADDR (0x40080160)
#define IAXXX_HDMAC_CH4_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH4_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH4_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH4_SAR_SAR_DECL (31:0)

/*** HDMAC_CH4_DAR (0x40080168) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH4_DAR_ADDR (0x40080168)
#define IAXXX_HDMAC_CH4_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH4_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH4_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH4_DAR_DAR_DECL (31:0)

/*** HDMAC_CH4_LLP (0x40080170) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH4_LLP_ADDR (0x40080170)
#define IAXXX_HDMAC_CH4_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH4_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH4_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH4_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH4_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH4_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH4_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH4_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH4_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH4_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH4_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH4_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH4_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH4_LLP_LOC_DECL (31:2)

/*** HDMAC_CH4_CTL (0x40080178) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH4_CTL_ADDR (0x40080178)
#define IAXXX_HDMAC_CH4_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH4_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH4_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH4_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH4_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH4_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH4_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH4_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH4_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH4_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH4_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH4_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH4_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH4_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH4_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH4_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH4_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH4_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH4_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH4_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH4_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH4_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH4_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH4_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH4_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH4_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH4_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH4_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH4_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH4_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH4_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH4_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH4_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH4_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH4_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH4_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH4_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH4_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH4_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH4_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH4_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH4_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH4_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH4_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH4_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH4_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH4_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH4_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH4_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH4_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH4_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH4_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH4_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH4_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH4_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH4_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH4_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH4_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH4_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH4_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH4_CTL_H (0x4008017c) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH4_CTL_H_ADDR (0x4008017c)
#define IAXXX_HDMAC_CH4_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH4_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH4_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH4_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH4_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH4_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH4_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH4_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH4_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH4_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH4_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH4_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH4_CTL_H_DONE_DECL 12

/*** HDMAC_CH4_SSTAT (0x40080180) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH4_SSTAT_ADDR (0x40080180)
#define IAXXX_HDMAC_CH4_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH4_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH4_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH4_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH4_DSTAT (0x40080188) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH4_DSTAT_ADDR (0x40080188)
#define IAXXX_HDMAC_CH4_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH4_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH4_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH4_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH4_SSTATAR (0x40080190) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH4_SSTATAR_ADDR (0x40080190)
#define IAXXX_HDMAC_CH4_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH4_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH4_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH4_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH4_DSTATAR (0x40080198) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH4_DSTATAR_ADDR (0x40080198)
#define IAXXX_HDMAC_CH4_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH4_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH4_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH4_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH4_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH4_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH4_CFG (0x400801a0) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH4_CFG_ADDR (0x400801a0)
#define IAXXX_HDMAC_CH4_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH4_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH4_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH4_CFG_RESET_VAL 0x00000e80

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH4_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH4_CFG_CH_PRIOR_RESET_VAL 0x4
#define IAXXX_HDMAC_CH4_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH4_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH4_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH4_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH4_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH4_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH4_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH4_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH4_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH4_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH4_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH4_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH4_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH4_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH4_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH4_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH4_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH4_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH4_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH4_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH4_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH4_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH4_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH4_CFG_H (0x400801a4) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH4_CFG_H_ADDR (0x400801a4)
#define IAXXX_HDMAC_CH4_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH4_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH4_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH4_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH4_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH4_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH4_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH4_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH4_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH4_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH4_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH4_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH4_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH4_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH4_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH4_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH4_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH4_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH4_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH4_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH4_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH4_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH4_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH4_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH4_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH4_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH4_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH4_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH4_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH4_SGR (0x400801a8) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH4_SGR_ADDR (0x400801a8)
#define IAXXX_HDMAC_CH4_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH4_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH4_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH4_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH4_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH4_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH4_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH4_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH4_SGR_SGC_DECL (30:20)

/*** HDMAC_CH4_DSR (0x400801b0) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH4_DSR_ADDR (0x400801b0)
#define IAXXX_HDMAC_CH4_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH4_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH4_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH4_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH4_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH4_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH4_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH4_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH4_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH4_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH4_DSR_DSC_DECL (30:20)

/*** HDMAC_CH5_SAR (0x400801b8) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH5_SAR_ADDR (0x400801b8)
#define IAXXX_HDMAC_CH5_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH5_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH5_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH5_SAR_SAR_DECL (31:0)

/*** HDMAC_CH5_DAR (0x400801c0) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH5_DAR_ADDR (0x400801c0)
#define IAXXX_HDMAC_CH5_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH5_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH5_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH5_DAR_DAR_DECL (31:0)

/*** HDMAC_CH5_LLP (0x400801c8) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH5_LLP_ADDR (0x400801c8)
#define IAXXX_HDMAC_CH5_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH5_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH5_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH5_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH5_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH5_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH5_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH5_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH5_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH5_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH5_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH5_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH5_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH5_LLP_LOC_DECL (31:2)

/*** HDMAC_CH5_CTL (0x400801d0) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH5_CTL_ADDR (0x400801d0)
#define IAXXX_HDMAC_CH5_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH5_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH5_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH5_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH5_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH5_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH5_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH5_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH5_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH5_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH5_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH5_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH5_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH5_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH5_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH5_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH5_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH5_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH5_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH5_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH5_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH5_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH5_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH5_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH5_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH5_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH5_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH5_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH5_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH5_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH5_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH5_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH5_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH5_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH5_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH5_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH5_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH5_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH5_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH5_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH5_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH5_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH5_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH5_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH5_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH5_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH5_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH5_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH5_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH5_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH5_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH5_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH5_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH5_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH5_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH5_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH5_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH5_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH5_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH5_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH5_CTL_H (0x400801d4) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH5_CTL_H_ADDR (0x400801d4)
#define IAXXX_HDMAC_CH5_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH5_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH5_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH5_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH5_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH5_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH5_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH5_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH5_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH5_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH5_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH5_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH5_CTL_H_DONE_DECL 12

/*** HDMAC_CH5_SSTAT (0x400801d8) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH5_SSTAT_ADDR (0x400801d8)
#define IAXXX_HDMAC_CH5_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH5_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH5_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH5_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH5_DSTAT (0x400801e0) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH5_DSTAT_ADDR (0x400801e0)
#define IAXXX_HDMAC_CH5_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH5_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH5_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH5_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH5_SSTATAR (0x400801e8) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH5_SSTATAR_ADDR (0x400801e8)
#define IAXXX_HDMAC_CH5_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH5_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH5_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH5_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH5_DSTATAR (0x400801f0) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH5_DSTATAR_ADDR (0x400801f0)
#define IAXXX_HDMAC_CH5_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH5_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH5_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH5_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH5_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH5_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH5_CFG (0x400801f8) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH5_CFG_ADDR (0x400801f8)
#define IAXXX_HDMAC_CH5_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH5_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH5_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH5_CFG_RESET_VAL 0x00000ea0

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH5_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH5_CFG_CH_PRIOR_RESET_VAL 0x5
#define IAXXX_HDMAC_CH5_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH5_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH5_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH5_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH5_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH5_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH5_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH5_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH5_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH5_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH5_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH5_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH5_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH5_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH5_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH5_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH5_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH5_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH5_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH5_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH5_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH5_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH5_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH5_CFG_H (0x400801fc) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH5_CFG_H_ADDR (0x400801fc)
#define IAXXX_HDMAC_CH5_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH5_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH5_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH5_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH5_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH5_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH5_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH5_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH5_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH5_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH5_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH5_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH5_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH5_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH5_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH5_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH5_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH5_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH5_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH5_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH5_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH5_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH5_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH5_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH5_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH5_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH5_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH5_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH5_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH5_SGR (0x40080200) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH5_SGR_ADDR (0x40080200)
#define IAXXX_HDMAC_CH5_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH5_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH5_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH5_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH5_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH5_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH5_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH5_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH5_SGR_SGC_DECL (30:20)

/*** HDMAC_CH5_DSR (0x40080208) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH5_DSR_ADDR (0x40080208)
#define IAXXX_HDMAC_CH5_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH5_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH5_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH5_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH5_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH5_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH5_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH5_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH5_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH5_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH5_DSR_DSC_DECL (30:20)

/*** HDMAC_CH6_SAR (0x40080210) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH6_SAR_ADDR (0x40080210)
#define IAXXX_HDMAC_CH6_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH6_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH6_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH6_SAR_SAR_DECL (31:0)

/*** HDMAC_CH6_DAR (0x40080218) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH6_DAR_ADDR (0x40080218)
#define IAXXX_HDMAC_CH6_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH6_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH6_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH6_DAR_DAR_DECL (31:0)

/*** HDMAC_CH6_LLP (0x40080220) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH6_LLP_ADDR (0x40080220)
#define IAXXX_HDMAC_CH6_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH6_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH6_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH6_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH6_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH6_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH6_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH6_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH6_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH6_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH6_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH6_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH6_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH6_LLP_LOC_DECL (31:2)

/*** HDMAC_CH6_CTL (0x40080228) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH6_CTL_ADDR (0x40080228)
#define IAXXX_HDMAC_CH6_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH6_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH6_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH6_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH6_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH6_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH6_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH6_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH6_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH6_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH6_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH6_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH6_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH6_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH6_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH6_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH6_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH6_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH6_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH6_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH6_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH6_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH6_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH6_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH6_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH6_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH6_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH6_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH6_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH6_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH6_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH6_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH6_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH6_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH6_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH6_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH6_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH6_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH6_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH6_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH6_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH6_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH6_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH6_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH6_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH6_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH6_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH6_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH6_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH6_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH6_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH6_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH6_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH6_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH6_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH6_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH6_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH6_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH6_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH6_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH6_CTL_H (0x4008022c) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH6_CTL_H_ADDR (0x4008022c)
#define IAXXX_HDMAC_CH6_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH6_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH6_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH6_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH6_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH6_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH6_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH6_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH6_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH6_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH6_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH6_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH6_CTL_H_DONE_DECL 12

/*** HDMAC_CH6_SSTAT (0x40080230) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH6_SSTAT_ADDR (0x40080230)
#define IAXXX_HDMAC_CH6_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH6_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH6_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH6_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH6_DSTAT (0x40080238) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH6_DSTAT_ADDR (0x40080238)
#define IAXXX_HDMAC_CH6_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH6_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH6_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH6_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH6_SSTATAR (0x40080240) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH6_SSTATAR_ADDR (0x40080240)
#define IAXXX_HDMAC_CH6_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH6_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH6_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH6_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH6_DSTATAR (0x40080248) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH6_DSTATAR_ADDR (0x40080248)
#define IAXXX_HDMAC_CH6_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH6_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH6_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH6_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH6_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH6_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH6_CFG (0x40080250) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH6_CFG_ADDR (0x40080250)
#define IAXXX_HDMAC_CH6_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH6_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH6_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH6_CFG_RESET_VAL 0x00000ec0

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH6_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH6_CFG_CH_PRIOR_RESET_VAL 0x6
#define IAXXX_HDMAC_CH6_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH6_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH6_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH6_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH6_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH6_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH6_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH6_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH6_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH6_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH6_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH6_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH6_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH6_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH6_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH6_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH6_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH6_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH6_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH6_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH6_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH6_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH6_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH6_CFG_H (0x40080254) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH6_CFG_H_ADDR (0x40080254)
#define IAXXX_HDMAC_CH6_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH6_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH6_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH6_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH6_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH6_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH6_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH6_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH6_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH6_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH6_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH6_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH6_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH6_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH6_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH6_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH6_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH6_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH6_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH6_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH6_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH6_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH6_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH6_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH6_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH6_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH6_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH6_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH6_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH6_SGR (0x40080258) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH6_SGR_ADDR (0x40080258)
#define IAXXX_HDMAC_CH6_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH6_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH6_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH6_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH6_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH6_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH6_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH6_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH6_SGR_SGC_DECL (30:20)

/*** HDMAC_CH6_DSR (0x40080260) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH6_DSR_ADDR (0x40080260)
#define IAXXX_HDMAC_CH6_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH6_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH6_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH6_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH6_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH6_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH6_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH6_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH6_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH6_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH6_DSR_DSC_DECL (30:20)

/*** HDMAC_CH7_SAR (0x40080268) ***/
/*
 * The starting source address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the source address of the current AHB transfer.
 */
#define IAXXX_HDMAC_CH7_SAR_ADDR (0x40080268)
#define IAXXX_HDMAC_CH7_SAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SAR_RESET_VAL 0x00000000

/*
 * Current Source Address of DMA transfer.
 * Updated after each source transfer. The SINC field in the CTLx register
 * determines whether the address increments, decrements, or is left
 * unchanged on every source transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH7_SAR_SAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_SAR_SAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_SAR_SAR_POS 0
#define IAXXX_HDMAC_CH7_SAR_SAR_SIZE 32
#define IAXXX_HDMAC_CH7_SAR_SAR_DECL (31:0)

/*** HDMAC_CH7_DAR (0x40080270) ***/
/*
 * The starting destination address is programmed by software before the DMA
 * channel is enabled, or by an LLI update before the start of the DMA
 * transfer. While the DMA transfer is in progress, this register is updated
 * to reflect the destination address of the current AHB transfer
 */
#define IAXXX_HDMAC_CH7_DAR_ADDR (0x40080270)
#define IAXXX_HDMAC_CH7_DAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DAR_RESET_VAL 0x00000000

/*
 * Current Destination address of DMA transfer.
 * Updated after each destination transfer. The DINC field in the CTLx
 * register determines whether the address increments, decrements, or is left
 * unchanged on every destination transfer throughout the block transfer.
 */
#define IAXXX_HDMAC_CH7_DAR_DAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_DAR_DAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_DAR_DAR_POS 0
#define IAXXX_HDMAC_CH7_DAR_DAR_SIZE 32
#define IAXXX_HDMAC_CH7_DAR_DAR_DECL (31:0)

/*** HDMAC_CH7_LLP (0x40080278) ***/
/*
 * Linked List Pointer Register for Channel
 */
#define IAXXX_HDMAC_CH7_LLP_ADDR (0x40080278)
#define IAXXX_HDMAC_CH7_LLP_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_LLP_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_LLP_WMASK_VAL 0xfffffffd
#define IAXXX_HDMAC_CH7_LLP_RESET_VAL 0x00000000

/*
 * List Master Select. Identifies the AHB layer/interface where the memory
 * device that stores the next linked list item resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 * This field does not exist if the configuration parameter DMAH_CHx_LMS is
 * not set to NO_HARDCODE. In this case, the read-back value is always the
 * hardcoded value.
 */
#define IAXXX_HDMAC_CH7_LLP_LMS_MASK 0x00000001
#define IAXXX_HDMAC_CH7_LLP_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_LLP_LMS_POS 0
#define IAXXX_HDMAC_CH7_LLP_LMS_SIZE 1
#define IAXXX_HDMAC_CH7_LLP_LMS_DECL 0

/*
 * As there are only 2 masters, this bit is reserved in DMAC
 */
#define IAXXX_HDMAC_CH7_LLP_RES_LMS_MASK 0x00000002
#define IAXXX_HDMAC_CH7_LLP_RES_LMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_LLP_RES_LMS_POS 1
#define IAXXX_HDMAC_CH7_LLP_RES_LMS_SIZE 1
#define IAXXX_HDMAC_CH7_LLP_RES_LMS_DECL 1

/*
 * Starting Address In Memory of next LLI if block chaining is enabled. Note
 * that the two LSBs of the starting address are not stored because the
 * address is assumed to be aligned to a 32-bit boundary.  LLI accesses are
 * always 32-bit accesses (Hsize = 2) aligned to 32-bit boundaries and cannot
 * be changed or programmed to anything other than 32- bit.
 */
#define IAXXX_HDMAC_CH7_LLP_LOC_MASK 0xfffffffc
#define IAXXX_HDMAC_CH7_LLP_LOC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_LLP_LOC_POS 2
#define IAXXX_HDMAC_CH7_LLP_LOC_SIZE 30
#define IAXXX_HDMAC_CH7_LLP_LOC_DECL (31:2)

/*** HDMAC_CH7_CTL (0x40080280) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH7_CTL_ADDR (0x40080280)
#define IAXXX_HDMAC_CH7_CTL_MASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH7_CTL_RMASK_VAL 0x1ff7ffff
#define IAXXX_HDMAC_CH7_CTL_WMASK_VAL 0x1af7ffff
#define IAXXX_HDMAC_CH7_CTL_RESET_VAL 0x00304801

/*
 * Interrupt Enable Bit. If set, then all interrupt-generating sources are
 * enabled. Functions as a global mask bit for all interrupts for the
 * channel.
 */
#define IAXXX_HDMAC_CH7_CTL_INT_EN_MASK 0x00000001
#define IAXXX_HDMAC_CH7_CTL_INT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CTL_INT_EN_POS 0
#define IAXXX_HDMAC_CH7_CTL_INT_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_INT_EN_DECL 0

/*
 * Destination Transfer Width lists the decoding for this field. Mapped to
 * AHB bus hsize. For a non-memory peripheral, typically rgw peripheral
 * (destination) FIFO width.  This value must be less than or equal to
 * DMAH_Mk_HDATA_WIDTH, where k is the AHB layer 1 to 4 where the destination
 * resides.
 */
#define IAXXX_HDMAC_CH7_CTL_DST_TR_WIDTH_MASK 0x0000000e
#define IAXXX_HDMAC_CH7_CTL_DST_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_DST_TR_WIDTH_POS 1
#define IAXXX_HDMAC_CH7_CTL_DST_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH7_CTL_DST_TR_WIDTH_DECL (3:1)

/*
 * Source Transfer Width lists the decoding for this field.  Mapped to AHB
 * bus hsize. For a non-memory peripheral, typically the peripheral (source)
 * FIFO width.  This value must be less than or equal to DMAH_Mx_HDATA_WIDTH,
 * where x is the AHB layer 1 to 4 where the source resides.
 */
#define IAXXX_HDMAC_CH7_CTL_SRC_TR_WIDTH_MASK 0x00000070
#define IAXXX_HDMAC_CH7_CTL_SRC_TR_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_SRC_TR_WIDTH_POS 4
#define IAXXX_HDMAC_CH7_CTL_SRC_TR_WIDTH_SIZE 3
#define IAXXX_HDMAC_CH7_CTL_SRC_TR_WIDTH_DECL (6:4)

/*
 * Destination Address Increment. Indicates whether to increment or decrement
 * the destination address on every destination transfer. If your device is
 * writing data to a destination peripheral FIFO with a fixed address, then
 * set this field to No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH7_CTL_DINC_MASK 0x00000180
#define IAXXX_HDMAC_CH7_CTL_DINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_DINC_POS 7
#define IAXXX_HDMAC_CH7_CTL_DINC_SIZE 2
#define IAXXX_HDMAC_CH7_CTL_DINC_DECL (8:7)

/*
 * Source Address Increment. Indicates whether to increment or decrement the
 * source address on every source transfer. If the device is fetching data
 * from a source peripheral FIFO with a fixed address, then set this field to
 * No change.
 * 00 = Increment
 * 01 = Decrement
 * 1x = No change
 */
#define IAXXX_HDMAC_CH7_CTL_SINC_MASK 0x00000600
#define IAXXX_HDMAC_CH7_CTL_SINC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_SINC_POS 9
#define IAXXX_HDMAC_CH7_CTL_SINC_SIZE 2
#define IAXXX_HDMAC_CH7_CTL_SINC_DECL (10:9)

/*
 * Destination Burst Transaction Length. Number of data items, each of width
 * CTLx.DST_TR_WIDTH, to be written to the destination every time a
 * destination burst transaction request is made from either the
 * corresponding hardware or software handshaking interface.
 */
#define IAXXX_HDMAC_CH7_CTL_DEST_MSIZE_MASK 0x00003800
#define IAXXX_HDMAC_CH7_CTL_DEST_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CTL_DEST_MSIZE_POS 11
#define IAXXX_HDMAC_CH7_CTL_DEST_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH7_CTL_DEST_MSIZE_DECL (13:11)

/*
 * Source Burst Transaction Length. Number of data items, each of width
 * CTLx.SRC_TR_WIDTH, to be read from the source every time a source burst
 * transaction request is made from either the corresponding hardware or
 * software handshaking interface.
 */
#define IAXXX_HDMAC_CH7_CTL_SRC_MSIZE_MASK 0x0001c000
#define IAXXX_HDMAC_CH7_CTL_SRC_MSIZE_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CTL_SRC_MSIZE_POS 14
#define IAXXX_HDMAC_CH7_CTL_SRC_MSIZE_SIZE 3
#define IAXXX_HDMAC_CH7_CTL_SRC_MSIZE_DECL (16:14)

/*
 * Source gather enable bit
 * 0 = Gather disabled
 * 1 = Gather enabled
 * Gather on the source side is applicable only when the CTLx.SINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH7_CTL_SRC_GATHER_EN_MASK 0x00020000
#define IAXXX_HDMAC_CH7_CTL_SRC_GATHER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_SRC_GATHER_EN_POS 17
#define IAXXX_HDMAC_CH7_CTL_SRC_GATHER_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_SRC_GATHER_EN_DECL 17

/*
 * Destination scatter enable bit
 * 0 = Scatter disabled
 * 1 = Scatter enabled
 * Scatter on the destination side is applicable only when the CTLx.DINC bit
 * indicates an incrementing or decrementing address control.
 */
#define IAXXX_HDMAC_CH7_CTL_DST_SCATTER_EN_MASK 0x00040000
#define IAXXX_HDMAC_CH7_CTL_DST_SCATTER_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_DST_SCATTER_EN_POS 18
#define IAXXX_HDMAC_CH7_CTL_DST_SCATTER_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_DST_SCATTER_EN_DECL 18

/*
 * Transfer Type and Flow Control. The following transfer types are
 * supported.
 * 000 - Memory to Memory (DMA is Flow Controller)
 * 001 - Memory to Peripheral (DMA is Flow Controller)
 * 010 - Peripheral to Memory (DMA is Flow Controller)
 * 011 - Peripheral to Peripheral (DMA is Flow Controller)
 * 100 - Peripheral to Memory (Peripheral is Flow Controller)
 * 101 - Peripheral to Peripheral (Source Peripheral is Flow Controller)
 * 110 - Memory to Peripheral (Peripheral is Flow Controller)
 * 111 - Peripheral to Peripheral (Destination Peripheral is Flow Controller)
 * Flow Control can be assigned to the DW_ahb_dmac, the source peripheral, or
 * the destination peripheral.
 */
#define IAXXX_HDMAC_CH7_CTL_TT_FC_MASK 0x00700000
#define IAXXX_HDMAC_CH7_CTL_TT_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_CH7_CTL_TT_FC_POS 20
#define IAXXX_HDMAC_CH7_CTL_TT_FC_SIZE 3
#define IAXXX_HDMAC_CH7_CTL_TT_FC_DECL (22:20)

/*
 * Destination Master Select. Identifies the Master Interface layer where the
 * destination device (peripheral or memory) resides.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH7_CTL_DMS_MASK 0x00800000
#define IAXXX_HDMAC_CH7_CTL_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_DMS_POS 23
#define IAXXX_HDMAC_CH7_CTL_DMS_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_DMS_DECL 23

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH7_CTL_RES_DMS_MASK 0x01000000
#define IAXXX_HDMAC_CH7_CTL_RES_DMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_RES_DMS_POS 24
#define IAXXX_HDMAC_CH7_CTL_RES_DMS_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_RES_DMS_DECL 24

/*
 * Source Master Select. Identifies the Master Interface layer from which the
 * source device (peripheral or memory) is accessed.
 * 0 = AHB master 1
 * 1 = AHB master 2
 */
#define IAXXX_HDMAC_CH7_CTL_SMS_MASK 0x02000000
#define IAXXX_HDMAC_CH7_CTL_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_SMS_POS 25
#define IAXXX_HDMAC_CH7_CTL_SMS_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_SMS_DECL 25

/*
 * this field is reserved as there are only 2 masters in DMAC
 */
#define IAXXX_HDMAC_CH7_CTL_RES_SMS_MASK 0x04000000
#define IAXXX_HDMAC_CH7_CTL_RES_SMS_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_RES_SMS_POS 26
#define IAXXX_HDMAC_CH7_CTL_RES_SMS_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_RES_SMS_DECL 26

/*
 * Block chaining is enabled on the destination side only if the LLP_DST_EN
 * field is high and LLPx.LOC is non-zero.
 */
#define IAXXX_HDMAC_CH7_CTL_LLP_DST_EN_MASK 0x08000000
#define IAXXX_HDMAC_CH7_CTL_LLP_DST_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_LLP_DST_EN_POS 27
#define IAXXX_HDMAC_CH7_CTL_LLP_DST_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_LLP_DST_EN_DECL 27

/*
 * Block chaining is enabled on the source side only if the LLP_SRC_EN field
 * is high and LLPx.LOC is non-zero
 */
#define IAXXX_HDMAC_CH7_CTL_LLP_SRC_EN_MASK 0x10000000
#define IAXXX_HDMAC_CH7_CTL_LLP_SRC_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_LLP_SRC_EN_POS 28
#define IAXXX_HDMAC_CH7_CTL_LLP_SRC_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_LLP_SRC_EN_DECL 28

/*** HDMAC_CH7_CTL_H (0x40080284) ***/
/*
 * This register contains fields that control the DMA transfer.
 * The CTLx register is part of the block descriptor (linked list item - LLI)
 * when block chaining is enabled. It can be varied on a block-by-block basis
 * within a DMA transfer when block chaining is enabled.
 */
#define IAXXX_HDMAC_CH7_CTL_H_ADDR (0x40080284)
#define IAXXX_HDMAC_CH7_CTL_H_MASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH7_CTL_H_RMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH7_CTL_H_WMASK_VAL 0x000017ff
#define IAXXX_HDMAC_CH7_CTL_H_RESET_VAL 0x00000002

/*
 * Block Transfer Size.  When the DW_ahb_dmac is the flow controller, the
 * user writes this field before the channel is enabled in order to indicate
 * the block size.  The number programmed into BLOCK_TS indicates the total
 * number of single transactions to perform for every block transfer; a
 * single transaction is mapped to a single AMBA beat.
 * Width- The width of the single transaction is determined by
 * CTLx.SRC_TR_WIDTH. Once the transfer starts, the read-back value is the
 * total number of data items already read from the source peripheral,
 * regardless of what is the flow controller.
 * When the source or destination peripheral is assigned as the flow
 * controller, then the maximum block size that can be read back saturates at
 * DMAH_CHx_MAX_BLK_SIZE, but the actual block size can be greater.
 */
#define IAXXX_HDMAC_CH7_CTL_H_BLOCK_TS_MASK 0x000007ff
#define IAXXX_HDMAC_CH7_CTL_H_BLOCK_TS_RESET_VAL 0x2
#define IAXXX_HDMAC_CH7_CTL_H_BLOCK_TS_POS 0
#define IAXXX_HDMAC_CH7_CTL_H_BLOCK_TS_SIZE 11
#define IAXXX_HDMAC_CH7_CTL_H_BLOCK_TS_DECL (10:0)

/*
 * Done bit If status write-back is enabled, the upper word of the control
 * register, CTLx[(63:32)], is written to the control register location of the
 * Linked List Item (LLI) in system memory at the end of the block transfer
 * with the done bit set.
 * Software can poll the LLI CTLx.DONE bit to see when a block transfer is
 * complete. The LLI CTLx.DONE bit should be cleared when the linked lists
 * are set up in memory prior to enabling the channel.
 * LLI accesses are always 32-bit accesses (Hsize = 2) aligned to 32-bit
 * boundaries and cannot be changed or programmed to anything other than
 * 32-bit.
 */
#define IAXXX_HDMAC_CH7_CTL_H_DONE_MASK 0x00001000
#define IAXXX_HDMAC_CH7_CTL_H_DONE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CTL_H_DONE_POS 12
#define IAXXX_HDMAC_CH7_CTL_H_DONE_SIZE 1
#define IAXXX_HDMAC_CH7_CTL_H_DONE_DECL 12

/*** HDMAC_CH7_SSTAT (0x40080288) ***/
/*
 * After each block transfer completes, hardware can retrieve the source
 * status information from the address pointed to by the contents of the
 * SSTATARx register. This status information is then stored in the SSTATx
 * register and written out to the SSTATx register location of the LLI before
 * the start of the next block.
 */
#define IAXXX_HDMAC_CH7_SSTAT_ADDR (0x40080288)
#define IAXXX_HDMAC_CH7_SSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTAT_RESET_VAL 0x00000000

/*
 * Source status information retrieved by hardware from the address pointed
 * to by the contents of the SSTATARx register.
 */
#define IAXXX_HDMAC_CH7_SSTAT_SSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_SSTAT_SSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_SSTAT_SSTAT_POS 0
#define IAXXX_HDMAC_CH7_SSTAT_SSTAT_SIZE 32
#define IAXXX_HDMAC_CH7_SSTAT_SSTAT_DECL (31:0)

/*** HDMAC_CH7_DSTAT (0x40080290) ***/
/*
 * After the completion of each block transfer, hardware can retrieve the
 * destination status information from the address pointed to by the contents
 * of the DSTATARx register. This status information is then stored in the
 * DSTATx register and written out to the DSTATx register location of the LLI
 * before the start of the next block.
 */
#define IAXXX_HDMAC_CH7_DSTAT_ADDR (0x40080290)
#define IAXXX_HDMAC_CH7_DSTAT_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTAT_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTAT_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTAT_RESET_VAL 0x00000000

/*
 * Destination status information retrieved by hardware from the address
 * pointed to by the contents of the DSTATARx register.
 */
#define IAXXX_HDMAC_CH7_DSTAT_DSTAT_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_DSTAT_DSTAT_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_DSTAT_DSTAT_POS 0
#define IAXXX_HDMAC_CH7_DSTAT_DSTAT_SIZE 32
#define IAXXX_HDMAC_CH7_DSTAT_DSTAT_DECL (31:0)

/*** HDMAC_CH7_SSTATAR (0x40080298) ***/
/*
 * After completion of each block transfer, hardware can retrieve the source
 * status information from the user-defined address to which the contents of
 * the SSTATARx register point. The user can select any location in system
 * memory that would provide a 32-bit value to indicate the status of the
 * source transfer. For example, if the DW_apb_ssi is the source peripheral
 * for the DMA transfer, the user can use one of the SSI registers to
 * indicate the status of the transfer. Thus the address programmed in
 * SSTATARx could be the address of the SSI.CTRL register or the SSI.ISR
 * register, or it could be the address of the SSI.RXFLR register.
 */
#define IAXXX_HDMAC_CH7_SSTATAR_ADDR (0x40080298)
#define IAXXX_HDMAC_CH7_SSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_SSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the source status information, which
 * is registered in the SSTATx register and written out to the SSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH7_SSTATAR_SSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_SSTATAR_SSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_SSTATAR_SSTATAR_POS 0
#define IAXXX_HDMAC_CH7_SSTATAR_SSTATAR_SIZE 32
#define IAXXX_HDMAC_CH7_SSTATAR_SSTATAR_DECL (31:0)

/*** HDMAC_CH7_DSTATAR (0x400802a0) ***/
/*
 * After completion of each block transfer, hardware can retrieve the
 * destination status information from the user-defined address to which the
 * contents of the DSTATARx register point. The user can select any location
 * in system memory that would provide a 32-bit value to indicate the status
 * of the destination transfer. For example, if the DW_apb_ssi is the
 * destination peripheral for the DMA transfer, the user can use one of the
 * SSI registers to indicate the status of the transfer. Thus the address
 * programmed in DSTATARx could be the address of the SSI.CTRL register or
 * the SSI.ISR register, or it could be the address of the SSI.TXFLR
 * register.
 */
#define IAXXX_HDMAC_CH7_DSTATAR_ADDR (0x400802a0)
#define IAXXX_HDMAC_CH7_DSTATAR_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTATAR_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTATAR_WMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CH7_DSTATAR_RESET_VAL 0x00000000

/*
 * Pointer from where hardware can fetch the destination status information,
 * which is registered in the DSTATx register and written out to the DSTATx
 * register location of the LLI before the start of the next block.
 */
#define IAXXX_HDMAC_CH7_DSTATAR_DSTATAR_MASK 0xffffffff
#define IAXXX_HDMAC_CH7_DSTATAR_DSTATAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_DSTATAR_DSTATAR_POS 0
#define IAXXX_HDMAC_CH7_DSTATAR_DSTATAR_SIZE 32
#define IAXXX_HDMAC_CH7_DSTATAR_DSTATAR_DECL (31:0)

/*** HDMAC_CH7_CFG (0x400802a8) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH7_CFG_ADDR (0x400802a8)
#define IAXXX_HDMAC_CH7_CFG_MASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH7_CFG_RMASK_VAL 0xffffffe0
#define IAXXX_HDMAC_CH7_CFG_WMASK_VAL 0xc00c0de0
#define IAXXX_HDMAC_CH7_CFG_RESET_VAL 0x00000ee0

/*
 * Channel priority. A priority of 7 is the highest priority, and 0 is the
 * lowest. This field must be programmed within the following range-
 * 0: (DMAH_NUM_CHANNELS - 1)
 * A programmed value outside this range will cause erroneous behavior.
 */
#define IAXXX_HDMAC_CH7_CFG_CH_PRIOR_MASK 0x000000e0
#define IAXXX_HDMAC_CH7_CFG_CH_PRIOR_RESET_VAL 0x7
#define IAXXX_HDMAC_CH7_CFG_CH_PRIOR_POS 5
#define IAXXX_HDMAC_CH7_CFG_CH_PRIOR_SIZE 3
#define IAXXX_HDMAC_CH7_CFG_CH_PRIOR_DECL (7:5)

/*
 * Channel Suspend. Suspends all DMA data transfers from the source until
 * this bit is cleared. There is no guarantee that the current transaction
 * will complete. Can also be used in conjunction with CFGx.FIFO_EMPTY to
 * cleanly disable a channel without losing any data.
 * 0 = Not suspended.
 * 1 = Suspend DMA transfer from the source.
 */
#define IAXXX_HDMAC_CH7_CFG_CH_SUSP_MASK 0x00000100
#define IAXXX_HDMAC_CH7_CFG_CH_SUSP_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_CH_SUSP_POS 8
#define IAXXX_HDMAC_CH7_CFG_CH_SUSP_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_CH_SUSP_DECL 8

/*
 * Indicates if there is data left in the channel FIFO. Can be used in
 * conjunction with CFGx. CH_SUSP to cleanly disable a channel.
 * 1 = Channel FIFO empty
 * 0 = Channel FIFO not empty
 */
#define IAXXX_HDMAC_CH7_CFG_FIFO_EMPTY_MASK 0x00000200
#define IAXXX_HDMAC_CH7_CFG_FIFO_EMPTY_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CFG_FIFO_EMPTY_POS 9
#define IAXXX_HDMAC_CH7_CFG_FIFO_EMPTY_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_FIFO_EMPTY_DECL 9

/*
 * Destination Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software  - is active
 * for destination requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware- initiated transaction
 * requests are ignored.
 * If the destination peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_DST_MASK 0x00000400
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_DST_POS 10
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_DST_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_DST_DECL 10

/*
 * Source Software or Hardware Handshaking Select. This register selects
 * which of the handshaking interfaces - hardware or software - is active for
 * source requests on this channel.
 * 0 = Hardware handshaking interface. Software-initiated transaction
 * requests are ignored.
 * 1 = Software handshaking interface. Hardware-initiated transaction
 * requests are ignored.
 * If the source peripheral is memory, then this bit is ignored.
 */
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_SRC_MASK 0x00000800
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_SRC_POS 11
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_SRC_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_HS_SEL_SRC_DECL 11

/*
 * Channel Lock Level. Indicates the duration over which CFGx.LOCK_CH bit
 * applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_L_MASK 0x00003000
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_L_POS 12
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_L_SIZE 2
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_L_DECL (13:12)

/*
 * Bus Lock Level. Indicates the duration over which CFGx.LOCK_B bit applies.
 * 00 = Over complete DMA transfer
 * 01 = Over complete DMA block transfer
 * 1x = Over complete DMA transaction
 * This field does not exist if the parameter DMAH_CHx_LOCK_EN is set to
 * False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_L_MASK 0x0000c000
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_L_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_L_POS 14
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_L_SIZE 2
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_L_DECL (15:14)

/*
 * Channel Lock Bit. When the channel is granted control of the master bus
 * interface and if the CFGx.LOCK_CH bit is asserted, then no other channels
 * are granted control of the master bus interface for the duration specified
 * in CFGx.LOCK_CH_L.  Indicates to the master bus interface arbiter that
 * this channel wants exclusive access to the master bus interface for the
 * duration specified in CFGx.LOCK_CH_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_MASK 0x00010000
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_POS 16
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_LOCK_CH_DECL 16

/*
 * Bus Lock Bit. When active, the AHB bus master signal hlock is asserted for
 * the duration specified in CFGx.LOCK_B_L.
 * This field does not exist if the configuration parameter DMAH_CHx_LOCK_EN
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_MASK 0x00020000
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_POS 17
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_LOCK_B_DECL 17

/*
 * Destination Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH7_CFG_DST_HS_POL_MASK 0x00040000
#define IAXXX_HDMAC_CH7_CFG_DST_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_DST_HS_POL_POS 18
#define IAXXX_HDMAC_CH7_CFG_DST_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_DST_HS_POL_DECL 18

/*
 * Source Handshaking Interface Polarity.
 * 0 = Active high
 * 1 = Active low
 */
#define IAXXX_HDMAC_CH7_CFG_SRC_HS_POL_MASK 0x00080000
#define IAXXX_HDMAC_CH7_CFG_SRC_HS_POL_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_SRC_HS_POL_POS 19
#define IAXXX_HDMAC_CH7_CFG_SRC_HS_POL_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_SRC_HS_POL_DECL 19

/*
 * Maximum AMBA Burst Length. Maximum AMBA burst length that is used for DMA
 * transfers on this channel.
 * A value of 0 indicates that software is not limiting the maximum AMBA
 * burst length for DMA transfers on this channel. This field does not exist
 * if the configuration parameter DMAH_MABRST is not selected;in this
 * case,the read-back value is always 0, and the maximum AMBA burst length
 * cannot be limited by software.
 */
#define IAXXX_HDMAC_CH7_CFG_MAX_ABRST_MASK 0x3ff00000
#define IAXXX_HDMAC_CH7_CFG_MAX_ABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_MAX_ABRST_POS 20
#define IAXXX_HDMAC_CH7_CFG_MAX_ABRST_SIZE 10
#define IAXXX_HDMAC_CH7_CFG_MAX_ABRST_DECL (29:20)

/*
 * Automatic Source Reload. The SARx register can be automatically reloaded
 * from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This field does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_RELOAD_SRC_MASK 0x40000000
#define IAXXX_HDMAC_CH7_CFG_RELOAD_SRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_RELOAD_SRC_POS 30
#define IAXXX_HDMAC_CH7_CFG_RELOAD_SRC_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_RELOAD_SRC_DECL 30

/*
 * Automatic Destination Reload. The DARx register can be automatically
 * reloaded from its initial value at the end of every block for multi-block
 * transfers. A new block transfer is then initiated.
 * This register does not exist if the configuration parameter
 * DMAH_CHx_MULTI_BLK_EN is not selected; in this case, the read-back value
 * is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_RELOAD_DST_MASK 0x80000000
#define IAXXX_HDMAC_CH7_CFG_RELOAD_DST_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_RELOAD_DST_POS 31
#define IAXXX_HDMAC_CH7_CFG_RELOAD_DST_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_RELOAD_DST_DECL 31

/*** HDMAC_CH7_CFG_H (0x400802ac) ***/
/*
 * This register contains fields that configure the DMA transfer. The channel
 * configuration register remains fixed for all blocks of a multi-block
 * transfer.
 */
#define IAXXX_HDMAC_CH7_CFG_H_ADDR (0x400802ac)
#define IAXXX_HDMAC_CH7_CFG_H_MASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH7_CFG_H_RMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH7_CFG_H_WMASK_VAL 0x00007fff
#define IAXXX_HDMAC_CH7_CFG_H_RESET_VAL 0x00000004

/*
 * Flow Control Mode. Determines when source transaction requests are
 * serviced when the Destination Peripheral is the flow controller.
 * 0 = Source transaction requests are serviced when they occur.  Data
 * pre-fetching is enabled.
 * 1 = Source transaction requests are not serviced until a destination
 * transaction request occurs. In this mode, the amount of data transferred
 * from the source is limited so that it is guaranteed to be transferred to
 * the destination prior to block termination by the destination. Data
 * pre-fetching is disabled.
 */
#define IAXXX_HDMAC_CH7_CFG_H_FCMODE_MASK 0x00000001
#define IAXXX_HDMAC_CH7_CFG_H_FCMODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_FCMODE_POS 0
#define IAXXX_HDMAC_CH7_CFG_H_FCMODE_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_H_FCMODE_DECL 0

/*
 * FIFO Mode Select. Determines how much space or data needs to be available
 * in the FIFO before a burst transaction request is serviced.
 * 0 = Space/data available for single AHB transfer of the specified transfer
 * width.
 * 1 = Data available is greater than or equal to half the FIFO depth for
 * destination transfers and space available is greater than half the fifo
 * depth for source transfers. The exceptions are at the end of a burst
 * transaction request or at the end of a block transfer.
 */
#define IAXXX_HDMAC_CH7_CFG_H_FIFO_MODE_MASK 0x00000002
#define IAXXX_HDMAC_CH7_CFG_H_FIFO_MODE_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_FIFO_MODE_POS 1
#define IAXXX_HDMAC_CH7_CFG_H_FIFO_MODE_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_H_FIFO_MODE_DECL 1

/*
 * Protection Control bits used to drive the AHB HPROT[(3:1)] bus.  The AMBA
 * Specification recommends that the default value of HPROT indicates a
 * non-cached, non-buffered, privileged data access. The reset value is used
 * to indicate such an access.  HPROT[0] is tied high because all transfers
 * are data accesses, as there are no opcode fetches.
 * There is a one-to-one mapping of these register bits to the HPROT[(3:1)]
 * master interface signals.
 */
#define IAXXX_HDMAC_CH7_CFG_H_PROTCTL_MASK 0x0000001c
#define IAXXX_HDMAC_CH7_CFG_H_PROTCTL_RESET_VAL 0x1
#define IAXXX_HDMAC_CH7_CFG_H_PROTCTL_POS 2
#define IAXXX_HDMAC_CH7_CFG_H_PROTCTL_SIZE 3
#define IAXXX_HDMAC_CH7_CFG_H_PROTCTL_DECL (4:2)

/*
 * Destination Status Update Enable. Destination status information is
 * fetched only from the location pointed to by the DSTATARx register, stored
 * in the DSTATx register and written out to the DSTATx location of the LLI
 * if DS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_H_DS_UPD_EN_MASK 0x00000020
#define IAXXX_HDMAC_CH7_CFG_H_DS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_DS_UPD_EN_POS 5
#define IAXXX_HDMAC_CH7_CFG_H_DS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_H_DS_UPD_EN_DECL 5

/*
 * Source Status Update Enable. Source status information is fetched only
 * from the location pointed to by the SSTATARx register, stored in the
 * SSTATx register and written out to the SSTATx location of the LLI if
 * SS_UPD_EN is high.
 * This field does not exist if the configuration parameter DMAH_CHx_STAT_DST
 * is set to False; in this case, the read-back value is always 0.
 */
#define IAXXX_HDMAC_CH7_CFG_H_SS_UPD_EN_MASK 0x00000040
#define IAXXX_HDMAC_CH7_CFG_H_SS_UPD_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_SS_UPD_EN_POS 6
#define IAXXX_HDMAC_CH7_CFG_H_SS_UPD_EN_SIZE 1
#define IAXXX_HDMAC_CH7_CFG_H_SS_UPD_EN_DECL 6

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * source of channel x if the CFGx.HS_SEL_SRC field is 0; otherwise, this
 * field is ignored.  The channel can then communicate with the source
 * peripheral connected to that interface through the assigned hardware
 * handshaking interface.
 */
#define IAXXX_HDMAC_CH7_CFG_H_SRC_PER_MASK 0x00000780
#define IAXXX_HDMAC_CH7_CFG_H_SRC_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_SRC_PER_POS 7
#define IAXXX_HDMAC_CH7_CFG_H_SRC_PER_SIZE 4
#define IAXXX_HDMAC_CH7_CFG_H_SRC_PER_DECL (10:7)

/*
 * Assigns a hardware handshaking interface (0 - DMAH_NUM_HS_INT-1) to the
 * destination of channel x if the CFGx.HS_SEL_DST field is 0; otherwise,
 * this field is ignored.  The channel can then communicate with the
 * destination peripheral connected to that interface through the assigned
 * hardware handshaking interface.
 */
#define IAXXX_HDMAC_CH7_CFG_H_DEST_PER_MASK 0x00007800
#define IAXXX_HDMAC_CH7_CFG_H_DEST_PER_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_CFG_H_DEST_PER_POS 11
#define IAXXX_HDMAC_CH7_CFG_H_DEST_PER_SIZE 4
#define IAXXX_HDMAC_CH7_CFG_H_DEST_PER_DECL (14:11)

/*** HDMAC_CH7_SGR (0x400802b0) ***/
/*
 * Source Gather Register for Channel
 */
#define IAXXX_HDMAC_CH7_SGR_ADDR (0x400802b0)
#define IAXXX_HDMAC_CH7_SGR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_SGR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_SGR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_SGR_RESET_VAL 0x00000000

/*
 * Source gather interval.
 */
#define IAXXX_HDMAC_CH7_SGR_SGI_MASK 0x000fffff
#define IAXXX_HDMAC_CH7_SGR_SGI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_SGR_SGI_POS 0
#define IAXXX_HDMAC_CH7_SGR_SGI_SIZE 20
#define IAXXX_HDMAC_CH7_SGR_SGI_DECL (19:0)

/*
 * Source gather count. Source contiguous transfer count between successive
 * gather boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19
 * Bits 31-b+1 do not exist and read back as 0.
 */
#define IAXXX_HDMAC_CH7_SGR_SGC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH7_SGR_SGC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_SGR_SGC_POS 20
#define IAXXX_HDMAC_CH7_SGR_SGC_SIZE 11
#define IAXXX_HDMAC_CH7_SGR_SGC_DECL (30:20)

/*** HDMAC_CH7_DSR (0x400802b8) ***/
/*
 * Destination Scatter Register for Channel
 */
#define IAXXX_HDMAC_CH7_DSR_ADDR (0x400802b8)
#define IAXXX_HDMAC_CH7_DSR_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_DSR_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_DSR_WMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_CH7_DSR_RESET_VAL 0x00000000

/*
 * Destination scatter interval.
 */
#define IAXXX_HDMAC_CH7_DSR_DSI_MASK 0x000fffff
#define IAXXX_HDMAC_CH7_DSR_DSI_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_DSR_DSI_POS 0
#define IAXXX_HDMAC_CH7_DSR_DSI_SIZE 20
#define IAXXX_HDMAC_CH7_DSR_DSI_DECL (19:0)

/*
 * Destination scatter count. Destination contiguous transfer count between
 * successive scatter boundaries.
 * b = log2 (DMAH_CHx_MAX_BLK_SIZE + 1) + 19.
 * Bits 31-b+1 do not exist and read 0.
 */
#define IAXXX_HDMAC_CH7_DSR_DSC_MASK 0x7ff00000
#define IAXXX_HDMAC_CH7_DSR_DSC_RESET_VAL 0x0
#define IAXXX_HDMAC_CH7_DSR_DSC_POS 20
#define IAXXX_HDMAC_CH7_DSR_DSC_SIZE 11
#define IAXXX_HDMAC_CH7_DSR_DSC_DECL (30:20)

/*** HDMAC_CMN_RAWTFR (0x400802c0) ***/
/*
 * Interrupt events are stored in the RawTfr Raw Interrupt Status registers
 * before masking. Each Raw Interrupt Status register has a bit allocated per
 * channel.
 * Each bit in these registers is cleared by writing a 1 to the corresponding
 * location in the ClearTfr, ClearBlock, ClearSrcTran, ClearDstTran, ClearErr
 * registers.
 * Write access is available to these registers for software testing purposes
 * only. Under normal operation, writes to these registers are not
 * recommended
 */
#define IAXXX_HDMAC_CMN_RAWTFR_ADDR (0x400802c0)
#define IAXXX_HDMAC_CMN_RAWTFR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWTFR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWTFR_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWTFR_RESET_VAL 0x00000000

/*
 * Raw interrupt status
 */
#define IAXXX_HDMAC_CMN_RAWTFR_RAW_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_RAWTFR_RAW_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_RAWTFR_RAW_POS 0
#define IAXXX_HDMAC_CMN_RAWTFR_RAW_SIZE 8
#define IAXXX_HDMAC_CMN_RAWTFR_RAW_DECL (7:0)

/*** HDMAC_CMN_RAWBLOCK (0x400802c8) ***/
/*
 * Interrupt events are stored in the RawBlock Raw Interrupt Status registers
 * before masking. Each Raw Interrupt Status register has a bit allocated per
 * channel.
 * Each bit in these registers is cleared by writing a 1 to the corresponding
 * location in the ClearTfr, ClearBlock, ClearSrcTran, ClearDstTran, ClearErr
 * registers.
 * Write access is available to these registers for software testing purposes
 * only. Under normal operation, writes to these registers are not
 * recommended
 */
#define IAXXX_HDMAC_CMN_RAWBLOCK_ADDR (0x400802c8)
#define IAXXX_HDMAC_CMN_RAWBLOCK_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWBLOCK_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWBLOCK_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWBLOCK_RESET_VAL 0x00000000

/*
 * Raw interrupt status
 */
#define IAXXX_HDMAC_CMN_RAWBLOCK_RAW_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_RAWBLOCK_RAW_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_RAWBLOCK_RAW_POS 0
#define IAXXX_HDMAC_CMN_RAWBLOCK_RAW_SIZE 8
#define IAXXX_HDMAC_CMN_RAWBLOCK_RAW_DECL (7:0)

/*** HDMAC_CMN_RAWSRCTRAN (0x400802d0) ***/
/*
 * Interrupt events are stored in the RawSrcTran Raw Interrupt Status
 * registers before masking. Each Raw Interrupt Status register has a bit
 * allocated per channel.
 * Each bit in these registers is cleared by writing a 1 to the corresponding
 * location in the ClearTfr, ClearBlock,ClearSrcTran, ClearDstTran, ClearErr
 * registers.
 * Write access is available to these registers for software testing purposes
 * only.Under normal operation, writes to these registers are not recommended
 */
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_ADDR (0x400802d0)
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RESET_VAL 0x00000000

/*
 * Raw interrupt status
 */
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RAW_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RAW_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RAW_POS 0
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RAW_SIZE 8
#define IAXXX_HDMAC_CMN_RAWSRCTRAN_RAW_DECL (7:0)

/*** HDMAC_CMN_RAWDSTTRAN (0x400802d8) ***/
/*
 * Interrupt events are stored in the RawDstTran Raw Interrupt Status
 * registers before masking. Each Raw Interrupt Status register has a bit
 * allocated per channel.
 * Each bit in these registers is cleared by writing a 1 to the corresponding
 * location in the ClearTfr, ClearBlock,ClearSrcTran, ClearDstTran, ClearErr
 * registers.
 * Write access is available to these registers for software testing purposes
 * only.Under normal operation, writes to these registers are not recommended
 */
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_ADDR (0x400802d8)
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RESET_VAL 0x00000000

/*
 * Raw interrupt status
 */
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RAW_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RAW_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RAW_POS 0
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RAW_SIZE 8
#define IAXXX_HDMAC_CMN_RAWDSTTRAN_RAW_DECL (7:0)

/*** HDMAC_CMN_RAWERR (0x400802e0) ***/
/*
 * Interrupt events are stored in the RawErr Raw Interrupt Status registers
 * before masking. Each Raw Interrupt Status register has a bit allocated per
 * channel.
 * Each bit in these registers is cleared by writing a 1 to the corresponding
 * location in the ClearTfr, ClearBlock,ClearSrcTran, ClearDstTran, ClearErr
 * registers.
 * Write access is available to these registers for software testing purposes
 * only.Under normal operation, writes to these registers are not recommended
 */
#define IAXXX_HDMAC_CMN_RAWERR_ADDR (0x400802e0)
#define IAXXX_HDMAC_CMN_RAWERR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWERR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWERR_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_RAWERR_RESET_VAL 0x00000000

/*
 * Raw interrupt status
 */
#define IAXXX_HDMAC_CMN_RAWERR_RAW_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_RAWERR_RAW_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_RAWERR_RAW_POS 0
#define IAXXX_HDMAC_CMN_RAWERR_RAW_SIZE 8
#define IAXXX_HDMAC_CMN_RAWERR_RAW_DECL (7:0)

/*** HDMAC_CMN_STATUSTFR (0x400802e8) ***/
/*
 * All interrupt events from all channels are stored in the StatusTfr
 * Interrupt Status registers after masking. Each Interrupt Status register
 * has a bit allocated per channel. The contents of these registers are used
 * to generate the interrupt signals (int or int_n bus, depending on
 * interrupt polarity) leaving the DW_ahb_dmac.
 */
#define IAXXX_HDMAC_CMN_STATUSTFR_ADDR (0x400802e8)
#define IAXXX_HDMAC_CMN_STATUSTFR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSTFR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSTFR_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSTFR_RESET_VAL 0x00000000

/*
 * Interrupt status
 */
#define IAXXX_HDMAC_CMN_STATUSTFR_STATUS_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSTFR_STATUS_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSTFR_STATUS_POS 0
#define IAXXX_HDMAC_CMN_STATUSTFR_STATUS_SIZE 8
#define IAXXX_HDMAC_CMN_STATUSTFR_STATUS_DECL (7:0)

/*** HDMAC_CMN_STATUSBLOCK (0x400802f0) ***/
/*
 * All interrupt events from all channels are stored in the StatusBlock
 * Interrupt Status registers after masking. Each Interrupt Status register
 * has a bit allocated per channel. The contents of these registers are used
 * to generate the interrupt signals (int or int_n bus, depending on
 * interrupt polarity) leaving the DW_ahb_dmac.
 */
#define IAXXX_HDMAC_CMN_STATUSBLOCK_ADDR (0x400802f0)
#define IAXXX_HDMAC_CMN_STATUSBLOCK_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSBLOCK_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSBLOCK_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSBLOCK_RESET_VAL 0x00000000

/*
 * Interrupt status
 */
#define IAXXX_HDMAC_CMN_STATUSBLOCK_STATUS_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSBLOCK_STATUS_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSBLOCK_STATUS_POS 0
#define IAXXX_HDMAC_CMN_STATUSBLOCK_STATUS_SIZE 8
#define IAXXX_HDMAC_CMN_STATUSBLOCK_STATUS_DECL (7:0)

/*** HDMAC_CMN_STATUSSRCTRAN (0x400802f8) ***/
/*
 * All interrupt events from all channels are stored in the StatusSrcTran
 * Interrupt Status registers after masking. Each Interrupt Status register
 * has a bit allocated per channel. The contents of these registers are used
 * to generate the interrupt signals (int or int_n bus, depending on
 * interrupt polarity) leaving the DW_ahb_dmac.
 */
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_ADDR (0x400802f8)
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_RESET_VAL 0x00000000

/*
 * Interrupt status
 */
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_STATUS_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_STATUS_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_STATUS_POS 0
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_STATUS_SIZE 8
#define IAXXX_HDMAC_CMN_STATUSSRCTRAN_STATUS_DECL (7:0)

/*** HDMAC_CMN_STATUSDSTTRAN (0x40080300) ***/
/*
 * All interrupt events from all channels are stored in the StatusDstTran
 * Interrupt Status registers after masking. Each Interrupt Status register
 * has a bit allocated per channel. The contents of these registers are used
 * to generate the interrupt signals (int or int_n bus, depending on
 * interrupt polarity) leaving the DW_ahb_dmac.
 */
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_ADDR (0x40080300)
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_RESET_VAL 0x00000000

/*
 * Interrupt status
 */
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_STATUS_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_STATUS_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_STATUS_POS 0
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_STATUS_SIZE 8
#define IAXXX_HDMAC_CMN_STATUSDSTTRAN_STATUS_DECL (7:0)

/*** HDMAC_CMN_STATUSERR (0x40080308) ***/
/*
 * All interrupt events from all channels are stored in the StatusErr
 * Interrupt Status registers after masking. Each Interrupt Status register
 * has a bit allocated per channel. The contents of these registers are used
 * to generate the interrupt signals (int or int_n bus, depending on
 * interrupt polarity) leaving the DW_ahb_dmac.
 */
#define IAXXX_HDMAC_CMN_STATUSERR_ADDR (0x40080308)
#define IAXXX_HDMAC_CMN_STATUSERR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSERR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSERR_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSERR_RESET_VAL 0x00000000

/*
 * Interrupt status
 */
#define IAXXX_HDMAC_CMN_STATUSERR_STATUS_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_STATUSERR_STATUS_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSERR_STATUS_POS 0
#define IAXXX_HDMAC_CMN_STATUSERR_STATUS_SIZE 8
#define IAXXX_HDMAC_CMN_STATUSERR_STATUS_DECL (7:0)

/*** HDMAC_CMN_MASKTFR (0x40080310) ***/
/*
 * The contents of the Raw Status registers are masked with the contents of
 * the Mask registers-MaskTfr. Each Interrupt Mask register has a bit
 * allocated per channel.
 * When the source peripheral of DMA channel i is memory, then the source
 * transaction complete interrupt, MaskSrcTran[i], must be masked to prevent
 * an erroneous triggering of an interrupt on the int_combined signal.
 * Similarly, when the destination peripheral of DMA channel i is memory,
 * then the destination transaction complete interrupt, MaskDstTran[i], must
 * be masked to prevent an erroneous triggering of an interrupt on the
 * int_combined(_n) signal.
 * A channel INT_MASK bit will be written only if the corresponding mask
 * write enable bit in the INT_MASK_WE field is asserted on the same AHB
 * write transfer. This allows software to set a mask bit without performing
 * a read-modified write operation. For example, writing hex 01x1 to the
 * MaskTfr register writes a 1 into MaskTfr[0], while MaskTfr[(7:1)] remains
 * unchanged. Writing hex 00xx leaves MaskTfr[(7:0)] unchanged.
 * Writing a 1 to any bit in these registers unmasks the corresponding
 * interrupt, thus allowing the DW_ahb_dmac to set the appropriate bit in the
 * Status registers and int_* port signals.
 */
#define IAXXX_HDMAC_CMN_MASKTFR_ADDR (0x40080310)
#define IAXXX_HDMAC_CMN_MASKTFR_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKTFR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_MASKTFR_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKTFR_RESET_VAL 0x00000000

/*
 * Interrupt Mask
 * 0 = masked
 * 1 = unmasked
 */
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_POS 0
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_SIZE 8
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_DECL (7:0)

/*
 * Interrupt Mask Write Enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_WE_POS 8
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_WE_SIZE 8
#define IAXXX_HDMAC_CMN_MASKTFR_INT_MASK_WE_DECL (15:8)

/*** HDMAC_CMN_MASKBLOCK (0x40080318) ***/
/*
 * The contents of the Raw Status registers are masked with the contents of
 * the Mask registers-MaskBlockr. Each Interrupt Mask register has a bit
 * allocated per channel
 * When the source peripheral of DMA channel i is memory, then the source
 * transaction complete interrupt, MaskSrcTran[i], must be masked to prevent
 * an erroneous triggering of an interrupt on the int_combined signal.
 * Similarly, when the destination peripheral of DMA channel i is memory,
 * then the destination transaction complete interrupt, MaskDstTran[i], must
 * be masked to prevent an erroneous triggering of an interrupt on the
 * int_combined(_n) signal.
 * A channel INT_MASK bit will be written only if the corresponding mask
 * write enable bit in the INT_MASK_WE field is asserted on the same AHB
 * write transfer. This allows software to set a mask bit without performing
 * a read-modified write operation. For example, writing hex 01x1 to the
 * MaskTfr register writes a 1 into MaskTfr[0], while MaskTfr[(7:1)] remains
 * unchanged. Writing hex 00xx leaves MaskTfr[(7:0)] unchanged.
 * Writing a 1 to any bit in these registers unmasks the corresponding
 * interrupt, thus allowing the DW_ahb_dmac to set the appropriate bit in the
 * Status registers and int_* port signals.
 */
#define IAXXX_HDMAC_CMN_MASKBLOCK_ADDR (0x40080318)
#define IAXXX_HDMAC_CMN_MASKBLOCK_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKBLOCK_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_MASKBLOCK_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKBLOCK_RESET_VAL 0x00000000

/*
 * Interrupt Mask
 * 0 = masked
 * 1 = unmasked
 */
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_POS 0
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_SIZE 8
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_DECL (7:0)

/*
 * Interrupt Mask Write Enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_WE_POS 8
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_WE_SIZE 8
#define IAXXX_HDMAC_CMN_MASKBLOCK_INT_MASK_WE_DECL (15:8)

/*** HDMAC_CMN_MASKSRCTRAN (0x40080320) ***/
/*
 * The contents of the Raw Status registers are masked with the contents of
 * the Mask registers-MaskSrcTran. Each Interrupt Mask register has a bit
 * allocated per channel
 * When the source peripheral of DMA channel i is memory, then the source
 * transaction complete interrupt, MaskSrcTran[i], must be masked to prevent
 * an erroneous triggering of an interrupt on the int_combined signal.
 * Similarly, when the destination peripheral of DMA channel i is memory,
 * then the destination transaction complete interrupt, MaskDstTran[i], must
 * be masked to prevent an erroneous triggering of an interrupt on the
 * int_combined(_n) signal.
 * A channel INT_MASK bit will be written only if the corresponding mask
 * write enable bit in the INT_MASK_WE field is asserted on the same AHB
 * write transfer. This allows software to set a mask bit without performing
 * a read-modified write operation. For example, writing hex 01x1 to the
 * MaskTfr register writes a 1 into MaskTfr[0], while MaskTfr[(7:1)] remains
 * unchanged. Writing hex 00xx leaves MaskTfr[(7:0)] unchanged.
 * Writing a 1 to any bit in these registers unmasks the corresponding
 * interrupt, thus allowing the DW_ahb_dmac to set the appropriate bit in the
 * Status registers and int_* port signals.
 */
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_ADDR (0x40080320)
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_RESET_VAL 0x00000000

/*
 * Interrupt Mask
 * 0 = masked
 * 1 = unmasked
 */
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_POS 0
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_SIZE 8
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_DECL (7:0)

/*
 * Interrupt Mask Write Enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_WE_POS 8
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_WE_SIZE 8
#define IAXXX_HDMAC_CMN_MASKSRCTRAN_INT_MASK_WE_DECL (15:8)

/*** HDMAC_CMN_MASKDSTTRAN (0x40080328) ***/
/*
 * The contents of the Raw Status registers are masked with the contents of
 * the Mask registers-MaskDstTran. Each Interrupt Mask register has a bit
 * allocated per channel
 * When the source peripheral of DMA channel i is memory, then the source
 * transaction complete interrupt, MaskSrcTran[i], must be masked to prevent
 * an erroneous triggering of an interrupt on the int_combined signal.
 * Similarly, when the destination peripheral of DMA channel i is memory,
 * then the destination transaction complete interrupt, MaskDstTran[i], must
 * be masked to prevent an erroneous triggering of an interrupt on the
 * int_combined(_n) signal.
 * A channel INT_MASK bit will be written only if the corresponding mask
 * write enable bit in the INT_MASK_WE field is asserted on the same AHB
 * write transfer. This allows software to set a mask bit without performing
 * a read-modified write operation. For example, writing hex 01x1 to the
 * MaskTfr register writes a 1 into MaskTfr[0], while MaskTfr[(7:1)] remains
 * unchanged. Writing hex 00xx leaves MaskTfr[(7:0)] unchanged.
 * Writing a 1 to any bit in these registers unmasks the corresponding
 * interrupt, thus allowing the DW_ahb_dmac to set the appropriate bit in the
 * Status registers and int_* port signals.
 */
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_ADDR (0x40080328)
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_RESET_VAL 0x00000000

/*
 * Interrupt Mask
 * 0 = masked
 * 1 = unmasked
 */
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_POS 0
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_SIZE 8
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_DECL (7:0)

/*
 * Interrupt Mask Write Enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_WE_POS 8
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_WE_SIZE 8
#define IAXXX_HDMAC_CMN_MASKDSTTRAN_INT_MASK_WE_DECL (15:8)

/*** HDMAC_CMN_MASKERR (0x40080330) ***/
/*
 * The contents of the Raw Status registers are masked with the contents of
 * the Mask registers-MaskErr. Each Interrupt Mask register has a bit
 * allocated per channel
 * When the source peripheral of DMA channel i is memory, then the source
 * transaction complete interrupt, MaskSrcTran[i], must be masked to prevent
 * an erroneous triggering of an interrupt on the int_combined signal.
 * Similarly, when the destination peripheral of DMA channel i is memory,
 * then the destination transaction complete interrupt, MaskDstTran[i], must
 * be masked to prevent an erroneous triggering of an interrupt on the
 * int_combined(_n) signal.
 * A channel INT_MASK bit will be written only if the corresponding mask
 * write enable bit in the INT_MASK_WE field is asserted on the same AHB
 * write transfer. This allows software to set a mask bit without performing
 * a read-modified write operation. For example, writing hex 01x1 to the
 * MaskTfr register writes a 1 into MaskTfr[0], while MaskTfr[(7:1)] remains
 * unchanged. Writing hex 00xx leaves MaskTfr[(7:0)] unchanged.
 * Writing a 1 to any bit in these registers unmasks the corresponding
 * interrupt, thus allowing the DW_ahb_dmac to set the appropriate bit in the
 * Status registers and int_* port signals.
 */
#define IAXXX_HDMAC_CMN_MASKERR_ADDR (0x40080330)
#define IAXXX_HDMAC_CMN_MASKERR_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKERR_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_MASKERR_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_MASKERR_RESET_VAL 0x00000000

/*
 * Interrupt Mask
 * 0 = masked
 * 1 = unmasked
 */
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_POS 0
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_SIZE 8
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_DECL (7:0)

/*
 * Interrupt Mask Write Enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_WE_POS 8
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_WE_SIZE 8
#define IAXXX_HDMAC_CMN_MASKERR_INT_MASK_WE_DECL (15:8)

/*** HDMAC_CMN_CLEARTFR (0x40080338) ***/
/*
 * Each bit in the Raw Status and Status registers is cleared on the same
 * cycle by writing a 1 to the corresponding location in the Clear registers-
 * ClearTfr. Each Interrupt Clear register has a bit allocated per channel.
 * Writing a 0 has no effect. These registers are not readable.
 */
#define IAXXX_HDMAC_CMN_CLEARTFR_ADDR (0x40080338)
#define IAXXX_HDMAC_CMN_CLEARTFR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARTFR_RMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_CLEARTFR_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARTFR_RESET_VAL 0x00000000

/*
 * Interrupt clear.
 * 0 = no effect
 * 1 = clear interrupt
 */
#define IAXXX_HDMAC_CMN_CLEARTFR_CLEAR_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARTFR_CLEAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CLEARTFR_CLEAR_POS 0
#define IAXXX_HDMAC_CMN_CLEARTFR_CLEAR_SIZE 8
#define IAXXX_HDMAC_CMN_CLEARTFR_CLEAR_DECL (7:0)

/*** HDMAC_CMN_CLEARBLOCK (0x40080340) ***/
/*
 * Each bit in the Raw Status and Status registers is cleared on the same
 * cycle by writing a 1 to the corresponding location in the Clear registers-
 * ClearBlock. Each Interrupt Clear register has a bit allocated per channel.
 * Writing a 0 has no effect. These registers are not readable.
 */
#define IAXXX_HDMAC_CMN_CLEARBLOCK_ADDR (0x40080340)
#define IAXXX_HDMAC_CMN_CLEARBLOCK_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARBLOCK_RMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_CLEARBLOCK_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARBLOCK_RESET_VAL 0x00000000

/*
 * Interrupt clear.
 * 0 = no effect
 * 1 = clear interrupt
 */
#define IAXXX_HDMAC_CMN_CLEARBLOCK_CLEAR_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARBLOCK_CLEAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CLEARBLOCK_CLEAR_POS 0
#define IAXXX_HDMAC_CMN_CLEARBLOCK_CLEAR_SIZE 8
#define IAXXX_HDMAC_CMN_CLEARBLOCK_CLEAR_DECL (7:0)

/*** HDMAC_CMN_CLEARSRCTRAN (0x40080348) ***/
/*
 * Each bit in the Raw Status and Status registers is cleared on the same
 * cycle by writing a 1 to the corresponding location in the Clear registers-
 * ClearSrcTran. Each Interrupt Clear register has a bit allocated per
 * channel. Writing a 0 has no effect. These registers are not readable.
 */
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_ADDR (0x40080348)
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_RMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_RESET_VAL 0x00000000

/*
 * Interrupt clear.
 * 0 = no effect
 * 1 = clear interrupt
 */
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_CLEAR_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_CLEAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_CLEAR_POS 0
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_CLEAR_SIZE 8
#define IAXXX_HDMAC_CMN_CLEARSRCTRAN_CLEAR_DECL (7:0)

/*** HDMAC_CMN_CLEARDSTTRAN (0x40080350) ***/
/*
 * Each bit in the Raw Status and Status registers is cleared on the same
 * cycle by writing a 1 to the corresponding location in the Clear registers-
 * ClearDstTran. Each Interrupt Clear register has a bit allocated per
 * channel. Writing a 0 has no effect. These registers are not readable.
 */
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_ADDR (0x40080350)
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_RMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_RESET_VAL 0x00000000

/*
 * Interrupt clear.
 * 0 = no effect
 * 1 = clear interrupt
 */
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_CLEAR_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_CLEAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_CLEAR_POS 0
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_CLEAR_SIZE 8
#define IAXXX_HDMAC_CMN_CLEARDSTTRAN_CLEAR_DECL (7:0)

/*** HDMAC_CMN_CLEARERR (0x40080358) ***/
/*
 * Each bit in the Raw Status and Status registers is cleared on the same
 * cycle by writing a 1 to the corresponding location in the Clear registers-
 * ClearErr. Each Interrupt Clear register has a bit allocated per channel.
 * Writing a 0 has no effect. These registers are not readable.
 */
#define IAXXX_HDMAC_CMN_CLEARERR_ADDR (0x40080358)
#define IAXXX_HDMAC_CMN_CLEARERR_MASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARERR_RMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_CLEARERR_WMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARERR_RESET_VAL 0x00000000

/*
 * Interrupt clear.
 * 0 = no effect
 * 1 = clear interrupt
 */
#define IAXXX_HDMAC_CMN_CLEARERR_CLEAR_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CLEARERR_CLEAR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CLEARERR_CLEAR_POS 0
#define IAXXX_HDMAC_CMN_CLEARERR_CLEAR_SIZE 8
#define IAXXX_HDMAC_CMN_CLEARERR_CLEAR_DECL (7:0)

/*** HDMAC_CMN_STATUSINT (0x40080360) ***/
/*
 * The contents of each of the five Status registers - StatusTfr,
 * StatusBlock, StatusSrcTran, StatusDstTran, StatusErr - is ORed to produce
 * a single bit for each interrupt type in the Combined Status register
 * (StatusInt). This register is read-only.
 */
#define IAXXX_HDMAC_CMN_STATUSINT_ADDR (0x40080360)
#define IAXXX_HDMAC_CMN_STATUSINT_MASK_VAL 0x0000001f
#define IAXXX_HDMAC_CMN_STATUSINT_RMASK_VAL 0x0000001f
#define IAXXX_HDMAC_CMN_STATUSINT_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_STATUSINT_RESET_VAL 0x00000000

/*
 * OR of the contents of StatusTfr register
 */
#define IAXXX_HDMAC_CMN_STATUSINT_TFR_MASK 0x00000001
#define IAXXX_HDMAC_CMN_STATUSINT_TFR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSINT_TFR_POS 0
#define IAXXX_HDMAC_CMN_STATUSINT_TFR_SIZE 1
#define IAXXX_HDMAC_CMN_STATUSINT_TFR_DECL 0

/*
 * OR of the contents of StatusBlock register
 */
#define IAXXX_HDMAC_CMN_STATUSINT_BLOCK_MASK 0x00000002
#define IAXXX_HDMAC_CMN_STATUSINT_BLOCK_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSINT_BLOCK_POS 1
#define IAXXX_HDMAC_CMN_STATUSINT_BLOCK_SIZE 1
#define IAXXX_HDMAC_CMN_STATUSINT_BLOCK_DECL 1

/*
 * OR of the contents of StatusSrcTran register
 */
#define IAXXX_HDMAC_CMN_STATUSINT_SRCT_MASK 0x00000004
#define IAXXX_HDMAC_CMN_STATUSINT_SRCT_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSINT_SRCT_POS 2
#define IAXXX_HDMAC_CMN_STATUSINT_SRCT_SIZE 1
#define IAXXX_HDMAC_CMN_STATUSINT_SRCT_DECL 2

/*
 * OR of the contents of StatusDst register
 */
#define IAXXX_HDMAC_CMN_STATUSINT_DSTT_MASK 0x00000008
#define IAXXX_HDMAC_CMN_STATUSINT_DSTT_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSINT_DSTT_POS 3
#define IAXXX_HDMAC_CMN_STATUSINT_DSTT_SIZE 1
#define IAXXX_HDMAC_CMN_STATUSINT_DSTT_DECL 3

/*
 * OR of the contents of StatusErr register
 */
#define IAXXX_HDMAC_CMN_STATUSINT_ERR_MASK 0x00000010
#define IAXXX_HDMAC_CMN_STATUSINT_ERR_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_STATUSINT_ERR_POS 4
#define IAXXX_HDMAC_CMN_STATUSINT_ERR_SIZE 1
#define IAXXX_HDMAC_CMN_STATUSINT_ERR_DECL 4

/*** HDMAC_CMN_REQSRCREG (0x40080368) ***/
/*
 * A bit is assigned for each channel in this register. ReqSrcReg[n] is
 * ignored when software handshaking is not enabled for the source of channel
 * n.
 * A channel SRC_REQ bit is written only if the corresponding channel write
 * enable bit in the SRC_REQ_WE field is asserted on the same AHB write
 * transfer, and if the channel is enabled in the ChEnreg register. For
 * example, writing hex 0101 writes a 1 into ReqSrcReg[0], while
 * ReqSrcReg[(7:1)] remains unchanged. Writing hex 00xx leaves ReqSrcReg[(7:0)]
 * unchanged. This allows software to set a bit in the ReqSrcreg register
 * without performing a read-modified write operation.
 */
#define IAXXX_HDMAC_CMN_REQSRCREG_ADDR (0x40080368)
#define IAXXX_HDMAC_CMN_REQSRCREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_REQSRCREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_REQSRCREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_REQSRCREG_RESET_VAL 0x00000000

/*
 * Source request
 */
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_POS 0
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_SIZE 8
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_DECL (7:0)

/*
 * Source request write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_WE_POS 8
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_WE_SIZE 8
#define IAXXX_HDMAC_CMN_REQSRCREG_SRC_REQ_WE_DECL (15:8)

/*** HDMAC_CMN_REQDSTREG (0x40080370) ***/
/*
 * A bit is assigned for each channel in this register. ReqDstReg[n] is
 * ignored when software handshaking is not enabled for the source of channel
 * n.
 * A channel DST_REQ bit is written only if the corresponding channel write
 * enable bit in the DST_REQ_WE field is asserted on the same AHB write
 * transfer, and if the channel is enabled in the ChEnreg register.
 */
#define IAXXX_HDMAC_CMN_REQDSTREG_ADDR (0x40080370)
#define IAXXX_HDMAC_CMN_REQDSTREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_REQDSTREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_REQDSTREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_REQDSTREG_RESET_VAL 0x00000000

/*
 * Destination request
 */
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_POS 0
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_SIZE 8
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_DECL (7:0)

/*
 * Destination request write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_WE_POS 8
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_WE_SIZE 8
#define IAXXX_HDMAC_CMN_REQDSTREG_DST_REQ_WE_DECL (15:8)

/*** HDMAC_CMN_SGLREQSRCREG (0x40080378) ***/
/*
 * A bit is assigned for each channel in this register. SglReqSrcReg[n] is
 * ignored when software handshaking is not enabled for the source of channel
 * n.
 * A channel SRC_SGLREQ bit is written only if the corresponding channel
 * write enable bit in the SRC_SGLREQ_WE field is asserted on the same AHB
 * write transfer, and if the channel is enabled in the ChEnreg register.
 */
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_ADDR (0x40080378)
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_RESET_VAL 0x00000000

/*
 * Source single request
 */
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_POS 0
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_SIZE 8
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_DECL (7:0)

/*
 * Single write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_WE_POS 8
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_WE_SIZE 8
#define IAXXX_HDMAC_CMN_SGLREQSRCREG_SRC_SGLREQ_WE_DECL (15:8)

/*** HDMAC_CMN_SGLREQDSTREG (0x40080380) ***/
/*
 * A bit is assigned for each channel in this register. SglReqDstReg[n] is
 * ignored when software handshaking is not enabled for the destination of
 * channel n.
 * A channel DST_SGLREQ bit is written only if the corresponding channel
 * write enable bit in the DST_SGLREQ_WE field is asserted on the same AHB
 * write transfer, and if the channel is enabled in the ChEnreg register.
 */
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_ADDR (0x40080380)
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_RESET_VAL 0x00000000

/*
 * Destination single or burst request
 */
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_POS 0
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_SIZE 8
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_DECL (7:0)

/*
 * Destination write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_WE_POS 8
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_WE_SIZE 8
#define IAXXX_HDMAC_CMN_SGLREQDSTREG_DST_SGLREQ_WE_DECL (15:8)

/*** HDMAC_CMN_LSTSRCREG (0x40080388) ***/
/*
 * A bit is assigned for each channel in this register. LstSrcReg[n] is
 * ignored when software handshaking is not enabled for the source of channel
 * n, or when the source of channel n is not a flow controller.
 * A channel LSTSRC bit is written only if the corresponding channel write
 * enable bit in the LSTSRC_WE field is asserted on the same AHB write
 * transfer, and if the channel is enabled in the ChEnreg register.
 */
#define IAXXX_HDMAC_CMN_LSTSRCREG_ADDR (0x40080388)
#define IAXXX_HDMAC_CMN_LSTSRCREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_LSTSRCREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_LSTSRCREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_LSTSRCREG_RESET_VAL 0x00000000

/*
 * Source last transaction request
 * 0 = Not last transaction in current block
 * 1 = Last transaction in current block
 */
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_POS 0
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_SIZE 8
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_DECL (7:0)

/*
 * Source last transaction request write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_WE_POS 8
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_WE_SIZE 8
#define IAXXX_HDMAC_CMN_LSTSRCREG_LSTSRC_WE_DECL (15:8)

/*** HDMAC_CMN_LSTDSTREG (0x40080390) ***/
/*
 * A bit is assigned for each channel in this register. LstDstReg[n] is
 * ignored when software handshaking is not enabled for the destination of
 * channel n or when the destination of channel n is not a flow controller.
 * A channel LSTDST bit is written only if the corresponding channel write
 * enable bit in the LSTDST_WE field is asserted on the same AHB write
 * transfer, and if the channel is enabled in the ChEnreg register.
 */
#define IAXXX_HDMAC_CMN_LSTDSTREG_ADDR (0x40080390)
#define IAXXX_HDMAC_CMN_LSTDSTREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_LSTDSTREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_LSTDSTREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_LSTDSTREG_RESET_VAL 0x00000000

/*
 * Destination last transaction request
 * 0 = Not last transaction in current block
 * 1 = Last transaction in current block
 */
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_POS 0
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_SIZE 8
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_DECL (7:0)

/*
 * Destination last transaction request write enable
 * 0 = write disabled
 * 1 = write enabled
 */
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_WE_POS 8
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_WE_SIZE 8
#define IAXXX_HDMAC_CMN_LSTDSTREG_LSTDST_WE_DECL (15:8)

/*** HDMAC_CMN_DMACFGREG (0x40080398) ***/
/*
 * This register is used to enable the DW_ahb_dmac, which must be done before
 * any channel activity can begin.
 */
#define IAXXX_HDMAC_CMN_DMACFGREG_ADDR (0x40080398)
#define IAXXX_HDMAC_CMN_DMACFGREG_MASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMACFGREG_RMASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMACFGREG_WMASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMACFGREG_RESET_VAL 0x00000000

/*
 * DW_ahb_dmac Enable bit.
 * 0 = DW_ahb_dmac Disabled
 * 1 = DW_ahb_dmac Enabled
 */
#define IAXXX_HDMAC_CMN_DMACFGREG_DMA_EN_MASK 0x00000001
#define IAXXX_HDMAC_CMN_DMACFGREG_DMA_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_DMACFGREG_DMA_EN_POS 0
#define IAXXX_HDMAC_CMN_DMACFGREG_DMA_EN_SIZE 1
#define IAXXX_HDMAC_CMN_DMACFGREG_DMA_EN_DECL 0

/*** HDMAC_CMN_CHENREG (0x400803a0) ***/
/*
 * This is the DW_ahb_dmac Channel Enable Register. If software needs to set
 * up a new channel, then it can read this register in order to find out
 * which channels are currently inactive; it can then enable an inactive
 * channel with the required priority.
 */
#define IAXXX_HDMAC_CMN_CHENREG_ADDR (0x400803a0)
#define IAXXX_HDMAC_CMN_CHENREG_MASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_CHENREG_RMASK_VAL 0x000000ff
#define IAXXX_HDMAC_CMN_CHENREG_WMASK_VAL 0x0000ffff
#define IAXXX_HDMAC_CMN_CHENREG_RESET_VAL 0x00000000

/*
 * Enables/Disables the channel. Setting this bit enables a channel; clearing
 * this bit disables the channel.
 * 0 = Disable the Channel
 * 1 = Enable the Channel
 * The ChEnReg.CH_EN bit is automatically cleared by hardware to disable the
 * channel after the last AMBA transfer of the DMA transfer to the
 * destination has completed. Software can therefore poll this bit to
 * determine when this channel is free for a new DMA transfer.
 */
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_MASK 0x000000ff
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_POS 0
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_SIZE 8
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_DECL (7:0)

/*
 * Channel enable write enable.
 */
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_WE_MASK 0x0000ff00
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_WE_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_WE_POS 8
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_WE_SIZE 8
#define IAXXX_HDMAC_CMN_CHENREG_CH_EN_WE_DECL (15:8)

/*** HDMAC_CMN_DMAIDREG (0x400803a8) ***/
/*
 * This is the DW_ahb_dmac ID register, which is a read-only register that
 * reads back the coreConsultantconfigured hardcoded ID number, DMAH_ID_NUM.
 */
#define IAXXX_HDMAC_CMN_DMAIDREG_ADDR (0x400803a8)
#define IAXXX_HDMAC_CMN_DMAIDREG_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_CMN_DMAIDREG_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_CMN_DMAIDREG_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_CMN_DMAIDREG_RESET_VAL 0x00000000

/*
 * Hardcoded DW_ahb_dmac Peripheral ID
 */
#define IAXXX_HDMAC_CMN_DMAIDREG_DMA_ID_MASK 0xffffffff
#define IAXXX_HDMAC_CMN_DMAIDREG_DMA_ID_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_DMAIDREG_DMA_ID_POS 0
#define IAXXX_HDMAC_CMN_DMAIDREG_DMA_ID_SIZE 32
#define IAXXX_HDMAC_CMN_DMAIDREG_DMA_ID_DECL (31:0)

/*** HDMAC_CMN_DMATESTREG (0x400803b0) ***/
/*
 * This register is used to put the AHB slave interface into test mode,
 * during which the readback value of the writable registers match the value
 * written, assuming the DW_ahb_dmac configuration has not optimized the same
 * registers. In normal operation, the readback value of some registers is a
 * function of the DW_ahb_dmac state and does not match the value written.
 */
#define IAXXX_HDMAC_CMN_DMATESTREG_ADDR (0x400803b0)
#define IAXXX_HDMAC_CMN_DMATESTREG_MASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMATESTREG_RMASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMATESTREG_WMASK_VAL 0x00000001
#define IAXXX_HDMAC_CMN_DMATESTREG_RESET_VAL 0x00000000

/*
 * Puts the AHB slave interface into test mode. In this mode, the readback
 * value of the writable registers always matches the value written. This bit
 * does not allow writing to read-only registers.
 * 0 = Normal mode
 * 1 = Test mode
 */
#define IAXXX_HDMAC_CMN_DMATESTREG_TEST_SLV_IF_MASK 0x00000001
#define IAXXX_HDMAC_CMN_DMATESTREG_TEST_SLV_IF_RESET_VAL 0x0
#define IAXXX_HDMAC_CMN_DMATESTREG_TEST_SLV_IF_POS 0
#define IAXXX_HDMAC_CMN_DMATESTREG_TEST_SLV_IF_SIZE 1
#define IAXXX_HDMAC_CMN_DMATESTREG_TEST_SLV_IF_DECL 0

/*** HDMAC_DMA_COMP_PARAMS_CH7 (0x400803cc) ***/
/*
 * Component parameter settings for channel  CH7.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_ADDR (0x400803cc)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH7_CH7_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH6 (0x400803d0) ***/
/*
 * Component parameter settings for channel  CH6.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_ADDR (0x400803d0)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH6_CH6_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH5 (0x400803d4) ***/
/*
 * Component parameter settings for channel  CH5.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_ADDR (0x400803d4)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH5_CH5_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH4 (0x400803d8) ***/
/*
 * Component parameter settings for channel  CH4.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_ADDR (0x400803d8)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH4_CH4_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH3 (0x400803dc) ***/
/*
 * Component parameter settings for channel  CH3.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_ADDR (0x400803dc)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH3_CH3_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH2 (0x400803e0) ***/
/*
 * Component parameter settings for channel  CH2.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_ADDR (0x400803e0)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH2_CH2_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH1 (0x400803e4) ***/
/*
 * Component parameter settings for channel  CH1.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_ADDR (0x400803e4)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH1_CH1_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_CH0 (0x400803e8) ***/
/*
 * Component parameter settings for channel  CH0.
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_ADDR (0x400803e8)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_MASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_RMASK_VAL 0x7fffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_RESET_VAL 0x1922dfc0

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DTW_MASK 0x00000007
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DTW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DTW_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DTW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DTW_DECL (2:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STW_MASK 0x00000038
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STW_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STW_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STW_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STW_DECL (5:3)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_DST_MASK 0x00000040
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_DST_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_DST_POS 6
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_DST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_DST_DECL 6

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_SRC_MASK 0x00000080
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_SRC_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_SRC_POS 7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_SRC_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_STAT_SRC_DECL 7

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DST_SCA_EN_MASK 0x00000100
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DST_SCA_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DST_SCA_EN_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DST_SCA_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DST_SCA_EN_DECL 8

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SRC_GAT_EN_MASK 0x00000200
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SRC_GAT_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SRC_GAT_EN_POS 9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SRC_GAT_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SRC_GAT_EN_DECL 9

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LOCK_EN_MASK 0x00000400
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LOCK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LOCK_EN_POS 10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LOCK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LOCK_EN_DECL 10

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MULTI_BLK_EN_MASK 0x00000800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MULTI_BLK_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MULTI_BLK_EN_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MULTI_BLK_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MULTI_BLK_EN_DECL 11

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_CTL_WB_EN_MASK 0x00001000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_CTL_WB_EN_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_CTL_WB_EN_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_CTL_WB_EN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_CTL_WB_EN_DECL 12

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_HC_LLP_MASK 0x00002000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_HC_LLP_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_HC_LLP_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_HC_LLP_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_HC_LLP_DECL 13

/*
 *  0x0 = DMA
 *  0x1 = SRC
 *  0x2 = DST
 *  0x3 = ANY
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FC_MASK 0x0000c000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FC_RESET_VAL 0x3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FC_POS 14
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FC_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FC_DECL (15:14)

/*
 *  0x0 = 4
 *  0x1 = 8
 *  0x2 = 16
 *  0x3 = 32
 *  0x4 = 64
 *  0x5 = 128
 *  0x6 = 256
 *  0x7 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MAX_MULT_SIZE_MASK 0x00070000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MAX_MULT_SIZE_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MAX_MULT_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MAX_MULT_SIZE_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_MAX_MULT_SIZE_DECL (18:16)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DMS_MASK 0x00380000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DMS_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_DMS_DECL (21:19)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LMS_MASK 0x01c00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LMS_POS 22
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_LMS_DECL (24:22)

/*
 *  0x0 = MASTER1
 *  0x1 = MASTER2
 *  0x2 = MASTER3
 *  0x3 = MASTER4
 *  0x4 = NO_HARDCODE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SMS_MASK 0x0e000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SMS_RESET_VAL 0x4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SMS_POS 25
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SMS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_SMS_DECL (27:25)

/*
 *  0x0 = 8
 *  0x1 = 16
 *  0x2 = 32
 *  0x3 = 64
 *  0x4 = 128
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FIFO_DEPTH_MASK 0x70000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FIFO_DEPTH_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FIFO_DEPTH_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FIFO_DEPTH_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_CH0_CH0_FIFO_DEPTH_DECL (30:28)

/*** HDMAC_DMA_COMP_PARAMS_2 (0x400803ec) ***/
/*
 * Multi block type parameter for channel 0 to 7
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_ADDR (0x400803ec)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_RESET_VAL 0x00000000

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH0_MULTI_BLK_TYPE_MASK 0x0000000f
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH0_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH0_MULTI_BLK_TYPE_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH0_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH0_MULTI_BLK_TYPE_DECL (3:0)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH1_MULTI_BLK_TYPE_MASK 0x000000f0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH1_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH1_MULTI_BLK_TYPE_POS 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH1_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH1_MULTI_BLK_TYPE_DECL (7:4)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH2_MULTI_BLK_TYPE_MASK 0x00000f00
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH2_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH2_MULTI_BLK_TYPE_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH2_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH2_MULTI_BLK_TYPE_DECL (11:8)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH3_MULTI_BLK_TYPE_MASK 0x0000f000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH3_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH3_MULTI_BLK_TYPE_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH3_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH3_MULTI_BLK_TYPE_DECL (15:12)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH4_MULTI_BLK_TYPE_MASK 0x000f0000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH4_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH4_MULTI_BLK_TYPE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH4_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH4_MULTI_BLK_TYPE_DECL (19:16)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH5_MULTI_BLK_TYPE_MASK 0x00f00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH5_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH5_MULTI_BLK_TYPE_POS 20
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH5_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH5_MULTI_BLK_TYPE_DECL (23:20)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH6_MULTI_BLK_TYPE_MASK 0x0f000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH6_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH6_MULTI_BLK_TYPE_POS 24
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH6_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH6_MULTI_BLK_TYPE_DECL (27:24)

/*
 *  0x0 = NO_HARDCODE
 *  0x1 = CONT_RELOAD
 *  0x2 = RELOAD_CONT
 *  0x3 = RELOAD_RELOAD
 *  0x4 = CONT_LLP
 *  0x5 = RELOAD_LLP
 *  0x6 = LLP_CONT
 *  0x7 = LLP_RELOAD
 *  0x8 = LLP_LLP
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH7_MULTI_BLK_TYPE_MASK 0xf0000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH7_MULTI_BLK_TYPE_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH7_MULTI_BLK_TYPE_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH7_MULTI_BLK_TYPE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_2_CH7_MULTI_BLK_TYPE_DECL (31:28)

/*** HDMAC_DMA_COMP_PARAMS_1_LO (0x400803f0) ***/
/*
 * Max block type parameter for channel 0 to 7
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_ADDR (0x400803f0)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_RESET_VAL 0x99999999

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH0_MAX_BLK_SIZE_MASK 0x0000000f
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH0_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH0_MAX_BLK_SIZE_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH0_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH0_MAX_BLK_SIZE_DECL (3:0)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH1_MAX_BLK_SIZE_MASK 0x000000f0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH1_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH1_MAX_BLK_SIZE_POS 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH1_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH1_MAX_BLK_SIZE_DECL (7:4)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH2_MAX_BLK_SIZE_MASK 0x00000f00
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH2_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH2_MAX_BLK_SIZE_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH2_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH2_MAX_BLK_SIZE_DECL (11:8)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH3_MAX_BLK_SIZE_MASK 0x0000f000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH3_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH3_MAX_BLK_SIZE_POS 12
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH3_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH3_MAX_BLK_SIZE_DECL (15:12)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH4_MAX_BLK_SIZE_MASK 0x000f0000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH4_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH4_MAX_BLK_SIZE_POS 16
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH4_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH4_MAX_BLK_SIZE_DECL (19:16)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH5_MAX_BLK_SIZE_MASK 0x00f00000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH5_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH5_MAX_BLK_SIZE_POS 20
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH5_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH5_MAX_BLK_SIZE_DECL (23:20)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH6_MAX_BLK_SIZE_MASK 0x0f000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH6_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH6_MAX_BLK_SIZE_POS 24
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH6_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH6_MAX_BLK_SIZE_DECL (27:24)

/*
 *  0x0 = 3
 *  0x1 = 7
 *  0x2 = 15
 *  0x3 = 31
 *  0x4 = 63
 *  0x5 = 127
 *  0x6 = 255
 *  0x7 = 511
 *  0x8 = 1023
 *  0x9 = 2047
 *  0xa = 4095
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH7_MAX_BLK_SIZE_MASK 0xf0000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH7_MAX_BLK_SIZE_RESET_VAL 0x9
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH7_MAX_BLK_SIZE_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH7_MAX_BLK_SIZE_SIZE 4
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_LO_CH7_MAX_BLK_SIZE_DECL (31:28)

/*** HDMAC_DMA_COMP_PARAMS_1_HI (0x400803f4) ***/
/*
 * Miscellaneous top level parameters
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDR (0x400803f4)
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MASK_VAL 0x3fffff0f
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_RMASK_VAL 0x3fffff0f
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_RESET_VAL 0x38000f04

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_BIG_ENDIAN_MASK 0x00000001
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_BIG_ENDIAN_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_BIG_ENDIAN_POS 0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_BIG_ENDIAN_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_BIG_ENDIAN_DECL 0

/*
 *  0x0 = ALL
 *  0x1 = TYPE
 *  0x2 = COMBINED
 *  0x3 = reserved
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_INTR_IO_MASK 0x00000006
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_INTR_IO_RESET_VAL 0x2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_INTR_IO_POS 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_INTR_IO_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_INTR_IO_DECL (2:1)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MABRST_MASK 0x00000008
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MABRST_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MABRST_POS 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MABRST_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_MABRST_DECL 3

/*
 *  0x0 = 1 to 0x7 = 8
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_CHANNELS_MASK 0x00000700
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_CHANNELS_RESET_VAL 0x7
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_CHANNELS_POS 8
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_CHANNELS_SIZE 3
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_CHANNELS_DECL (10:8)

/*
 *  0x0 = 1 to 0x3 = 4
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_MASTER_INT_MASK 0x00001800
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_MASTER_INT_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_MASTER_INT_POS 11
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_MASTER_INT_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_MASTER_INT_DECL (12:11)

/*
 *  0x0 = 32bits
 *  0x1 = 64bits
 *  0x2=128bits
 *  0x3=256bits
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_S_HDATA_WIDTH_MASK 0x00006000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_S_HDATA_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_S_HDATA_WIDTH_POS 13
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_S_HDATA_WIDTH_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_S_HDATA_WIDTH_DECL (14:13)

/*
 *  0x0 = 32bits
 *  0x1 = 64bits
 *  0x2=128bits
 *  0x3=256bits
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M4_HDATA_WIDTH_MASK 0x00018000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M4_HDATA_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M4_HDATA_WIDTH_POS 15
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M4_HDATA_WIDTH_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M4_HDATA_WIDTH_DECL (16:15)

/*
 *  0x0 = 32bits
 *  0x1 = 64bits
 *  0x2=128bits
 *  0x3=256bits
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M3_HDATA_WIDTH_MASK 0x00060000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M3_HDATA_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M3_HDATA_WIDTH_POS 17
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M3_HDATA_WIDTH_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M3_HDATA_WIDTH_DECL (18:17)

/*
 *  0x0 = 32bits
 *  0x1 = 64bits
 *  0x2=128bits
 *  0x3=256bits
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M2_HDATA_WIDTH_MASK 0x00180000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M2_HDATA_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M2_HDATA_WIDTH_POS 19
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M2_HDATA_WIDTH_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M2_HDATA_WIDTH_DECL (20:19)

/*
 *  0x0 = 32bits
 *  0x1 = 64bits
 *  0x2=128bits
 *  0x3=256bits
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M1_HDATA_WIDTH_MASK 0x00600000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M1_HDATA_WIDTH_RESET_VAL 0x0
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M1_HDATA_WIDTH_POS 21
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M1_HDATA_WIDTH_SIZE 2
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_M1_HDATA_WIDTH_DECL (22:21)

/*
 *  0x00=0 to 0x10=16
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_HS_INT_MASK 0x0f800000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_HS_INT_RESET_VAL 0x10
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_HS_INT_POS 23
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_HS_INT_SIZE 5
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_NUM_HS_INT_DECL (27:23)

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDED_ENCODED_PARAMS_MASK 0x10000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDED_ENCODED_PARAMS_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDED_ENCODED_PARAMS_POS 28
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDED_ENCODED_PARAMS_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_ADDED_ENCODED_PARAMS_DECL 28

/*
 *  0x0 = FALSE
 *  0x1 = TRUE
 */
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_STATIC_ENDIAN_SELECT_MASK 0x20000000
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_STATIC_ENDIAN_SELECT_RESET_VAL 0x1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_STATIC_ENDIAN_SELECT_POS 29
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_STATIC_ENDIAN_SELECT_SIZE 1
#define IAXXX_HDMAC_DMA_COMP_PARAMS_1_HI_STATIC_ENDIAN_SELECT_DECL 29

/*** HDMAC_DMA_COMP_TYPE (0x400803f8) ***/
/*
 */
#define IAXXX_HDMAC_DMA_COMP_TYPE_ADDR (0x400803f8)
#define IAXXX_HDMAC_DMA_COMP_TYPE_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_TYPE_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_TYPE_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_TYPE_RESET_VAL 0x44571110

/*
 *  Designware component type number. This assigned unique hex value is
 * constant and is dervied from the two ASCII letters DW followed by a 32 bit
 * unsigned number
 */
#define IAXXX_HDMAC_DMA_COMP_TYPE_COMP_TYPE_MASK 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_TYPE_COMP_TYPE_RESET_VAL 0x44571110
#define IAXXX_HDMAC_DMA_COMP_TYPE_COMP_TYPE_POS 0
#define IAXXX_HDMAC_DMA_COMP_TYPE_COMP_TYPE_SIZE 32
#define IAXXX_HDMAC_DMA_COMP_TYPE_COMP_TYPE_DECL (31:0)

/*** HDMAC_DMA_COMP_VERSION (0x400803fc) ***/
/*
 */
#define IAXXX_HDMAC_DMA_COMP_VERSION_ADDR (0x400803fc)
#define IAXXX_HDMAC_DMA_COMP_VERSION_MASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_VERSION_RMASK_VAL 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_VERSION_WMASK_VAL 0x00000000
#define IAXXX_HDMAC_DMA_COMP_VERSION_RESET_VAL 0x3232312a

/*
 *  Version of the component
 */
#define IAXXX_HDMAC_DMA_COMP_VERSION_VERSION_MASK 0xffffffff
#define IAXXX_HDMAC_DMA_COMP_VERSION_VERSION_RESET_VAL 0x3232312a
#define IAXXX_HDMAC_DMA_COMP_VERSION_VERSION_POS 0
#define IAXXX_HDMAC_DMA_COMP_VERSION_VERSION_SIZE 32
#define IAXXX_HDMAC_DMA_COMP_VERSION_VERSION_DECL (31:0)

/* Number of registers in the module */
#define IAXXX_HDMAC_REG_NUM 148

#endif /* __IAXXX_REGISTER_DEFS_HDMAC_H__*/
