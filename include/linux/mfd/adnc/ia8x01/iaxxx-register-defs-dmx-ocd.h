/*
 * iaxxx-register-defs-dmx-ocd.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_DMX_OCD_H__
#define __IAXXX_REGISTER_DEFS_DMX_OCD_H__

/*** The base address for this set of registers ***/
#define IAXXX_DMX_OCD_REGS_ADDR (0x50014000)

/*** DMX_OCD_OCDID (0x50014000) ***/
/*
 * IDCODE is a 32-bit TAP data register containing a constant value
 * identifying the device managed by this TAP.
 */
#define IAXXX_DMX_OCD_OCDID_ADDR (0x50014000)
#define IAXXX_DMX_OCD_OCDID_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_OCDID_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_OCDID_WMASK_VAL 0x00000000
#define IAXXX_DMX_OCD_OCDID_RESET_VAL 0x0d33aff0

/*
 * Same as register description
 */
#define IAXXX_DMX_OCD_OCDID_OCDID_MASK 0xffffffff
#define IAXXX_DMX_OCD_OCDID_OCDID_RESET_VAL 0xd33aff0
#define IAXXX_DMX_OCD_OCDID_OCDID_POS 0
#define IAXXX_DMX_OCD_OCDID_OCDID_SIZE 32
#define IAXXX_DMX_OCD_OCDID_OCDID_DECL (31:0)

/*** DMX_OCD_DCRCLR (0x50014008) ***/
/*
 * The DCR is used by OCD host debugger software to control and configure the
 * OCD.
 * It is also meant for functionality accessible by vectored debuggers (such
 * as XMON), via RER and WER (ERI). Some bits are only meaningfully
 * accessible by a debugger external to the core; for this reason and for
 * cleaner external debug control of a core, only some of the bits are
 * writable by the core using WER (over ERI).
 * DCR is accessible (and equally readable) at the address DCRCLR, for
 * clearing selected bits of the register. Bits written to DCRCLR as 1 are
 * cleared (made 0). Bits written to the address as 0 are left unchanged. In
 * other words, writing zero to the register address has no effect. This
 * scheme allows accessing individual bits without using a software
 * read-modify-write sequence, thus avoiding race conditions when multiple
 * masters access different DCR bits at the same time.
 */
#define IAXXX_DMX_OCD_DCRCLR_ADDR (0x50014008)
#define IAXXX_DMX_OCD_DCRCLR_MASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRCLR_RMASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRCLR_WMASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRCLR_RESET_VAL 0x00600000

/*
 * Write '1' to de-activate the OCD. OCD functionality disabled (Debug
 * exceptions won't stop the core).
 */
#define IAXXX_DMX_OCD_DCRCLR_ENABLEOCD_MASK 0x00000001
#define IAXXX_DMX_OCD_DCRCLR_ENABLEOCD_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_ENABLEOCD_POS 0
#define IAXXX_DMX_OCD_DCRCLR_ENABLEOCD_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_ENABLEOCD_DECL 0

/*
 * Write '1' to clear debug interrupt. Debug Interrupt breaks the core (same
 * as DSR.DebugPendHost).
 * This bit indicates whether a debug interrupt to the core is pending. It is
 * set by writing a 1. Writing a zero has no effect. It is automatically
 * cleared when the debug interrupt is taken (whether by stopping the core if
 * EnableOCD is set, or taking a debug exception if not). It can also be
 * cleared by writing a 1 to the DSR.DebugPendHost bit (which mirrors this
 * bit).
 */
#define IAXXX_DMX_OCD_DCRCLR_DEBUGINTERRUPT_MASK 0x00000002
#define IAXXX_DMX_OCD_DCRCLR_DEBUGINTERRUPT_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_DEBUGINTERRUPT_POS 1
#define IAXXX_DMX_OCD_DCRCLR_DEBUGINTERRUPT_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_DEBUGINTERRUPT_DECL 1

/*
 * Write '1' to clear this bit in DCR. When the bit in DCR is set, it allows
 * debug interrupts to supersese all conditions.
 * When - for the purposes of obtaining debug control over the processor - a
 * debug interrupt is asserted e.g. by asserting BreakIn, it is accorded the
 * highest priority. In some cases however (e.g., load from a
 * read-side-effect I/O device), it may have to wait for the pipeline to
 * complete the in-flight instruction so as to maintain functional
 * correctness of the system. If this bit is set, the pipeline is forced to
 * kill the instruction and take the debug interrupt, even if it means that
 * the state of the system becomes corrupted.
 */
#define IAXXX_DMX_OCD_DCRCLR_INTERRUPTALLCONDS_MASK 0x00000004
#define IAXXX_DMX_OCD_DCRCLR_INTERRUPTALLCONDS_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_INTERRUPTALLCONDS_POS 2
#define IAXXX_DMX_OCD_DCRCLR_INTERRUPTALLCONDS_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_INTERRUPTALLCONDS_DECL 2

/*
 * Enable BreakIn
 */
#define IAXXX_DMX_OCD_DCRCLR_BREAKINEN_MASK 0x00010000
#define IAXXX_DMX_OCD_DCRCLR_BREAKINEN_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_BREAKINEN_POS 16
#define IAXXX_DMX_OCD_DCRCLR_BREAKINEN_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_BREAKINEN_DECL 16

/*
 * Enable BreakIn
 */
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTEN_MASK 0x00020000
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTEN_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTEN_POS 17
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTEN_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTEN_DECL 17

/*
 * A software-set flag that indicates user-controlled debug mode By setting
 * the debug mode in this manner, debug operations (for example, from a
 * debugger running on an external host) would be permitted even if the core
 * has RunStall asserted. The bit is readable/writable by software running on
 * the Xtensa processor through the ERI (external register interface) or by
 * an external agent through JTAG or APB. Typically, the external agent would
 * be a debugger running on a host. For the RunStall signal to cause a
 * pipeline stall, this bit must be cleared. This bit is cleared when either
 * the Debug module or the core are reset. Setting this bit also causes the
 * Xtensa output XOCDMode to be asserted.
 */
#define IAXXX_DMX_OCD_DCRCLR_DEBUGSWACTIVE_MASK 0x00100000
#define IAXXX_DMX_OCD_DCRCLR_DEBUGSWACTIVE_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_DEBUGSWACTIVE_POS 20
#define IAXXX_DMX_OCD_DCRCLR_DEBUGSWACTIVE_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_DEBUGSWACTIVE_DECL 20

/*
 * Enable the RunStall input. If this bit is cleared, the pipeline will not
 * stall even if RunStall is asserted to the Xtensa processor.
 */
#define IAXXX_DMX_OCD_DCRCLR_RUNSTALLINEN_MASK 0x00200000
#define IAXXX_DMX_OCD_DCRCLR_RUNSTALLINEN_RESET_VAL 0x1
#define IAXXX_DMX_OCD_DCRCLR_RUNSTALLINEN_POS 21
#define IAXXX_DMX_OCD_DCRCLR_RUNSTALLINEN_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_RUNSTALLINEN_DECL 21

/*
 * Enable the XOCDMode output
 */
#define IAXXX_DMX_OCD_DCRCLR_DEBUGMODEOUTEN_MASK 0x00400000
#define IAXXX_DMX_OCD_DCRCLR_DEBUGMODEOUTEN_RESET_VAL 0x1
#define IAXXX_DMX_OCD_DCRCLR_DEBUGMODEOUTEN_POS 22
#define IAXXX_DMX_OCD_DCRCLR_DEBUGMODEOUTEN_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_DEBUGMODEOUTEN_DECL 22

/*
 * When the CoreSight ITCTRL register is set, this bit controls the state of
 * the BreakOut signal. Otherwise, this bit has no effect. It is used for
 * break in/out network topology detection in the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTITO_MASK 0x01000000
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTITO_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTITO_POS 24
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTITO_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_BREAKOUTITO_DECL 24

/*
 * BreakInAck topology detection control bit.
 * When the CoreSight ITCTRL register is set, this bit controls the state of
 * the BreakInAck signal. Otherwise, this bit has no effect. It is used for
 * break in/out network topology detection in the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DCRCLR_BREAKINACKITO_MASK 0x02000000
#define IAXXX_DMX_OCD_DCRCLR_BREAKINACKITO_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRCLR_BREAKINACKITO_POS 25
#define IAXXX_DMX_OCD_DCRCLR_BREAKINACKITO_SIZE 1
#define IAXXX_DMX_OCD_DCRCLR_BREAKINACKITO_DECL 25

/*** DMX_OCD_DCRSET (0x5001400c) ***/
/*
 * The DCR is used by OCD host debugger software to control and configure the
 * OCD.
 * It is also meant for functionality accessible by vectored debuggers (such
 * as XMON), via RER and WER (ERI). Some bits are only meaningfully
 * accessible by a debugger external to the core; for this reason and for
 * cleaner external debug control of a core, only some of the bits are
 * writable by the core using WER (over ERI).
 * DCRSET is accessible (and equally readable) at the address DCRSET, for
 * setting selected bits of the register. Bits written to DCRSET as 1 are set
 * (made 1). Bits written to the address as 0 are left unchanged. In other
 * words, writing zero to the register address has no effect. This scheme
 * allows accessing individual bits without using a software
 * read-modify-write sequence, thus avoiding race conditions when multiple
 * masters access different DCR bits at the same time.
 */
#define IAXXX_DMX_OCD_DCRSET_ADDR (0x5001400c)
#define IAXXX_DMX_OCD_DCRSET_MASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRSET_RMASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRSET_WMASK_VAL 0x03730007
#define IAXXX_DMX_OCD_DCRSET_RESET_VAL 0x00600000

/*
 * Set to activate the OCD. OCD functionality enabled (Debug exceptions stop
 * the core).
 */
#define IAXXX_DMX_OCD_DCRSET_ENABLEOCD_MASK 0x00000001
#define IAXXX_DMX_OCD_DCRSET_ENABLEOCD_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_ENABLEOCD_POS 0
#define IAXXX_DMX_OCD_DCRSET_ENABLEOCD_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_ENABLEOCD_DECL 0

/*
 * Set to stop the core (same as DSR.DebugPendHost).
 * This bit indicates whether a debug interrupt to the core is pending. It is
 * set by writing a 1. It is automatically cleared when the debug interrupt
 * is taken (whether by stopping the core if EnableOCD is set, or taking a
 * debug exception if not). It can also be cleared by writing a 1 to the
 * DSR.DebugPendHost bit (which mirrors this bit).
 */
#define IAXXX_DMX_OCD_DCRSET_DEBUGINTERRUPT_MASK 0x00000002
#define IAXXX_DMX_OCD_DCRSET_DEBUGINTERRUPT_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_DEBUGINTERRUPT_POS 1
#define IAXXX_DMX_OCD_DCRSET_DEBUGINTERRUPT_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_DEBUGINTERRUPT_DECL 1

/*
 * Write '1' to set this bit in DCR. When the bit in DCR is set, it allows
 * debug interrupts to supersese all conditions.
 * When - for the purposes of obtaining debug control over the processor - a
 * debug interrupt is asserted e.g. by asserting BreakIn, it is accorded the
 * highest priority. In some cases however (e.g., load from a
 * read-side-effect I/O device), it may have to wait for the pipeline to
 * complete the in-flight instruction so as to maintain functional
 * correctness of the system. If this bit is set, the pipeline is forced to
 * kill the instruction and take the debug interrupt, even if it means that
 * the state of the system becomes corrupted.
 */
#define IAXXX_DMX_OCD_DCRSET_INTERRUPTALLCONDS_MASK 0x00000004
#define IAXXX_DMX_OCD_DCRSET_INTERRUPTALLCONDS_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_INTERRUPTALLCONDS_POS 2
#define IAXXX_DMX_OCD_DCRSET_INTERRUPTALLCONDS_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_INTERRUPTALLCONDS_DECL 2

/*
 * Enable BreakIn
 */
#define IAXXX_DMX_OCD_DCRSET_BREAKINEN_MASK 0x00010000
#define IAXXX_DMX_OCD_DCRSET_BREAKINEN_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_BREAKINEN_POS 16
#define IAXXX_DMX_OCD_DCRSET_BREAKINEN_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_BREAKINEN_DECL 16

/*
 * Enable BreakIn
 */
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTEN_MASK 0x00020000
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTEN_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTEN_POS 17
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTEN_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTEN_DECL 17

/*
 * A software-set flag that indicates user-controlled debug mode By setting
 * the debug mode in this manner, debug operations (for example, from a
 * debugger running on an external host) would be permitted even if the core
 * has RunStall asserted. The bit is readable/writable by software running on
 * the Xtensa processor through the ERI (external register interface) or by
 * an external agent through JTAG or APB. Typically, the external agent would
 * be a debugger running on a host. For the RunStall signal to cause a
 * pipeline stall, this bit must be cleared. This bit is cleared when either
 * the Debug module or the core are reset. Setting this bit also causes the
 * Xtensa output XOCDMode to be asserted.
 */
#define IAXXX_DMX_OCD_DCRSET_DEBUGSWACTIVE_MASK 0x00100000
#define IAXXX_DMX_OCD_DCRSET_DEBUGSWACTIVE_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_DEBUGSWACTIVE_POS 20
#define IAXXX_DMX_OCD_DCRSET_DEBUGSWACTIVE_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_DEBUGSWACTIVE_DECL 20

/*
 * Enable the RunStall input. If this bit is cleared, the pipeline will not
 * stall even if RunStall is asserted to the Xtensa processor.
 */
#define IAXXX_DMX_OCD_DCRSET_RUNSTALLINEN_MASK 0x00200000
#define IAXXX_DMX_OCD_DCRSET_RUNSTALLINEN_RESET_VAL 0x1
#define IAXXX_DMX_OCD_DCRSET_RUNSTALLINEN_POS 21
#define IAXXX_DMX_OCD_DCRSET_RUNSTALLINEN_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_RUNSTALLINEN_DECL 21

/*
 * Enable the XOCDMode output
 */
#define IAXXX_DMX_OCD_DCRSET_DEBUGMODEOUTEN_MASK 0x00400000
#define IAXXX_DMX_OCD_DCRSET_DEBUGMODEOUTEN_RESET_VAL 0x1
#define IAXXX_DMX_OCD_DCRSET_DEBUGMODEOUTEN_POS 22
#define IAXXX_DMX_OCD_DCRSET_DEBUGMODEOUTEN_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_DEBUGMODEOUTEN_DECL 22

/*
 * When the CoreSight ITCTRL register is set, this bit controls the state of
 * the BreakOut signal. Otherwise, this bit has no effect. It is used for
 * break in/out network topology detection in the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTITO_MASK 0x01000000
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTITO_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTITO_POS 24
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTITO_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_BREAKOUTITO_DECL 24

/*
 * BreakInAck topology detection control bit.
 * When the CoreSight ITCTRL register is set, this bit controls the state of
 * the BreakInAck signal. Otherwise, this bit has no effect. It is used for
 * break in/out network topology detection in the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DCRSET_BREAKINACKITO_MASK 0x02000000
#define IAXXX_DMX_OCD_DCRSET_BREAKINACKITO_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DCRSET_BREAKINACKITO_POS 25
#define IAXXX_DMX_OCD_DCRSET_BREAKINACKITO_SIZE 1
#define IAXXX_DMX_OCD_DCRSET_BREAKINACKITO_DECL 25

/*** DMX_OCD_DSR (0x50014010) ***/
/*
 * The DSR register provides OCD status to host debugger.
 */
#define IAXXX_DMX_OCD_DSR_ADDR (0x50014010)
#define IAXXX_DMX_OCD_DSR_MASK_VAL 0x87f7cc1f
#define IAXXX_DMX_OCD_DSR_RMASK_VAL 0x87f7cc1f
#define IAXXX_DMX_OCD_DSR_WMASK_VAL 0x00f7cc0b
#define IAXXX_DMX_OCD_DSR_RESET_VAL 0x00000000

/*
 * Instruction in DIR completed execution (w/ or w/o exception)
 * Cleared by writing a 1 or by initiating DIR execution; set upon execution
 * completion (after successful DIR execution initiation, whether or not the
 * instruction completed successfully).
 */
#define IAXXX_DMX_OCD_DSR_EXECDONE_MASK 0x00000001
#define IAXXX_DMX_OCD_DSR_EXECDONE_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_EXECDONE_POS 0
#define IAXXX_DMX_OCD_DSR_EXECDONE_SIZE 1
#define IAXXX_DMX_OCD_DSR_EXECDONE_DECL 0

/*
 * A previous instruction in DIR completed with an exception. Set when such
 * an instruction takes an exception; cleared only by writing a 1 to this bit
 * or by entering Stopped state i.e.  Stopped bit becomes set (in particular,
 * initiating DIR execution does not clear this bit).
 */
#define IAXXX_DMX_OCD_DSR_EXECEXCEPTION_MASK 0x00000002
#define IAXXX_DMX_OCD_DSR_EXECEXCEPTION_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_EXECEXCEPTION_POS 1
#define IAXXX_DMX_OCD_DSR_EXECEXCEPTION_SIZE 1
#define IAXXX_DMX_OCD_DSR_EXECEXCEPTION_DECL 1

/*
 * Core is executing DIR (meaningful while Stopped is 1, else is undefined
 * and should be set to 0)
 */
#define IAXXX_DMX_OCD_DSR_EXECBUSY_MASK 0x00000004
#define IAXXX_DMX_OCD_DSR_EXECBUSY_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_EXECBUSY_POS 2
#define IAXXX_DMX_OCD_DSR_EXECBUSY_SIZE 1
#define IAXXX_DMX_OCD_DSR_EXECBUSY_DECL 2

/*
 * Set when DIR execution or any DIR write is attempted while a previous one
 * is still being executed, i.e. while ExecBusy is still set (it, and all
 * subsequent instruction execution attempts while this bit was still set,
 * are ignored). Cleared by writing a 1, or when core stops due to a debug
 * exception while OCD is enabled.
 * When ExecOverrun is set, any attempt to execute an instruction using DIR,
 * or to write DIR, is ignored (without any effect on ExecBusy, ExecDone,
 * ExecException or DIR).
 */
#define IAXXX_DMX_OCD_DSR_EXECOVERRUN_MASK 0x00000008
#define IAXXX_DMX_OCD_DSR_EXECOVERRUN_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_EXECOVERRUN_POS 3
#define IAXXX_DMX_OCD_DSR_EXECOVERRUN_SIZE 1
#define IAXXX_DMX_OCD_DSR_EXECOVERRUN_DECL 3

/*
 * Core is under OCD debug control, stopped or executing DIR (in either
 * Stopped or Stepping states).
 */
#define IAXXX_DMX_OCD_DSR_STOPPED_MASK 0x00000010
#define IAXXX_DMX_OCD_DSR_STOPPED_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_STOPPED_POS 4
#define IAXXX_DMX_OCD_DSR_STOPPED_SIZE 1
#define IAXXX_DMX_OCD_DSR_STOPPED_DECL 4

/*
 * Core wrote to DDR, i.e. executed WSR.DDR or XSR.DDR
 */
#define IAXXX_DMX_OCD_DSR_COREWROTEDDR_MASK 0x00000400
#define IAXXX_DMX_OCD_DSR_COREWROTEDDR_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_COREWROTEDDR_POS 10
#define IAXXX_DMX_OCD_DSR_COREWROTEDDR_SIZE 1
#define IAXXX_DMX_OCD_DSR_COREWROTEDDR_DECL 10

/*
 * Core read from DDR, i.e. executed RSR.DDR or XSR.DDR
 */
#define IAXXX_DMX_OCD_DSR_COREREADDDR_MASK 0x00000800
#define IAXXX_DMX_OCD_DSR_COREREADDDR_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_COREREADDDR_POS 11
#define IAXXX_DMX_OCD_DSR_COREREADDDR_SIZE 1
#define IAXXX_DMX_OCD_DSR_COREREADDDR_DECL 11

/*
 * Host wrote to DDR (via JTAG or APB) (includes DDREXEC). Set when DDR
 * written by external host (i.e. via JTAG or APB).
 */
#define IAXXX_DMX_OCD_DSR_HOSTWROTEDDR_MASK 0x00004000
#define IAXXX_DMX_OCD_DSR_HOSTWROTEDDR_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_HOSTWROTEDDR_POS 14
#define IAXXX_DMX_OCD_DSR_HOSTWROTEDDR_SIZE 1
#define IAXXX_DMX_OCD_DSR_HOSTWROTEDDR_DECL 14

/*
 * Host read from DDR (via JTAG or APB) (includes DDREXEC). Set when DDR read
 * by external host (i.e. via JTAG or APB).
 */
#define IAXXX_DMX_OCD_DSR_HOSTREADDDR_MASK 0x00008000
#define IAXXX_DMX_OCD_DSR_HOSTREADDDR_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_HOSTREADDDR_POS 15
#define IAXXX_DMX_OCD_DSR_HOSTREADDDR_SIZE 1
#define IAXXX_DMX_OCD_DSR_HOSTREADDDR_DECL 15

/*
 * This bit is 1 when BreakIn debug interrupt is pending. It is set when
 * BreakIn interrupt is latched. The bit is cleared either when the debug
 * interrupt is taken (whether or not the OCD is enabled) and indicated by
 * DEBUGCAUSE.DI, or by writing a 1 to this bit.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGPENDBREAK_MASK 0x00010000
#define IAXXX_DMX_OCD_DSR_DEBUGPENDBREAK_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGPENDBREAK_POS 16
#define IAXXX_DMX_OCD_DSR_DEBUGPENDBREAK_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGPENDBREAK_DECL 16

/*
 * Set when a debug interrupt is pending due to writing a 1 to
 * DCR.DebugInterrupt. Reading this bit reports the same value as
 * DCR.DebugInterrupt. Cleared either when the debug interrupt is taken
 * (whether or not DCR.EnableOCD is set) and indicated by DebugInterrupt.DI,
 * or by writing a 1 to this bit.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGPENDHOST_MASK 0x00020000
#define IAXXX_DMX_OCD_DSR_DEBUGPENDHOST_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGPENDHOST_POS 17
#define IAXXX_DMX_OCD_DSR_DEBUGPENDHOST_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGPENDHOST_DECL 17

/*
 * Set when a debug interrupt is pending due to TRAX processor trigger-out
 * (PTO). Cleared either when the debug interrupt is taken (whether or not
 * OCD is enabled) and indicated by DebugInterrupt.DI or by writing a 1 to
 * this bit.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGPENDTRAX_MASK 0x00040000
#define IAXXX_DMX_OCD_DSR_DEBUGPENDTRAX_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGPENDTRAX_POS 18
#define IAXXX_DMX_OCD_DSR_DEBUGPENDTRAX_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGPENDTRAX_DECL 18

/*
 * Set when a debug interrupt is taken due to BreakIn (at which point
 * DebugPendBreak gets cleared). Cleared by writing a 1 to this bit. If
 * DebugPendBreak is cleared just prior to the interrupt being taken (within
 * three cycles) DebugIntBreak will not be set.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGINTBREAK_MASK 0x00100000
#define IAXXX_DMX_OCD_DSR_DEBUGINTBREAK_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGINTBREAK_POS 20
#define IAXXX_DMX_OCD_DSR_DEBUGINTBREAK_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGINTBREAK_DECL 20

/*
 * Set when a debug interrupt is taken due to DCR.DebugInterrupt being set
 * (at which point DCR.DebugInterrupt and DCR.DebugPendHost get cleared).
 * Cleared by writing a 1 to this bit.  If DebugPendHost is cleared just
 * prior to the interrupt being taken (within three cycles) DebugIntHost will
 * not be set.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGINTHOST_MASK 0x00200000
#define IAXXX_DMX_OCD_DSR_DEBUGINTHOST_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGINTHOST_POS 21
#define IAXXX_DMX_OCD_DSR_DEBUGINTHOST_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGINTHOST_DECL 21

/*
 * Set when a debug interrupt is taken due to TRAX processor triggerout (PTO)
 * (at which point DCR.DebugPendTrax gets cleared).  Cleared by writing a 1
 * to this bit. If DebugPendTrax is cleared just prior to the interrupt being
 * taken (within three cycles) DebugIntTrax will not be set.
 */
#define IAXXX_DMX_OCD_DSR_DEBUGINTTRAX_MASK 0x00400000
#define IAXXX_DMX_OCD_DSR_DEBUGINTTRAX_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_DEBUGINTTRAX_POS 22
#define IAXXX_DMX_OCD_DSR_DEBUGINTTRAX_SIZE 1
#define IAXXX_DMX_OCD_DSR_DEBUGINTTRAX_DECL 22

/*
 * Set when RunStall input to Xtensa changes polarity
 */
#define IAXXX_DMX_OCD_DSR_RUNSTALLTOGGLE_MASK 0x00800000
#define IAXXX_DMX_OCD_DSR_RUNSTALLTOGGLE_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_RUNSTALLTOGGLE_POS 23
#define IAXXX_DMX_OCD_DSR_RUNSTALLTOGGLE_SIZE 1
#define IAXXX_DMX_OCD_DSR_RUNSTALLTOGGLE_DECL 23

/*
 * Provides the real-time value of the RunStall input to Xtensa
 */
#define IAXXX_DMX_OCD_DSR_RUNSTALLINPUTVALUE_MASK 0x01000000
#define IAXXX_DMX_OCD_DSR_RUNSTALLINPUTVALUE_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_RUNSTALLINPUTVALUE_POS 24
#define IAXXX_DMX_OCD_DSR_RUNSTALLINPUTVALUE_SIZE 1
#define IAXXX_DMX_OCD_DSR_RUNSTALLINPUTVALUE_DECL 24

/*
 * Reports the value of the BreakOutAck signal. Used for topology detection
 * in the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DSR_BREAKOUTACKITI_MASK 0x02000000
#define IAXXX_DMX_OCD_DSR_BREAKOUTACKITI_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_BREAKOUTACKITI_POS 25
#define IAXXX_DMX_OCD_DSR_BREAKOUTACKITI_SIZE 1
#define IAXXX_DMX_OCD_DSR_BREAKOUTACKITI_DECL 25

/*
 * Reports the value of the BreakIn signal. Used for topology detection in
 * the CoreSight environment.
 */
#define IAXXX_DMX_OCD_DSR_BREAKINITI_MASK 0x04000000
#define IAXXX_DMX_OCD_DSR_BREAKINITI_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_BREAKINITI_POS 26
#define IAXXX_DMX_OCD_DSR_BREAKINITI_SIZE 1
#define IAXXX_DMX_OCD_DSR_BREAKINITI_DECL 26

/*
 * Always 1. (Read as zero when the Debug Module is powered off.)
 */
#define IAXXX_DMX_OCD_DSR_ALWAYS_1_MASK 0x80000000
#define IAXXX_DMX_OCD_DSR_ALWAYS_1_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DSR_ALWAYS_1_POS 31
#define IAXXX_DMX_OCD_DSR_ALWAYS_1_SIZE 1
#define IAXXX_DMX_OCD_DSR_ALWAYS_1_DECL 31

/*** DMX_OCD_DDR (0x50014014) ***/
/*
 * The Debug Data Register (DDR) is a 32-bit data register that provides a
 * means of communication between the host software and the core, or between
 * the host software and the processor instructions it executes via DIR in
 * the Stepping state. A value written into DDR using the WSR instruction can
 * be subsequently read by host debug software over JTAG or APB. Conversely,
 * host software can write DDR using JTAG or APB, which can be subsequently
 * read by the core using the RSR Xtensa instruction.
 * DDR is not accessible over ERI. Instead, the core accesses DDR as a
 * special register.
 */
#define IAXXX_DMX_OCD_DDR_ADDR (0x50014014)
#define IAXXX_DMX_OCD_DDR_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDR_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDR_WMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDR_RESET_VAL 0x00000000

/*
 * 32-bit data field that provides a means of communication between the host
 * software and the core, or between the host software and the processor
 * instructions
 */
#define IAXXX_DMX_OCD_DDR_DDR_MASK 0xffffffff
#define IAXXX_DMX_OCD_DDR_DDR_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DDR_DDR_POS 0
#define IAXXX_DMX_OCD_DDR_DDR_SIZE 32
#define IAXXX_DMX_OCD_DDR_DDR_DECL (31:0)

/*** DMX_OCD_DDREXEC (0x50014018) ***/
/*
 * Alias to DDR, with added side-effect of executing the instruction already
 * in DIR. Typically used with instructions which write the DDR special
 * register.
 */
#define IAXXX_DMX_OCD_DDREXEC_ADDR (0x50014018)
#define IAXXX_DMX_OCD_DDREXEC_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDREXEC_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDREXEC_WMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DDREXEC_RESET_VAL 0x00000000

/*
 */
#define IAXXX_DMX_OCD_DDREXEC_DDREXEC_MASK 0xffffffff
#define IAXXX_DMX_OCD_DDREXEC_DDREXEC_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DDREXEC_DDREXEC_POS 0
#define IAXXX_DMX_OCD_DDREXEC_DDREXEC_SIZE 32
#define IAXXX_DMX_OCD_DDREXEC_DDREXEC_DECL (31:0)

/*** DMX_OCD_DIR0EXEC (0x5001401c) ***/
/*
 * DIR0EXEC is an alias to DIR0, with the added side-effect of executing the
 * instruction when written. To execute an instruction wider than 32 bits
 * this way, the relevant DIR1 to DIRn registers must be written before
 * writing to DIR0EXEC.
 * Reading DIR0EXEC is equivalent to reading DIR0 register (no side-effect).
 */
#define IAXXX_DMX_OCD_DIR0EXEC_ADDR (0x5001401c)
#define IAXXX_DMX_OCD_DIR0EXEC_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0EXEC_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0EXEC_WMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0EXEC_RESET_VAL 0x00000000

/*
 */
#define IAXXX_DMX_OCD_DIR0EXEC_DIR0EXEC_MASK 0xffffffff
#define IAXXX_DMX_OCD_DIR0EXEC_DIR0EXEC_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DIR0EXEC_DIR0EXEC_POS 0
#define IAXXX_DMX_OCD_DIR0EXEC_DIR0EXEC_SIZE 32
#define IAXXX_DMX_OCD_DIR0EXEC_DIR0EXEC_DECL (31:0)

/*** DMX_OCD_DIR0 (0x50014020) ***/
/*
 * The Debug Instruction Register (DIR) contains an Xtensa processor
 * instruction to execute under OCD control, rather than through the normal
 * processor fetch mechanism.
 * Execution is initiated in one of three ways:
 * 1) By writing an instruction to DIR register followed by writing data to
 * DDREXEC register
 * 2) By writing an instruction to DIR0EXEC register
 * 3) Reading from DDREXEC - this requests execution of the instruction
 * already contained in DIR
 */
#define IAXXX_DMX_OCD_DIR0_ADDR (0x50014020)
#define IAXXX_DMX_OCD_DIR0_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0_WMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR0_RESET_VAL 0x00000000

/*
 */
#define IAXXX_DMX_OCD_DIR0_DIR0_MASK 0xffffffff
#define IAXXX_DMX_OCD_DIR0_DIR0_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DIR0_DIR0_POS 0
#define IAXXX_DMX_OCD_DIR0_DIR0_SIZE 32
#define IAXXX_DMX_OCD_DIR0_DIR0_DECL (31:0)

/*** DMX_OCD_DIR1 (0x50014024) ***/
/*
 * The Debug Instruction Register (DIR) contains an Xtensa processor
 * instruction to execute under OCD control, rather than through the normal
 * processor fetch mechanism.
 * Execution is initiated in one of three ways:
 * 1) By writing an instruction to DIR register followed by writing data to
 * DDREXEC register
 * 2) By writing an instruction to DIR0EXEC register
 * 3) Reading from DDREXEC - this requests execution of the instruction
 * already contained in DIR
 */
#define IAXXX_DMX_OCD_DIR1_ADDR (0x50014024)
#define IAXXX_DMX_OCD_DIR1_MASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR1_RMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR1_WMASK_VAL 0xffffffff
#define IAXXX_DMX_OCD_DIR1_RESET_VAL 0x00000000

/*
 */
#define IAXXX_DMX_OCD_DIR1_DIR1_MASK 0xffffffff
#define IAXXX_DMX_OCD_DIR1_DIR1_RESET_VAL 0x0
#define IAXXX_DMX_OCD_DIR1_DIR1_POS 0
#define IAXXX_DMX_OCD_DIR1_DIR1_SIZE 32
#define IAXXX_DMX_OCD_DIR1_DIR1_DECL (31:0)

/* Number of registers in the module */
#define IAXXX_DMX_OCD_REG_NUM 9

#endif /* __IAXXX_REGISTER_DEFS_DMX_OCD_H__*/
