/*
 * iaxxx-register-defs-cnr7.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_CNR7_H__
#define __IAXXX_REGISTER_DEFS_CNR7_H__

/*** The base address for this set of registers ***/
#define IAXXX_CNR7_REGS_ADDR (0x40050000)

/*** CNR7_AFG_APB_CLK_HW_CG (0x40050000) ***/
/*
 * Clock gate for afg_apb_clk. Source clock is pd7_lpx_clk.<br><br>When EN =
 * 0, Clock will be cut regardless of Hardware Control and HW_OVRD
 * configuration<br>When EN = 1, Clock will be supplied based on the Hardware
 * Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1 or Modify EN Bit
 * unless suggested by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is
 * supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access AFG APB registers
 */
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_ADDR (0x40050000)
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_AFG_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_AFG_INTR_LPX_CLK_CG (0x40050004) ***/
/*
 * Clock will be always available when i2c_apb_lpx_clk is enabled. This clock
 * is sourced from pd7_ahb_lpx_clk.
 */
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_ADDR (0x40050004)
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_AFG_INTR_LPX_CLK_CG_EN_DECL 0

/*** CNR7_CNR7_APB_CLK_HW_CG (0x40050008) ***/
/*
 * Hardware Controlled enable for cnr7_apb_clk. This clock is sourced from
 * pd7_ahb_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if one of
 * these conditions are met : a) AHB masters access CNR7 APB registers b)
 * CNR7 APB ready error interrupt is set
 */
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_ADDR (0x40050008)
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_CNR7_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_I2C_APB_LPX_CLK_SC (0x4005000c) ***/
/*
 * i2c_apb_lpx_clk is sourced from pd7_ahb_lpx_clk. Divide i2c_apb_lpx_clk by
 * (SKIP_CNT+1).
 */
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_ADDR (0x4005000c)
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_MASK_VAL 0x0000007f
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_RMASK_VAL 0x0000007f
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_WMASK_VAL 0x0000007f
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_EN_POS 0
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_EN_SIZE 1
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_SKIP_CNT_MASK 0x0000007e
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_SKIP_CNT_SIZE 6
#define IAXXX_CNR7_I2C_APB_LPX_CLK_SC_SKIP_CNT_DECL (6:1)

/*** CNR7_I2C0_APB_CLK_CG (0x40050010) ***/
/*
 * Clock will be always available when i2c_apb_lpx_clk is enabled. This clock
 * is sourced from pd7_ahb_lpx_clk.
 */
#define IAXXX_CNR7_I2C0_APB_CLK_CG_ADDR (0x40050010)
#define IAXXX_CNR7_I2C0_APB_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_APB_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_APB_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_APB_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_I2C0_APB_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_I2C0_APB_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_I2C0_APB_CLK_CG_EN_POS 0
#define IAXXX_CNR7_I2C0_APB_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_I2C0_APB_CLK_CG_EN_DECL 0

/*** CNR7_I2C0_SAMP_X_CLK_CG (0x40050014) ***/
/*
 * Enable i2c0_samp_x_clk clock for I2C Sample clock, the clock root is
 * x_clk.  I2c_samp_x_clk must be enabled before enabling this clock. If not
 * followed, system hangs!<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_ADDR (0x40050014)
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_EN_POS 0
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_I2C0_SAMP_X_CLK_CG_EN_DECL 0

/*** CNR7_I2C1_APB_CLK_CG (0x40050018) ***/
/*
 * Clock will be always available when i2c_apb_lpx_clk is enabled. This clock
 * is sourced from pd7_ahb_lpx_clk.
 */
#define IAXXX_CNR7_I2C1_APB_CLK_CG_ADDR (0x40050018)
#define IAXXX_CNR7_I2C1_APB_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_APB_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_APB_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_APB_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_I2C1_APB_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_I2C1_APB_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_I2C1_APB_CLK_CG_EN_POS 0
#define IAXXX_CNR7_I2C1_APB_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_I2C1_APB_CLK_CG_EN_DECL 0

/*** CNR7_I2C1_SAMP_X_CLK_CG (0x4005001c) ***/
/*
 * Enable i2c1_samp_x_clk clock for I2C Sample clock, the clock root is
 * x_clk.   I2c_samp_x_clk must be enabled before enabling this clock. If not
 * followed, system hangs!<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_ADDR (0x4005001c)
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_EN_POS 0
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_I2C1_SAMP_X_CLK_CG_EN_DECL 0

/*** CNR7_SPI0_APB_CLK_HW_CG (0x40050020) ***/
/*
 * Hardware Controlled enable for spi0_apb_clk. This clock is sourced from
 * pd7_ahb_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) SPI0 IP asserts spi_apb_clk_req_samp_o b) SPI0
 * IP asserts spi_apb_clk_req_apb_o c) AHB master accesses SPI0 APB registers
 */
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_ADDR (0x40050020)
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_SPI0_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_SPI0_SAMP_X_CLK_CG (0x40050024) ***/
/*
 * Enable spi0_samp_x_clk clock for SPI Sample clock, the clock root is
 * x_clk.  spi_samp_x_clk must be enabled before enabling this clock. If not
 * followed, system hangs!<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_ADDR (0x40050024)
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_EN_POS 0
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_SPI0_SAMP_X_CLK_CG_EN_DECL 0

/*** CNR7_SPI1_APB_CLK_HW_CG (0x40050028) ***/
/*
 * Hardware Controlled enable for spi1_apb_clk. This clock is sourced from
 * pd7_ahb_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) SPI1 IP asserts spi_apb_clk_req_samp_o b) SPI1
 * IP asserts spi_apb_clk_req_apb_o c) AHB master accesses SPI1 APB registers
 */
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_ADDR (0x40050028)
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_SPI1_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_SPI1_SAMP_X_CLK_CG (0x4005002c) ***/
/*
 * Enable spi1_samp_x_clk clock for SPI Sample clock, the clock root is
 * x_clk.  spi_samp_x_clk must be enabled before enabling this clock. If not
 * followed, system hangs!<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_ADDR (0x4005002c)
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_EN_POS 0
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_EN_SIZE 1
#define IAXXX_CNR7_SPI1_SAMP_X_CLK_CG_EN_DECL 0

/*** CNR7_UART0_APB_CLK_HW_CG (0x40050030) ***/
/*
 * Hardware Controlled enable for uart0_apb_clk. This clock is sourced from
 * pd7_ahb_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>This Hardware controlled clock gate is not enabled by
 * default. Software must set EN as 1 to enable this clock gate.<br><br>When
 * EN = 0, Clock will be cut regardless of Hardware Control and HW_OVRD
 * configuration<br>When EN = 1, Clock will be supplied based on the Hardware
 * Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1 unless suggested
 * by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is supposed to clear
 * them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) UART0 IP asserts uart_lp_req_pclk low b) AHB
 * master accesses UART0 APB registers
 */
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_ADDR (0x40050030)
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_UART0_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_UART0_SAMP_X_CLK_HW_CG (0x40050034) ***/
/*
 * Hardware Controlled enable for uart0_samp_x_clk. This clock is sourced
 * from x_clk. uart_samp_x_clk must be enabled before enabling this clock. If
 * not followed, system hangs! It may be required to set OVERRIDE for debug
 * by debugger.<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective<br><br>This Hardware controlled clock gate is not enabled
 * by default. Software must set EN as 1 to enable this clock
 * gate.<br><br>When EN = 0, Clock will be cut regardless of Hardware Control
 * and HW_OVRD configuration<br>When EN = 1, Clock will be supplied based on
 * the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1
 * unless suggested by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is
 * supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if UART0
 * assert uart_lp_req_sclk low
 */
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_ADDR (0x40050034)
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_UART0_SAMP_X_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_UART1_APB_CLK_HW_CG (0x40050038) ***/
/*
 * Hardware Controlled enable for uart1_apb_clk. This clock is sourced from
 * pd7_ahb_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>This Hardware controlled clock gate is not enabled by
 * default. Software must set EN as 1 to enable this clock gate.<br><br>When
 * EN = 0, Clock will be cut regardless of Hardware Control and HW_OVRD
 * configuration<br>When EN = 1, Clock will be supplied based on the Hardware
 * Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1 unless suggested
 * by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is supposed to clear
 * them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) UART1 IP asserts uart_lp_req_pclk low b) AHB
 * master accesses UART1 APB registers
 */
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_ADDR (0x40050038)
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_UART1_APB_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_UART1_SAMP_X_CLK_HW_CG (0x4005003c) ***/
/*
 * Hardware Controlled enable for uart1_samp_x_clk. This clock is sourced
 * from x_clk. uart_samp_x_clk must be enabled before enabling this clock. If
 * not followed, system hangs! It may be required to set OVERRIDE for debug
 * by debugger.<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective<br><br>This Hardware controlled clock gate is not enabled
 * by default. Software must set EN as 1 to enable this clock
 * gate.<br><br>When EN = 0, Clock will be cut regardless of Hardware Control
 * and HW_OVRD configuration<br>When EN = 1, Clock will be supplied based on
 * the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1
 * unless suggested by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is
 * supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if UART1
 * assert uart_lp_req_sclk low
 */
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_ADDR (0x4005003c)
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR7_UART1_SAMP_X_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR7_APB_REG_SOFT_RST (0x40050040) ***/
/*
 * Resets APB registers
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_ADDR (0x40050040)
#define IAXXX_CNR7_APB_REG_SOFT_RST_MASK_VAL 0x000001fe
#define IAXXX_CNR7_APB_REG_SOFT_RST_RMASK_VAL 0x00000030
#define IAXXX_CNR7_APB_REG_SOFT_RST_WMASK_VAL 0x00000030
#define IAXXX_CNR7_APB_REG_SOFT_RST_RESET_VAL 0x00000030

/*
 * Write 1 to reset H2P3 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_H2P3_APB_REG_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR7_APB_REG_SOFT_RST_H2P3_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_H2P3_APB_REG_SOFT_RST_POS 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_H2P3_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_H2P3_APB_REG_SOFT_RST_DECL 1

/*
 * Write 1 to reset I2C0 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C0_APB_REG_SOFT_RST_MASK 0x00000004
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C0_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C0_APB_REG_SOFT_RST_POS 2
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C0_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C0_APB_REG_SOFT_RST_DECL 2

/*
 * Write 1 to reset I2C1 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C1_APB_REG_SOFT_RST_MASK 0x00000008
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C1_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C1_APB_REG_SOFT_RST_POS 3
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C1_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_I2C1_APB_REG_SOFT_RST_DECL 3

/*
 * Write 1 to assert UART0 APB register reset. Write 0 to de-assert the
 * reset.
 * SW must follow the reset sequence mentioned as per <a
 * href="http://intranet/Engineering/VLSI/Shared%20Documents/D4101%20(Bayern)/Design/UART/DW_apb_uart_databook.pdf">DW_apb_uart_databook</a>
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART0_APB_REG_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART0_APB_REG_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART0_APB_REG_SOFT_RST_POS 4
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART0_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART0_APB_REG_SOFT_RST_DECL 4

/*
 * Write 1 to assert UART1 APB register reset. Write 0 to de-assert the
 * reset.
 * SW must follow the reset sequence mentioned as per <a
 * href="http://intranet/Engineering/VLSI/Shared%20Documents/D4101%20(Bayern)/Design/UART/DW_apb_uart_databook.pdf">DW_apb_uart_databook</a>
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART1_APB_REG_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART1_APB_REG_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART1_APB_REG_SOFT_RST_POS 5
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART1_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_UART1_APB_REG_SOFT_RST_DECL 5

/*
 * Write 1 to reset SPI0APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI0_APB_REG_SOFT_RST_MASK 0x00000040
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI0_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI0_APB_REG_SOFT_RST_POS 6
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI0_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI0_APB_REG_SOFT_RST_DECL 6

/*
 * Write 1 to reset SPI1 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI1_APB_REG_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI1_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI1_APB_REG_SOFT_RST_POS 7
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI1_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_SPI1_APB_REG_SOFT_RST_DECL 7

/*
 * Write 1 to reset AFG APB registers only. It will always read back as 0
 */
#define IAXXX_CNR7_APB_REG_SOFT_RST_AFG_APB_REG_SOFT_RST_MASK 0x00000100
#define IAXXX_CNR7_APB_REG_SOFT_RST_AFG_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR7_APB_REG_SOFT_RST_AFG_APB_REG_SOFT_RST_POS 8
#define IAXXX_CNR7_APB_REG_SOFT_RST_AFG_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_APB_REG_SOFT_RST_AFG_APB_REG_SOFT_RST_DECL 8

/*** CNR7_FUNC_SOFT_RST (0x40050044) ***/
/*
 * Reset the corresponding APB_REG_SOFT_RST when reprogramming the module
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_ADDR (0x40050044)
#define IAXXX_CNR7_FUNC_SOFT_RST_MASK_VAL 0x0000007f
#define IAXXX_CNR7_FUNC_SOFT_RST_RMASK_VAL 0x0000007f
#define IAXXX_CNR7_FUNC_SOFT_RST_WMASK_VAL 0x0000007f
#define IAXXX_CNR7_FUNC_SOFT_RST_RESET_VAL 0x0000007f

/*
 * I2C0 reset in PD7
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C0_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C0_SOFT_RST_POS 0
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C0_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C0_SOFT_RST_DECL 0

/*
 * I2C1 reset in PD7
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C1_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C1_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C1_SOFT_RST_POS 1
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C1_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_I2C1_SOFT_RST_DECL 1

/*
 * Write 1 to assert UART0 reset in PD7. Write 0 to de-assert the reset.
 * SW must follow the reset sequence mentioned as per <a
 * href="http://intranet/Engineering/VLSI/Shared%20Documents/D4101%20(Bayern)/Design/UART/DW_apb_uart_databook.pdf">DW_apb_uart_databook</a>
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_UART0_SOFT_RST_MASK 0x00000004
#define IAXXX_CNR7_FUNC_SOFT_RST_UART0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_UART0_SOFT_RST_POS 2
#define IAXXX_CNR7_FUNC_SOFT_RST_UART0_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_UART0_SOFT_RST_DECL 2

/*
 * Write 1 to assert UART1 reset in PD7. Write 0 to de-assert the reset.
 * SW must follow the reset sequence mentioned as per <a
 * href="http://intranet/Engineering/VLSI/Shared%20Documents/D4101%20(Bayern)/Design/UART/DW_apb_uart_databook.pdf">DW_apb_uart_databook</a>
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_UART1_SOFT_RST_MASK 0x00000008
#define IAXXX_CNR7_FUNC_SOFT_RST_UART1_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_UART1_SOFT_RST_POS 3
#define IAXXX_CNR7_FUNC_SOFT_RST_UART1_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_UART1_SOFT_RST_DECL 3

/*
 * SPI0 reset in PD7
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI0_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI0_SOFT_RST_POS 4
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI0_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI0_SOFT_RST_DECL 4

/*
 * SPI1 reset in PD7
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI1_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI1_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI1_SOFT_RST_POS 5
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI1_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_SPI1_SOFT_RST_DECL 5

/*
 * AFG reset in PD7
 */
#define IAXXX_CNR7_FUNC_SOFT_RST_AFG_SOFT_RST_MASK 0x00000040
#define IAXXX_CNR7_FUNC_SOFT_RST_AFG_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR7_FUNC_SOFT_RST_AFG_SOFT_RST_POS 6
#define IAXXX_CNR7_FUNC_SOFT_RST_AFG_SOFT_RST_SIZE 1
#define IAXXX_CNR7_FUNC_SOFT_RST_AFG_SOFT_RST_DECL 6

/*** CNR7_ERR_PADDR (0x40050048) ***/
/*
 * This register has the address for which error is reported and caused
 * register bus to stall.
 *
 Software must follow the steps to recover
 * 1) Enable the source clock for the Clock Gate or Clock Divider that has
 * caused bus to stall
 * 2) Re-configure the Clock Gate or Clock Divider as per correct sequence
 */
#define IAXXX_CNR7_ERR_PADDR_ADDR (0x40050048)
#define IAXXX_CNR7_ERR_PADDR_MASK_VAL 0x00000fff
#define IAXXX_CNR7_ERR_PADDR_RMASK_VAL 0x00000fff
#define IAXXX_CNR7_ERR_PADDR_WMASK_VAL 0x00000000
#define IAXXX_CNR7_ERR_PADDR_RESET_VAL 0x00000000

/*
 * CNR7 Address for which address bus is stalled
 */
#define IAXXX_CNR7_ERR_PADDR_ADDRESS_MASK 0x00000fff
#define IAXXX_CNR7_ERR_PADDR_ADDRESS_RESET_VAL 0x0
#define IAXXX_CNR7_ERR_PADDR_ADDRESS_POS 0
#define IAXXX_CNR7_ERR_PADDR_ADDRESS_SIZE 12
#define IAXXX_CNR7_ERR_PADDR_ADDRESS_DECL (11:0)

/*** CNR7_SPARE_GATES (0x4005004c) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_CNR7_SPARE_GATES_ADDR (0x4005004c)
#define IAXXX_CNR7_SPARE_GATES_MASK_VAL 0xffffffff
#define IAXXX_CNR7_SPARE_GATES_RMASK_VAL 0xffffffff
#define IAXXX_CNR7_SPARE_GATES_WMASK_VAL 0x0000ffff
#define IAXXX_CNR7_SPARE_GATES_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_CNR7_SPARE_GATES_FIELD_1_MASK 0x0000ffff
#define IAXXX_CNR7_SPARE_GATES_FIELD_1_RESET_VAL 0x0
#define IAXXX_CNR7_SPARE_GATES_FIELD_1_POS 0
#define IAXXX_CNR7_SPARE_GATES_FIELD_1_SIZE 16
#define IAXXX_CNR7_SPARE_GATES_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_CNR7_SPARE_GATES_FIELD_2_MASK 0xffff0000
#define IAXXX_CNR7_SPARE_GATES_FIELD_2_RESET_VAL 0x0
#define IAXXX_CNR7_SPARE_GATES_FIELD_2_POS 16
#define IAXXX_CNR7_SPARE_GATES_FIELD_2_SIZE 16
#define IAXXX_CNR7_SPARE_GATES_FIELD_2_DECL (31:16)

/* Number of registers in the module */
#define IAXXX_CNR7_REG_NUM 20

#endif /* __IAXXX_REGISTER_DEFS_CNR7_H__*/
