/*
 * iaxxx-register-defs-cnr.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_CNR_H__
#define __IAXXX_REGISTER_DEFS_CNR_H__

/*** The base address for this set of registers ***/
#define IAXXX_CNR_REGS_ADDR (0x40001000)

/*** CNR_A_CLK_MUX (0x40001000) ***/
/*
 * Control to switch between APLL, MPLL and OSC as the source of a_clk. This
 * is a Glitchless MUX.
 */
#define IAXXX_CNR_A_CLK_MUX_ADDR (0x40001000)
#define IAXXX_CNR_A_CLK_MUX_MASK_VAL 0x00000007
#define IAXXX_CNR_A_CLK_MUX_RMASK_VAL 0x00000007
#define IAXXX_CNR_A_CLK_MUX_WMASK_VAL 0x00000007
#define IAXXX_CNR_A_CLK_MUX_RESET_VAL 0x00000001

/*
 * One-hot encoded MUX Select <br>0x1: apll_clk_out_o<br>0x2:
 * mpll_clk_out_o<br>0x4: osc_clk_divd_byp_pll_o<br>
 * This field should not be programmed to the following illegal values:
 *   0x0
 *   0x3
 *   0x5
 *   0x6
 *   0x7
 */
#define IAXXX_CNR_A_CLK_MUX_SEL_MASK 0x00000007
#define IAXXX_CNR_A_CLK_MUX_SEL_RESET_VAL 0x1
#define IAXXX_CNR_A_CLK_MUX_SEL_POS 0
#define IAXXX_CNR_A_CLK_MUX_SEL_SIZE 3
#define IAXXX_CNR_A_CLK_MUX_SEL_DECL (2:0)

/*** CNR_A_CLK_NR (0x40001004) ***/
/*
 * a_clk_nr is sourced from a_clk_sc through a N/R Divider. To calculate the
 * out_clk frequency: D = 2^(width of N field) + N - R, out_clk =
 * (N/D)*in_clk. If N/D is not an integer, the out_clk duty cycle is not
 * 50%.<br>After issuing an N R update, software must wait for 1 D duration
 * of input clock period before writing new N R values. Register
 * configuration will take ((6 to 7) * (register_clock_frequency /
 * gate_source_clock_frequency)) clock periods to become effective
 */
#define IAXXX_CNR_A_CLK_NR_ADDR (0x40001004)
#define IAXXX_CNR_A_CLK_NR_MASK_VAL 0x0000003f
#define IAXXX_CNR_A_CLK_NR_RMASK_VAL 0x0000003f
#define IAXXX_CNR_A_CLK_NR_WMASK_VAL 0x0000003f
#define IAXXX_CNR_A_CLK_NR_RESET_VAL 0x00000018

/*
 * Enable for NR Counter
 */
#define IAXXX_CNR_A_CLK_NR_EN_MASK 0x00000001
#define IAXXX_CNR_A_CLK_NR_EN_RESET_VAL 0x0
#define IAXXX_CNR_A_CLK_NR_EN_POS 0
#define IAXXX_CNR_A_CLK_NR_EN_SIZE 1
#define IAXXX_CNR_A_CLK_NR_EN_DECL 0

/*
 * R Count value
 */
#define IAXXX_CNR_A_CLK_NR_R_CNT_MASK 0x0000000e
#define IAXXX_CNR_A_CLK_NR_R_CNT_RESET_VAL 0x4
#define IAXXX_CNR_A_CLK_NR_R_CNT_POS 1
#define IAXXX_CNR_A_CLK_NR_R_CNT_SIZE 3
#define IAXXX_CNR_A_CLK_NR_R_CNT_DECL (3:1)

/*
 * N Count value
 */
#define IAXXX_CNR_A_CLK_NR_N_CNT_MASK 0x00000030
#define IAXXX_CNR_A_CLK_NR_N_CNT_RESET_VAL 0x1
#define IAXXX_CNR_A_CLK_NR_N_CNT_POS 4
#define IAXXX_CNR_A_CLK_NR_N_CNT_SIZE 2
#define IAXXX_CNR_A_CLK_NR_N_CNT_DECL (5:4)

/*** CNR_A_CLK_SC (0x40001008) ***/
/*
 * a_clk_sc is sourced from a_clk. Divide a_clk_sc by (SKIP_CNT+1) which is
 * used to feed a NR Divider (N2R3).<br>Register configuration will take ((6
 * to 7) * (register_clock_frequency / gate_source_clock_frequency)) clock
 * periods to become effective
 */
#define IAXXX_CNR_A_CLK_SC_ADDR (0x40001008)
#define IAXXX_CNR_A_CLK_SC_MASK_VAL 0x0000001f
#define IAXXX_CNR_A_CLK_SC_RMASK_VAL 0x0000001f
#define IAXXX_CNR_A_CLK_SC_WMASK_VAL 0x0000001f
#define IAXXX_CNR_A_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_A_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_A_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_A_CLK_SC_EN_POS 0
#define IAXXX_CNR_A_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_A_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_A_CLK_SC_SKIP_CNT_MASK 0x0000001e
#define IAXXX_CNR_A_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_A_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_A_CLK_SC_SKIP_CNT_SIZE 4
#define IAXXX_CNR_A_CLK_SC_SKIP_CNT_DECL (4:1)

/*** CNR_AO_APB_LPX_CLK_HW_CG (0x4000100c) ***/
/*
 * Hardware Controlled enable for ao_apb_lpx_clk. This clock is sourced from
 * lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access AO APB registers
 */
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_ADDR (0x4000100c)
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_AO_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_APLL_CLK_IN_MUX (0x40001010) ***/
/*
 * Select clock source for Audio PLL.  This is a Glitchy MUX.
 */
#define IAXXX_CNR_APLL_CLK_IN_MUX_ADDR (0x40001010)
#define IAXXX_CNR_APLL_CLK_IN_MUX_MASK_VAL 0x0000000f
#define IAXXX_CNR_APLL_CLK_IN_MUX_RMASK_VAL 0x0000000f
#define IAXXX_CNR_APLL_CLK_IN_MUX_WMASK_VAL 0x0000000f
#define IAXXX_CNR_APLL_CLK_IN_MUX_RESET_VAL 0x00000000

/*
 * MUX Select <br>0x0: sys_clk_o<br>0x1: io_ref0_clk2cnr_i<br>0x2:
 * io_ref1_clk2cnr_i<br>0x3: io_ref2_clk2cnr_i<br>0x4:
 * io_ref3_clk2cnr_i<br>0x5: io_ref4_clk2cnr_i<br>0x6:
 * io_ref5_clk2cnr_i<br>0x7: io_ref6_clk2cnr_i<br>0x8:
 * osc_clk_divd_byp_pll_o<br>0x9: clk_in_i<br><br>Any other values apart from
 * the valid configurations would result in not selecting any of the clocks
 * as output
 */
#define IAXXX_CNR_APLL_CLK_IN_MUX_SEL_MASK 0x0000000f
#define IAXXX_CNR_APLL_CLK_IN_MUX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_APLL_CLK_IN_MUX_SEL_POS 0
#define IAXXX_CNR_APLL_CLK_IN_MUX_SEL_SIZE 4
#define IAXXX_CNR_APLL_CLK_IN_MUX_SEL_DECL (3:0)

/*** CNR_APLL_CLK_OUT_MUX (0x40001014) ***/
/*
 * 0x2 : APLL Bypassed. Input to the PLL is directly used for CNR clock root.
 * 0x1 : APLL is not bypassed. This is a Glitchless MUX.
 */
#define IAXXX_CNR_APLL_CLK_OUT_MUX_ADDR (0x40001014)
#define IAXXX_CNR_APLL_CLK_OUT_MUX_MASK_VAL 0x00000003
#define IAXXX_CNR_APLL_CLK_OUT_MUX_RMASK_VAL 0x00000003
#define IAXXX_CNR_APLL_CLK_OUT_MUX_WMASK_VAL 0x00000003
#define IAXXX_CNR_APLL_CLK_OUT_MUX_RESET_VAL 0x00000001

/*
 * One-hot encoded MUX Select <br>0x1: apll_clk_out_i<br>0x2:
 * apll_clk_in_o<br>
 * This field should not be programmed to the following illegal values:
 *   0x0
 *   0x3
 */
#define IAXXX_CNR_APLL_CLK_OUT_MUX_SEL_MASK 0x00000003
#define IAXXX_CNR_APLL_CLK_OUT_MUX_SEL_RESET_VAL 0x1
#define IAXXX_CNR_APLL_CLK_OUT_MUX_SEL_POS 0
#define IAXXX_CNR_APLL_CLK_OUT_MUX_SEL_SIZE 2
#define IAXXX_CNR_APLL_CLK_OUT_MUX_SEL_DECL (1:0)

/*** CNR_AUD_WALL_A_CLK_CG (0x40001018) ***/
/*
 * Enable the clock root for AUD WALL Clock, the clock root is
 * a_clk_nr<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_ADDR (0x40001018)
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_EN_POS 0
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_EN_SIZE 1
#define IAXXX_CNR_AUD_WALL_A_CLK_CG_EN_DECL 0

/*** CNR_CLK_CCAL0_MUX (0x4000101c) ***/
/*
 * Select clock source for clk_ccal_0. Please note that clk_ccal1 should be
 * equal or faster thatn clk_ccal0.  This is a Glitchy MUX.
 */
#define IAXXX_CNR_CLK_CCAL0_MUX_ADDR (0x4000101c)
#define IAXXX_CNR_CLK_CCAL0_MUX_MASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL0_MUX_RMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL0_MUX_WMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL0_MUX_RESET_VAL 0x00000000

/*
 * MUX Select <br>0x0: sys_clk_o<br>0x1: io_ref0_clk2cnr_i<br>0x2:
 * io_ref1_clk2cnr_i<br>0x3: io_ref2_clk2cnr_i<br>0x4:
 * io_ref3_clk2cnr_i<br>0x5: io_ref4_clk2cnr_i<br>0x6:
 * io_ref5_clk2cnr_i<br>0x7: io_ref6_clk2cnr_i<br>0x8:
 * osc_clk_divd_byp_pll_o<br>0x9: clk_in_i<br><br>Any other values apart from
 * the valid configurations would result in not selecting any of the clocks
 * as output
 */
#define IAXXX_CNR_CLK_CCAL0_MUX_SEL_MASK 0x0000000f
#define IAXXX_CNR_CLK_CCAL0_MUX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_CCAL0_MUX_SEL_POS 0
#define IAXXX_CNR_CLK_CCAL0_MUX_SEL_SIZE 4
#define IAXXX_CNR_CLK_CCAL0_MUX_SEL_DECL (3:0)

/*** CNR_CLK_CCAL1_MUX (0x40001020) ***/
/*
 * Select clock source for clk_ccal_1. Please note that clk_ccal1 should be
 * equal or faster thatn clk_ccal0.  This is a Glitchy MUX.
 */
#define IAXXX_CNR_CLK_CCAL1_MUX_ADDR (0x40001020)
#define IAXXX_CNR_CLK_CCAL1_MUX_MASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL1_MUX_RMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL1_MUX_WMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CCAL1_MUX_RESET_VAL 0x00000000

/*
 * MUX Select <br>0x0: sys_clk_o<br>0x1: io_ref0_clk2cnr_i<br>0x2:
 * io_ref1_clk2cnr_i<br>0x3: io_ref2_clk2cnr_i<br>0x4:
 * io_ref3_clk2cnr_i<br>0x5: io_ref4_clk2cnr_i<br>0x6:
 * io_ref5_clk2cnr_i<br>0x7: io_ref6_clk2cnr_i<br>0x8:
 * osc_clk_divd_byp_pll_o<br>0x9: clk_in_i<br><br>Any other values apart from
 * the valid configurations would result in not selecting any of the clocks
 * as output
 */
#define IAXXX_CNR_CLK_CCAL1_MUX_SEL_MASK 0x0000000f
#define IAXXX_CNR_CLK_CCAL1_MUX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_CCAL1_MUX_SEL_POS 0
#define IAXXX_CNR_CLK_CCAL1_MUX_SEL_SIZE 4
#define IAXXX_CNR_CLK_CCAL1_MUX_SEL_DECL (3:0)

/*** CNR_CNR_APB_LPX_CLK_HW_CG (0x40001024) ***/
/*
 * Hardware Controlled enable for cnr_apb_lpx_clk.  On POR, OVERRIDE is set
 * because of fail-safe. This clock is sourced from lpx_clk. OVERRIDE must be
 * disabled upon successful boot. It may be required to set OVERRIDE for
 * debug by debugger.<br><br>When EN = 0, Clock will be cut regardless of
 * Hardware Control and HW_OVRD configuration<br>When EN = 1, Clock will be
 * supplied based on the Hardware Control condition<br><br>NOTE:<br>DO NOT
 * SET HW_OVRD = 1 or Modify EN Bit unless suggested by VLSI<br>For cases,
 * where HW_OVRD = 1 on Reset, SW is supposed to clear them after successful
 * bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if one of
 * these conditions are met : a) AHB masters access CNR APB registers b) CNR
 * APB ready error interrupt is set
 */
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_ADDR (0x40001024)
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000003

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x1
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_CNR_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_CNR_CD_AO_CLK_SC (0x40001028) ***/
/*
 * Divides always on clock sys_clk_o  by (SKIP_CNT+1) to generate always on
 * clock cnr_cd_ao_clk_o for the clock detection circuit.<br>Register
 * configuration will take ((6 to 7) * (register_clock_frequency /
 * gate_source_clock_frequency)) clock periods to become effective
 */
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_ADDR (0x40001028)
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_MASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_RMASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_WMASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_RESET_VAL 0x00000001

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_EN_RESET_VAL 0x1
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_EN_POS 0
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_SKIP_CNT_MASK 0x00001ffe
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_SKIP_CNT_SIZE 12
#define IAXXX_CNR_CNR_CD_AO_CLK_SC_SKIP_CNT_DECL (12:1)

/*** CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC (0x4000102c) ***/
/*
 * Divides always on clock sys_clk_o  by (SKIP_CNT+1) to generate always on
 * clock cnr_pll_switch_cd_ao_clk_o for the clock detection circuit used for
 * the on-the-fly PLL switch circuitry.<br>Register configuration will take
 * ((6 to 7) * (register_clock_frequency / gate_source_clock_frequency))
 * clock periods to become effective
 */
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_ADDR (0x4000102c)
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_MASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_RMASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_WMASK_VAL 0x00001fff
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_RESET_VAL 0x00000001

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_EN_RESET_VAL 0x1
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_EN_POS 0
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_SKIP_CNT_MASK 0x00001ffe
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_SKIP_CNT_SIZE 12
#define IAXXX_CNR_CNR_PLL_SWITCH_CD_AO_CLK_SC_SKIP_CNT_DECL (12:1)

/*** CNR_GPIO_APB_LPX_CLK_HW_CG (0x40001030) ***/
/*
 * Hardware Controlled enable for gpio_apb_lpx_clk. This clock is sourced
 * from lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access GPIO APB registers
 */
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_ADDR (0x40001030)
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_GPIO_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG (0x40001034) ***/
/*
 * Hardware Controlled enable for gpio_intr_lpx_clk_root. This clock is
 * sourced from lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) Clock is requested by GPIO IP (please refer to
 * GPIO IP data sheet for more details) b) Access to GPIO APB registers
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_ADDR (0x40001034)
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_EN_POS 0
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_EN_SIZE 1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_ROOT_HW_CG_HW_OVRD_DECL 1

/*** CNR_GPIO_INTR_LPX_CLK_SC (0x40001038) ***/
/*
 * gpio_intr_lpx_clk is sourced from gpio_intr_lpx_clk_root.  Divide GPIO
 * interrupt clock by (SKIP_CNT + 1)
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_ADDR (0x40001038)
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_MASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_RMASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_WMASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_EN_POS 0
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_SKIP_CNT_MASK 0x00003ffe
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_SKIP_CNT_SIZE 13
#define IAXXX_CNR_GPIO_INTR_LPX_CLK_SC_SKIP_CNT_DECL (13:1)

/*** CNR_HDMAC_LPX_CLK_CG (0x4000103c) ***/
/*
 * Clock gate for HDMAC clock. Disabling this gate stops clock supply to
 * HDMAC. This clock is sourced from lpx_clk.
 */
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_ADDR (0x4000103c)
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR_HDMAC_LPX_CLK_CG_EN_DECL 0

/*** CNR_I2C_SAMP_X_CLK_SC (0x40001040) ***/
/*
 * I2C Sample clock is sourced from x_clk. Divide I2C clock by (SKIP_CNT +
 * 1)<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_ADDR (0x40001040)
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_MASK_VAL 0x0000007f
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_RMASK_VAL 0x0000007f
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_WMASK_VAL 0x0000007f
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_EN_POS 0
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_SKIP_CNT_MASK 0x0000007e
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_SKIP_CNT_SIZE 6
#define IAXXX_CNR_I2C_SAMP_X_CLK_SC_SKIP_CNT_DECL (6:1)

/*** CNR_I2S_MSTR_A_CLK_SC (0x40001044) ***/
/*
 * i2s_mstr_a_clk is sourced from a_clk. Divide i2s_mstr_a_clk by
 * (SKIP_CNT+1)<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_ADDR (0x40001044)
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_MASK_VAL 0x0000001f
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_RMASK_VAL 0x0000001f
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_WMASK_VAL 0x0000001f
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_EN_POS 0
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_SKIP_CNT_MASK 0x0000001e
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_SKIP_CNT_SIZE 4
#define IAXXX_CNR_I2S_MSTR_A_CLK_SC_SKIP_CNT_DECL (4:1)

/*** CNR_LPX_CLK_NR (0x40001048) ***/
/*
 * lpx_clk is sourced from x_clk. To calculate the out_clk frequency: D =
 * 2^(width of N field) + N - R, out_clk = (N/D)*in_clk. If N/D is not an
 * integer, the out_clk duty cycle is not 50%<br>After issuing an N R update,
 * software must wait for 1 D duration of input clock period before writing
 * new N R values. Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_LPX_CLK_NR_ADDR (0x40001048)
#define IAXXX_CNR_LPX_CLK_NR_MASK_VAL 0x0003ffff
#define IAXXX_CNR_LPX_CLK_NR_RMASK_VAL 0x0003ffff
#define IAXXX_CNR_LPX_CLK_NR_WMASK_VAL 0x0003ffff
#define IAXXX_CNR_LPX_CLK_NR_RESET_VAL 0x00000601

/*
 * Enable for NR Counter
 */
#define IAXXX_CNR_LPX_CLK_NR_EN_MASK 0x00000001
#define IAXXX_CNR_LPX_CLK_NR_EN_RESET_VAL 0x1
#define IAXXX_CNR_LPX_CLK_NR_EN_POS 0
#define IAXXX_CNR_LPX_CLK_NR_EN_SIZE 1
#define IAXXX_CNR_LPX_CLK_NR_EN_DECL 0

/*
 * R Count value
 */
#define IAXXX_CNR_LPX_CLK_NR_R_CNT_MASK 0x000003fe
#define IAXXX_CNR_LPX_CLK_NR_R_CNT_RESET_VAL 0x100
#define IAXXX_CNR_LPX_CLK_NR_R_CNT_POS 1
#define IAXXX_CNR_LPX_CLK_NR_R_CNT_SIZE 9
#define IAXXX_CNR_LPX_CLK_NR_R_CNT_DECL (9:1)

/*
 * N Count value
 */
#define IAXXX_CNR_LPX_CLK_NR_N_CNT_MASK 0x0003fc00
#define IAXXX_CNR_LPX_CLK_NR_N_CNT_RESET_VAL 0x1
#define IAXXX_CNR_LPX_CLK_NR_N_CNT_POS 10
#define IAXXX_CNR_LPX_CLK_NR_N_CNT_SIZE 8
#define IAXXX_CNR_LPX_CLK_NR_N_CNT_DECL (17:10)

/*** CNR_MCLK_CG (0x4000104c) ***/
/*
 * Clock Gate for mclk_o. Disabling this gate stops clock supply to MCLK out.
 * This clock is sourced from mclk_root<br>Register configuration will take
 * ((6 to 7) * (register_clock_frequency / gate_source_clock_frequency))
 * clock periods to become effective
 */
#define IAXXX_CNR_MCLK_CG_ADDR (0x4000104c)
#define IAXXX_CNR_MCLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR_MCLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR_MCLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR_MCLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_MCLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR_MCLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR_MCLK_CG_EN_POS 0
#define IAXXX_CNR_MCLK_CG_EN_SIZE 1
#define IAXXX_CNR_MCLK_CG_EN_DECL 0

/*** CNR_MCLK_ROOT_MUX (0x40001050) ***/
/*
 * Control to switch between APLL, MPLL and mclk_sel as the source of MCLK.
 * This is a Glitchless MUX.
 */
#define IAXXX_CNR_MCLK_ROOT_MUX_ADDR (0x40001050)
#define IAXXX_CNR_MCLK_ROOT_MUX_MASK_VAL 0x00000007
#define IAXXX_CNR_MCLK_ROOT_MUX_RMASK_VAL 0x00000007
#define IAXXX_CNR_MCLK_ROOT_MUX_WMASK_VAL 0x00000007
#define IAXXX_CNR_MCLK_ROOT_MUX_RESET_VAL 0x00000001

/*
 * One-hot encoded MUX Select <br>0x1: mclk_sel<br>0x2:
 * mpll_clk_out_o<br>0x4: apll_clk_out_o<br>
 * This field should not be programmed to the following illegal values:
 *   0x0
 *   0x3
 *   0x5
 *   0x6
 *   0x7
 */
#define IAXXX_CNR_MCLK_ROOT_MUX_SEL_MASK 0x00000007
#define IAXXX_CNR_MCLK_ROOT_MUX_SEL_RESET_VAL 0x1
#define IAXXX_CNR_MCLK_ROOT_MUX_SEL_POS 0
#define IAXXX_CNR_MCLK_ROOT_MUX_SEL_SIZE 3
#define IAXXX_CNR_MCLK_ROOT_MUX_SEL_DECL (2:0)

/*** CNR_MCLK_SEL_MUX (0x40001054) ***/
/*
 * Select clock source for mclk_sel.  This is a Glitchy MUX.
 */
#define IAXXX_CNR_MCLK_SEL_MUX_ADDR (0x40001054)
#define IAXXX_CNR_MCLK_SEL_MUX_MASK_VAL 0x0000000f
#define IAXXX_CNR_MCLK_SEL_MUX_RMASK_VAL 0x0000000f
#define IAXXX_CNR_MCLK_SEL_MUX_WMASK_VAL 0x0000000f
#define IAXXX_CNR_MCLK_SEL_MUX_RESET_VAL 0x00000000

/*
 * MUX Select <br>0x0: sys_clk_o<br>0x1: io_ref0_clk2cnr_i<br>0x2:
 * io_ref1_clk2cnr_i<br>0x3: io_ref2_clk2cnr_i<br>0x4:
 * io_ref3_clk2cnr_i<br>0x5: io_ref4_clk2cnr_i<br>0x6:
 * io_ref5_clk2cnr_i<br>0x7: io_ref6_clk2cnr_i<br>0x8:
 * osc_clk_divd_byp_pll_o<br>0x9: clk_in_i<br><br>Any other values apart from
 * the valid configurations would result in not selecting any of the clocks
 * as output
 */
#define IAXXX_CNR_MCLK_SEL_MUX_SEL_MASK 0x0000000f
#define IAXXX_CNR_MCLK_SEL_MUX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_MCLK_SEL_MUX_SEL_POS 0
#define IAXXX_CNR_MCLK_SEL_MUX_SEL_SIZE 4
#define IAXXX_CNR_MCLK_SEL_MUX_SEL_DECL (3:0)

/*** CNR_MPLL_CLK_IN_MUX (0x40001058) ***/
/*
 * Select clock source for Main PLL. This is a Glitchy MUX.
 */
#define IAXXX_CNR_MPLL_CLK_IN_MUX_ADDR (0x40001058)
#define IAXXX_CNR_MPLL_CLK_IN_MUX_MASK_VAL 0x0000000f
#define IAXXX_CNR_MPLL_CLK_IN_MUX_RMASK_VAL 0x0000000f
#define IAXXX_CNR_MPLL_CLK_IN_MUX_WMASK_VAL 0x0000000f
#define IAXXX_CNR_MPLL_CLK_IN_MUX_RESET_VAL 0x00000000

/*
 * MUX Select <br>0x0: sys_clk_o<br>0x1: io_ref0_clk2cnr_i<br>0x2:
 * io_ref1_clk2cnr_i<br>0x3: io_ref2_clk2cnr_i<br>0x4:
 * io_ref3_clk2cnr_i<br>0x5: io_ref4_clk2cnr_i<br>0x6:
 * io_ref5_clk2cnr_i<br>0x7: io_ref6_clk2cnr_i<br>0x8:
 * osc_clk_divd_byp_pll_o<br>0x9: clk_in_i<br><br>Any other values apart from
 * the valid configurations would result in not selecting any of the clocks
 * as output
 */
#define IAXXX_CNR_MPLL_CLK_IN_MUX_SEL_MASK 0x0000000f
#define IAXXX_CNR_MPLL_CLK_IN_MUX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_MPLL_CLK_IN_MUX_SEL_POS 0
#define IAXXX_CNR_MPLL_CLK_IN_MUX_SEL_SIZE 4
#define IAXXX_CNR_MPLL_CLK_IN_MUX_SEL_DECL (3:0)

/*** CNR_MPLL_CLK_OUT_MUX (0x4000105c) ***/
/*
 * 0x2 : MPLL Bypassed. Input to the PLL is directly used for CNR clock root.
 * 0x1 : MPLL is not bypassed.  This is a Glitchless MUX.
 */
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_ADDR (0x4000105c)
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_MASK_VAL 0x00000003
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_RMASK_VAL 0x00000003
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_WMASK_VAL 0x00000003
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_RESET_VAL 0x00000001

/*
 * One-hot encoded MUX Select <br>0x1: mpll_clk_out_i<br>0x2:
 * mpll_clk_in_o<br>
 * This field should not be programmed to the following illegal values:
 *   0x0
 *   0x3
 */
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_SEL_MASK 0x00000003
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_SEL_RESET_VAL 0x1
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_SEL_POS 0
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_SEL_SIZE 2
#define IAXXX_CNR_MPLL_CLK_OUT_MUX_SEL_DECL (1:0)

/*** CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI (0x40001060) ***/
/*
 * Divides OSC clock by (IDI_CNT+1). The output of the IDI is muxed with
 * CLK_IN to provide one of the PLL reference clock. While booting using
 * CLK_IN, SW is expected to clear this bit to save power. Chip boots on
 * CLK_IN when LOR (Maped to INTR_API) is set as 1 on deassertion of chip
 * reset.<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_ADDR (0x40001060)
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_MASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_RMASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_WMASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_RESET_VAL 0x00000005

/*
 * Enable for IDI Counter
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_EN_MASK 0x00000001
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_EN_RESET_VAL 0x1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_EN_POS 0
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_EN_SIZE 1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_EN_DECL 0

/*
 * IDI Count value
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_IDI_CNT_MASK 0x0000003e
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_IDI_CNT_RESET_VAL 0x2
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_IDI_CNT_POS 1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_IDI_CNT_SIZE 5
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_CLK_IN_IDI_IDI_CNT_DECL (5:1)

/*** CNR_OSC_CLK_DIVD_BYP_PLL_IDI (0x40001064) ***/
/*
 * Divides OSC clock by (IDI_CNT+1). The output of the IDI is muxed with MPLL
 * and APLL output clocks to provide x_cllk ( and / or ) a_clk. This is the
 * route to bypass PLL<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_ADDR (0x40001064)
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_MASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_RMASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_WMASK_VAL 0x0000003f
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_RESET_VAL 0x00000002

/*
 * Enable for IDI Counter
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_EN_MASK 0x00000001
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_EN_RESET_VAL 0x0
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_EN_POS 0
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_EN_SIZE 1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_EN_DECL 0

/*
 * IDI Count value
 */
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_IDI_CNT_MASK 0x0000003e
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_IDI_CNT_RESET_VAL 0x1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_IDI_CNT_POS 1
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_IDI_CNT_SIZE 5
#define IAXXX_CNR_OSC_CLK_DIVD_BYP_PLL_IDI_IDI_CNT_DECL (5:1)

/*** CNR_PAD_CTRL_APB_LPX_CLK_HW_CG (0x40001068) ***/
/*
 * Hardware Controlled enable for pad_ctrl_apb_lpx_clk. This clock is sourced
 * from lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PAD_CTRL APB registers
 */
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_ADDR (0x40001068)
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PAD_CTRL_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_PCTRL_LPX_CLK_ROOT_HW_CG (0x4000106c) ***/
/*
 * Hardware control enable for pctrl_lpx_clk_root. This clock is sourced from
 * lpx_clk. <br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated only if PD8 is
 * powered up
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_ADDR (0x4000106c)
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_EN_POS 0
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PCTRL_LPX_CLK_ROOT_HW_CG_HW_OVRD_DECL 1

/*** CNR_PCTRL_LPX_CLK_SC (0x40001070) ***/
/*
 * Skip Count control for the PCTRL Clock. pctrl_lpx_clk is sourced from
 * pctrl_lpx_clk_root. Divide pctrl_lpx_clk by (SKIP_CNT+1)
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_ADDR (0x40001070)
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_MASK_VAL 0x000001ff
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_RMASK_VAL 0x000001ff
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_WMASK_VAL 0x000001ff
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_EN_POS 0
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_SKIP_CNT_MASK 0x000001fe
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_SKIP_CNT_SIZE 8
#define IAXXX_CNR_PCTRL_LPX_CLK_SC_SKIP_CNT_DECL (8:1)

/*** CNR_PD0_LPX_CLK_CG (0x40001074) ***/
/*
 * Clock Gate for pd0_lpx_clk. Disabling this gate stops clock supply to PD0.
 * This clock is sourced from lpx_clk
 */
#define IAXXX_CNR_PD0_LPX_CLK_CG_ADDR (0x40001074)
#define IAXXX_CNR_PD0_LPX_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR_PD0_LPX_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR_PD0_LPX_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR_PD0_LPX_CLK_CG_RESET_VAL 0x00000000

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PD0_LPX_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PD0_LPX_CLK_CG_EN_RESET_VAL 0x0
#define IAXXX_CNR_PD0_LPX_CLK_CG_EN_POS 0
#define IAXXX_CNR_PD0_LPX_CLK_CG_EN_SIZE 1
#define IAXXX_CNR_PD0_LPX_CLK_CG_EN_DECL 0

/*** CNR_PD4_LPX_CLK_HW_CG (0x40001078) ***/
/*
 * Hardware Controlled enable for HMDP clock. This clock is sourced from
 * lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) Inbound transactions + 16 additional clocks
 * for inbound completion b) Access to PD4 registers (MAC/PAC/MSW) c) Access
 * to HMD debug registers d) Unmasked interrupt detected by PCTRL e)
 * Processor not issuing Tieq Pop request when not in WAITI f) Audio Fabric
 * requesting for clock when processor is not in waiti g) Clock Stretch
 * request
 */
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_ADDR (0x40001078)
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PD4_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_PD5_LPX_CLK_HW_CG (0x4000107c) ***/
/*
 * Hardware Controlled enable for DMX clock. This clock is sourced from
 * lpx_clk. It is required to set OVERRIDE during PD5 power-up/reset
 * sequence. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) Inbound transactions + 16 additional clocks
 * for inbound completion b) Access to PD5 registers (MAC/PAC/MSW) c) Access
 * to DMX debug registers d) Unmasked interrupt detected by PCTRL e)
 * Processor not issuing Tieq Pop request when not in WAITI f) Audio Fabric
 * requesting for clock when processor is not in waiti g) Clock Stretch
 * request
 */
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_ADDR (0x4000107c)
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_RESET_VAL 0x00000003

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x1
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PD5_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_PD7_LPX_CLK_HW_CG (0x40001080) ***/
/*
 * Hardware Controlled enable for pd7_ahb_lpx_clk. This clock is sourced from
 * lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) Any of AHB masters accessing PD7 registers b)
 * SPI requesting APB clock (either using spi_apb_clk_req_apb_o or
 * spi_apb_clk_req_samp_o, please refer SPI IP documentation for conditions
 * that cause SPI APB clock request) c) UART requesting APB clock using
 * uart_lp_req_pclk d) CG bit for any I2C is set in CNR7 e) ArdBeg Ineterrupt
 * clock is enabled
 */
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_ADDR (0x40001080)
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PD7_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_PD8_LPX_CLK_HW_CG (0x40001084) ***/
/*
 * Hardware Controlled enable for pd8_ahb_lpx_clk. On POR, OVERRIDE is set
 * because of fail-safe. This clock is sourced from lpx_clk. It is required
 * to clear the OVERRIDE after successful boot-up. It may be required to set
 * OVERRIDE for debug by debugger.<br><br>When EN = 0, Clock will be cut
 * regardless of Hardware Control and HW_OVRD configuration<br>When EN = 1,
 * Clock will be supplied based on the Hardware Control
 * condition<br><br>NOTE:<br>DO NOT SET HW_OVRD = 1 or Modify EN Bit unless
 * suggested by VLSI<br>For cases, where HW_OVRD = 1 on Reset, SW is supposed
 * to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) Outbound traffic from any AHB master
 * (Outbounds of HMD, DMX or DMA) b) Any of AHB masters accessing PD8
 * registers c) PD8 debug clock is enabled d) Clock Stretch request
 */
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_ADDR (0x40001084)
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_RESET_VAL 0x00000003

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x1
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PD8_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_PWRC_APB_LPX_CLK_HW_CG (0x40001088) ***/
/*
 * Hardware Controlled enable for pwrc_apb_lpx_clk. This clock is sourced
 * from lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PWRC APB registers
 */
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_ADDR (0x40001088)
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_PWRC_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_SPI_SAMP_X_CLK_IDI (0x4000108c) ***/
/*
 * SPI Sample clock is sourced from x_clk. The clocks are of 50% duty cycle.
 * Divide SPI clock by (IDI_CNT + 1)<br>Register configuration will take ((6
 * to 7) * (register_clock_frequency / gate_source_clock_frequency)) clock
 * periods to become effective
 */
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_ADDR (0x4000108c)
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_MASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_RMASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_WMASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_RESET_VAL 0x00000000

/*
 * Enable for IDI Counter
 */
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_EN_MASK 0x00000001
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_EN_RESET_VAL 0x0
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_EN_POS 0
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_EN_SIZE 1
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_EN_DECL 0

/*
 * IDI Count value
 */
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_IDI_CNT_MASK 0x000003fe
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_IDI_CNT_RESET_VAL 0x0
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_IDI_CNT_POS 1
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_IDI_CNT_SIZE 9
#define IAXXX_CNR_SPI_SAMP_X_CLK_IDI_IDI_CNT_DECL (9:1)

/*** CNR_STMR_A_CLK_SC (0x40001090) ***/
/*
 * Control Sensor Interrupt Timer (STMR) Clock. stmr_a_clk is sourced from
 * a_clk_nr.<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_STMR_A_CLK_SC_ADDR (0x40001090)
#define IAXXX_CNR_STMR_A_CLK_SC_MASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_A_CLK_SC_RMASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_A_CLK_SC_WMASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_A_CLK_SC_RESET_VAL 0x00000000

/*
 * Enable for Skip Counter
 */
#define IAXXX_CNR_STMR_A_CLK_SC_EN_MASK 0x00000001
#define IAXXX_CNR_STMR_A_CLK_SC_EN_RESET_VAL 0x0
#define IAXXX_CNR_STMR_A_CLK_SC_EN_POS 0
#define IAXXX_CNR_STMR_A_CLK_SC_EN_SIZE 1
#define IAXXX_CNR_STMR_A_CLK_SC_EN_DECL 0

/*
 * Skip Count value
 */
#define IAXXX_CNR_STMR_A_CLK_SC_SKIP_CNT_MASK 0x000007fe
#define IAXXX_CNR_STMR_A_CLK_SC_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_STMR_A_CLK_SC_SKIP_CNT_POS 1
#define IAXXX_CNR_STMR_A_CLK_SC_SKIP_CNT_SIZE 10
#define IAXXX_CNR_STMR_A_CLK_SC_SKIP_CNT_DECL (10:1)

/*** CNR_STMR_APB_LPX_CLK_HW_CG (0x40001094) ***/
/*
 * Hardware Controlled enable for stmr_apb_lpx_clk. This clock is sourced
 * from lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access STMR APB registers
 */
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_ADDR (0x40001094)
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_CNR_STMR_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** CNR_SYS_CLK_CG (0x40001098) ***/
/*
 * Clock Gate for sys_clk. Disabling this gate stops clock supply to System
 * Control Block. DO NOT set this bit to Zero unless SCTRL block is not
 * used<br>Register configuration will take ((6 to 7) *
 * (register_clock_frequency / gate_source_clock_frequency)) clock periods to
 * become effective
 */
#define IAXXX_CNR_SYS_CLK_CG_ADDR (0x40001098)
#define IAXXX_CNR_SYS_CLK_CG_MASK_VAL 0x00000001
#define IAXXX_CNR_SYS_CLK_CG_RMASK_VAL 0x00000001
#define IAXXX_CNR_SYS_CLK_CG_WMASK_VAL 0x00000001
#define IAXXX_CNR_SYS_CLK_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_CNR_SYS_CLK_CG_EN_MASK 0x00000001
#define IAXXX_CNR_SYS_CLK_CG_EN_RESET_VAL 0x1
#define IAXXX_CNR_SYS_CLK_CG_EN_POS 0
#define IAXXX_CNR_SYS_CLK_CG_EN_SIZE 1
#define IAXXX_CNR_SYS_CLK_CG_EN_DECL 0

/*** CNR_UART_SAMP_X_CLK_NR (0x4000109c) ***/
/*
 * uart_samp_x_clk is sourced from x_clk through a N/R Divider. To calculate
 * the out_clk frequency: D = 2^(width of N field) + N - R, out_clk =
 * (N/D)*in_clk. If N/D is not an integer, the out_clk duty cycle is not
 * 50%<br>After issuing an N R update, software must wait for 1 D duration of
 * input clock period before writing new N R values. Register configuration
 * will take ((6 to 7) * (register_clock_frequency /
 * gate_source_clock_frequency)) clock periods to become effective
 */
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_ADDR (0x4000109c)
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_MASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_RESET_VAL 0x00000278

/*
 * Enable for NR Counter
 */
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_EN_MASK 0x00000001
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_EN_RESET_VAL 0x0
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_EN_POS 0
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_EN_SIZE 1
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_EN_DECL 0

/*
 * R Count value
 */
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_R_CNT_MASK 0x000001fe
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_R_CNT_RESET_VAL 0x3c
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_R_CNT_POS 1
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_R_CNT_SIZE 8
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_R_CNT_DECL (8:1)

/*
 * N Count value
 */
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_N_CNT_MASK 0x0000fe00
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_N_CNT_RESET_VAL 0x1
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_N_CNT_POS 9
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_N_CNT_SIZE 7
#define IAXXX_CNR_UART_SAMP_X_CLK_NR_N_CNT_DECL (15:9)

/*** CNR_X_CLK_MUX (0x400010a0) ***/
/*
 * Control to switch between MPLL, APLL and OSC as the source of x_clk. This
 * is a Glitchless MUX.
 */
#define IAXXX_CNR_X_CLK_MUX_ADDR (0x400010a0)
#define IAXXX_CNR_X_CLK_MUX_MASK_VAL 0x00000007
#define IAXXX_CNR_X_CLK_MUX_RMASK_VAL 0x00000007
#define IAXXX_CNR_X_CLK_MUX_WMASK_VAL 0x00000007
#define IAXXX_CNR_X_CLK_MUX_RESET_VAL 0x00000001

/*
 * One-hot encoded MUX Select <br>0x1: mpll_clk_out_o<br>0x2:
 * apll_clk_out_o<br>0x4: osc_clk_divd_byp_pll_o<br>
 * This field should not be programmed to the following illegal values:
 *   0x0
 *   0x3
 *   0x5
 *   0x6
 *   0x7
 */
#define IAXXX_CNR_X_CLK_MUX_SEL_MASK 0x00000007
#define IAXXX_CNR_X_CLK_MUX_SEL_RESET_VAL 0x1
#define IAXXX_CNR_X_CLK_MUX_SEL_POS 0
#define IAXXX_CNR_X_CLK_MUX_SEL_SIZE 3
#define IAXXX_CNR_X_CLK_MUX_SEL_DECL (2:0)

/*** CNR_SYS_CLK_SRC_SEL (0x400010a4) ***/
/*
 * Software control for selecting source of sys clock
 */
#define IAXXX_CNR_SYS_CLK_SRC_SEL_ADDR (0x400010a4)
#define IAXXX_CNR_SYS_CLK_SRC_SEL_MASK_VAL 0x00000003
#define IAXXX_CNR_SYS_CLK_SRC_SEL_RMASK_VAL 0x00000003
#define IAXXX_CNR_SYS_CLK_SRC_SEL_WMASK_VAL 0x00000003
#define IAXXX_CNR_SYS_CLK_SRC_SEL_RESET_VAL 0x00000000

/*
 * 0: LOR determines which of the CLK_IN or divided OSC clock is used for
 * SCTRL clock for boot up.
 * 1: When it is set to be 1 SYS_CLK_SRC_SEL in this register determines
 * which of the CLK_IN or divided OSC clock is used for SCTRL clock for boot
 * up.
 */
#define IAXXX_CNR_SYS_CLK_SRC_SEL_LOR_OVRRD_MASK 0x00000001
#define IAXXX_CNR_SYS_CLK_SRC_SEL_LOR_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_SYS_CLK_SRC_SEL_LOR_OVRRD_POS 0
#define IAXXX_CNR_SYS_CLK_SRC_SEL_LOR_OVRRD_SIZE 1
#define IAXXX_CNR_SYS_CLK_SRC_SEL_LOR_OVRRD_DECL 0

/*
 * This bit only takes effect when LOR_OVRRD is set to 1.Selected clock goes
 * to SCTRL for booting.
 * 0: Select divided down OSC clock as sys_clk.
 * 1: Select CLK_IN from PAD as sys_clk.
 */
#define IAXXX_CNR_SYS_CLK_SRC_SEL_SYS_CLK_SEL_MASK 0x00000002
#define IAXXX_CNR_SYS_CLK_SRC_SEL_SYS_CLK_SEL_RESET_VAL 0x0
#define IAXXX_CNR_SYS_CLK_SRC_SEL_SYS_CLK_SEL_POS 1
#define IAXXX_CNR_SYS_CLK_SRC_SEL_SYS_CLK_SEL_SIZE 1
#define IAXXX_CNR_SYS_CLK_SRC_SEL_SYS_CLK_SEL_DECL 1

/*** CNR_CCAL_CTRL (0x400010a8) ***/
/*
 */
#define IAXXX_CNR_CCAL_CTRL_ADDR (0x400010a8)
#define IAXXX_CNR_CCAL_CTRL_MASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_RMASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_WMASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_RESET_VAL 0x00000000

/*
 * Request read from hardware counter 0. Captures snapshot of incrementing
 * counter value at the closest clock edge after this bit is asserted.  Leave
 * asserted until <a
 * href="#D4080.CNR.CCAL_STS.RD_ACK0">CNR:CCAL_STS.RD_ACK0</a> is observed
 * equal to '1'; then software can safely read register <a
 * href="#D4080.CNR.CCAL_CNTR0">CNR:CCAL_CNTR0</a>.
 */
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_MASK 0x00000001
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_POS 0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_DECL 0

/*
 * Load value of counter 0 from <a
 * href="#D4080.CNR.CCAL_INIT">CNR:CCAL_INIT.VAL</a>.  Leave asserted until
 * <a href="#D4080.CNR.CCAL_STS.LOAD_ACK0">CNR:CCAL_STS.LOAD_ACK0</a> is
 * observed equal to '1'.
 */
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_MASK 0x00000002
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_POS 1
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_DECL 1

/*
 * Enables counter 0 to increment.  When bit <a
 * href="#D4080.CNR.CCAL_STS.INCR_ACK0">CNR:CCAL_STS.INCR_ACK0</a> is
 * observed equal to '1', counter has started incrementing.
 */
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_MASK 0x00000004
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_POS 2
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_DECL 2

/*
 * Request read from hardware counter 1. Captures snapshot of incrementing
 * counter value at the closest clock edge after this bit is asserted.  Leave
 * asserted until <a
 * href="#D4080.CNR.CCAL_STS.RD_ACK1">CNR:CCAL_STS.RD_ACK1</a> is observed
 * equal to '1'; then software can safely read register <a
 * href="#D4080.CNR.CCAL_CNTR1">CNR:CCAL_CNTR1</a>.
 */
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_MASK 0x00000010
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_POS 4
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_DECL 4

/*
 * Load value of counter 1 from <a
 * href="#D4080.CNR.CCAL_INIT">CNR:CCAL_INIT.VAL</a>.  Leave asserted until
 * <a href="#D4080.CNR.CCAL_STS.LOAD_ACK1">CNR:CCAL_STS.LOAD_ACK1</a> is
 * observed equal to '1'.
 */
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_MASK 0x00000020
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_POS 5
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_DECL 5

/*
 * Enables counter 1 to increment.  When bit <a
 * href="#D4080.CNR.CCAL_STS.INCR_ACK1">CNR:CCAL_STS.INCR_ACK1</a> is
 * observed equal to '1', counter has started incrementing.
 */
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_MASK 0x00000040
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_POS 6
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_SIZE 1
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_DECL 6

/*** CNR_CCAL_CFG (0x400010ac) ***/
/*
 */
#define IAXXX_CNR_CCAL_CFG_ADDR (0x400010ac)
#define IAXXX_CNR_CCAL_CFG_MASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_RMASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_WMASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_RESET_VAL 0x00000000

/*
 * Synchronize control signals to Counter 1 to the clock 0 domain before
 * synchronizing them to the clock 1 domain.  This ensures that Counter 1
 * measurements start on the closest rising edge of clock 1 after clock 0;
 * this minimizes the difference between Counter 1 and Counter 0 measurement
 * windows.  Assert this bit for frequency measurements if clock 0 is 1/2 or
 * less of the frequency of clock 1.  Otherwise, leave this bit set to '0'.
 */
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_MASK 0x00000001
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_POS 0
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_SIZE 1
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_DECL 0

/*** CNR_CCAL_STS (0x400010b0) ***/
/*
 */
#define IAXXX_CNR_CCAL_STS_ADDR (0x400010b0)
#define IAXXX_CNR_CCAL_STS_MASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_RMASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_WMASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_RESET_VAL 0x00000000

/*
 * Read acknowledge: if this bit is asserted, can safely read register <a
 * href="#D4080.CNR.CCAL_CNTR0">CNR:CCAL_CNTR0</a>.  Then software should set
 * bit <a href="#D4080.CNR.CCAL_CTRL.RD_REQ0">CNR:CCAL_CTRL.RD_REQ0</a> back
 * to 0, completing read request.
 */
#define IAXXX_CNR_CCAL_STS_RD_ACK0_MASK 0x00000001
#define IAXXX_CNR_CCAL_STS_RD_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_RD_ACK0_POS 0
#define IAXXX_CNR_CCAL_STS_RD_ACK0_SIZE 1
#define IAXXX_CNR_CCAL_STS_RD_ACK0_DECL 0

/*
 * Load acknowledged.  If asserted, can set <a
 * href="#D4080.CNR.CCAL_CTRL.LOAD_REQ0">CNR:CCAL_CTRL.LOAD_REQ0</a> back to
 * 0.
 */
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_MASK 0x00000002
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_POS 1
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_SIZE 1
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_DECL 1

/*
 * Increment acknowledged.  If asserted, can set <a
 * href="#D4080.CNR.CCAL_CTRL.INCR_REQ0">CNR:CCAL_CTRL.INCR_REQ0</a> back to
 * 0 when desired to stop counting.
 */
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_MASK 0x00000004
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_POS 2
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_SIZE 1
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_DECL 2

/*
 * Read acknowledge: if this bit is asserted, can safely read register <a
 * href="#D4080.CNR.CCAL_CNTR1">CNR:CCAL_CNTR1</a>.  Then software should set
 * bit <a href="#D4080.CNR.CCAL_CTRL.RD_REQ1">CNR:CCAL_CTRL.RD_REQ1</a> back
 * to 0, completing read request.
 */
#define IAXXX_CNR_CCAL_STS_RD_ACK1_MASK 0x00000010
#define IAXXX_CNR_CCAL_STS_RD_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_RD_ACK1_POS 4
#define IAXXX_CNR_CCAL_STS_RD_ACK1_SIZE 1
#define IAXXX_CNR_CCAL_STS_RD_ACK1_DECL 4

/*
 * Load acknowledged.  If asserted, can set <a
 * href="#D4080.CNR.CCAL_CTRL.LOAD_REQ1">CNR:CCAL_CTRL.LOAD_REQ1</a> back to
 * 0.
 */
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_MASK 0x00000020
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_POS 5
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_SIZE 1
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_DECL 5

/*
 * Increment acknowledged.  If asserted, can set <a
 * href="#D4080.CNR.CCAL_CTRL.INCR_REQ1">CNR:CCAL_CTRL.INCR_REQ1</a> back to
 * 0 when desired to stop counting.
 */
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_MASK 0x00000040
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_POS 6
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_SIZE 1
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_DECL 6

/*
 * Hardware counter 0 overflowed and restarted.  Condition is sticky: write
 * '1' to clear bit.
 */
#define IAXXX_CNR_CCAL_STS_OVRFLW0_MASK 0x00000100
#define IAXXX_CNR_CCAL_STS_OVRFLW0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_OVRFLW0_POS 8
#define IAXXX_CNR_CCAL_STS_OVRFLW0_SIZE 1
#define IAXXX_CNR_CCAL_STS_OVRFLW0_DECL 8

/*
 * Hardware counter 1 overflowed and restarted.  Condition is sticky: write
 * '1' to clear bit.
 */
#define IAXXX_CNR_CCAL_STS_OVRFLW1_MASK 0x00000200
#define IAXXX_CNR_CCAL_STS_OVRFLW1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_OVRFLW1_POS 9
#define IAXXX_CNR_CCAL_STS_OVRFLW1_SIZE 1
#define IAXXX_CNR_CCAL_STS_OVRFLW1_DECL 9

/*** CNR_CCAL_INIT (0x400010b4) ***/
/*
 */
#define IAXXX_CNR_CCAL_INIT_ADDR (0x400010b4)
#define IAXXX_CNR_CCAL_INIT_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_WMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_RESET_VAL 0x00000000

/*
 * Initial value to be used to initialize either hardware counter 0 or 1.
 * Load this value into the counters 0 and 1 respectively using the bits <a
 * href="#D4080.CNR.CCAL_CTRL.LOAD_REQ0">CNR:CCAL_CTRL.LOAD_REQ0</a> and <a
 * href="#D4080.CNR.CCAL_CTRL.LOAD_REQ1">CNR:CCAL_CTRL.LOAD_REQ1</a>.
 */
#define IAXXX_CNR_CCAL_INIT_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_INIT_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_INIT_VAL_POS 0
#define IAXXX_CNR_CCAL_INIT_VAL_SIZE 22
#define IAXXX_CNR_CCAL_INIT_VAL_DECL (21:0)

/*** CNR_CCAL_CNTR0 (0x400010b8) ***/
/*
 * During a measurement, hardware counts clock cycles on clock 0.  This
 * register reflects this buffered final count value; the counter itself may
 * be reinitialized and conduct another measurement while this value is being
 * read.    The accuracy is +/-1 reference clock cycle.
 */
#define IAXXX_CNR_CCAL_CNTR0_ADDR (0x400010b8)
#define IAXXX_CNR_CCAL_CNTR0_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_WMASK_VAL 0x00000000
#define IAXXX_CNR_CCAL_CNTR0_RESET_VAL 0x00000000

/*
 * Final value for counter 0 after a measurement.  Counter wraps after
 * maximium count 0X3F_FFFF.
 */
#define IAXXX_CNR_CCAL_CNTR0_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CNTR0_VAL_POS 0
#define IAXXX_CNR_CCAL_CNTR0_VAL_SIZE 22
#define IAXXX_CNR_CCAL_CNTR0_VAL_DECL (21:0)

/*** CNR_CCAL_CNTR1 (0x400010bc) ***/
/*
 * During a measurement, hardware counts clock cycles on clock 1.  This
 * register reflects this buffered final count value; the counter itself may
 * be reinitialized and conduct another measurement while this value is being
 * read.    The accuracy is +/-1 reference clock cycle.
 */
#define IAXXX_CNR_CCAL_CNTR1_ADDR (0x400010bc)
#define IAXXX_CNR_CCAL_CNTR1_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_WMASK_VAL 0x00000000
#define IAXXX_CNR_CCAL_CNTR1_RESET_VAL 0x00000000

/*
 * Final value for counter 1 after a measurement.  Counter wraps after
 * maximium count 0X3F_FFFF.
 */
#define IAXXX_CNR_CCAL_CNTR1_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CNTR1_VAL_POS 0
#define IAXXX_CNR_CCAL_CNTR1_VAL_SIZE 22
#define IAXXX_CNR_CCAL_CNTR1_VAL_DECL (21:0)

/*** CNR_PROC_WAITI_STS (0x400010c0) ***/
/*
 */
#define IAXXX_CNR_PROC_WAITI_STS_ADDR (0x400010c0)
#define IAXXX_CNR_PROC_WAITI_STS_MASK_VAL 0x00000030
#define IAXXX_CNR_PROC_WAITI_STS_RMASK_VAL 0x00000030
#define IAXXX_CNR_PROC_WAITI_STS_WMASK_VAL 0x00000000
#define IAXXX_CNR_PROC_WAITI_STS_RESET_VAL 0x00000000

/*
 * if this bit is asserted, HMD is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_MASK 0x00000010
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_POS 4
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_SIZE 1
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_DECL 4

/*
 * if this bit is asserted, DMX is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_MASK 0x00000020
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_POS 5
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_SIZE 1
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_DECL 5

/*** CNR_STMR_GEN_RESET (0x400010c4) ***/
/*
 * Selection and enable of STMR signals used to reset CM4/HMD/DMX.
 */
#define IAXXX_CNR_STMR_GEN_RESET_ADDR (0x400010c4)
#define IAXXX_CNR_STMR_GEN_RESET_MASK_VAL 0x00000fc0
#define IAXXX_CNR_STMR_GEN_RESET_RMASK_VAL 0x00000fc0
#define IAXXX_CNR_STMR_GEN_RESET_WMASK_VAL 0x00000fc0
#define IAXXX_CNR_STMR_GEN_RESET_RESET_VAL 0x00000000

/*
 * 0: Signal to reset HMD from timer 0 is selected.
 * 1: Signal to reset HMD from timer 1 is selected
 * 2: Signal to reset HMD from timer 2 is selected
 * 3: Signal to reset HMD from timer 3 is selected
 */
#define IAXXX_CNR_STMR_GEN_RESET_HMD_SEL_MASK 0x000000c0
#define IAXXX_CNR_STMR_GEN_RESET_HMD_SEL_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_HMD_SEL_POS 6
#define IAXXX_CNR_STMR_GEN_RESET_HMD_SEL_SIZE 2
#define IAXXX_CNR_STMR_GEN_RESET_HMD_SEL_DECL (7:6)

/*
 * 0/1: Signal to reset HMD is disabled/Enabled
 */
#define IAXXX_CNR_STMR_GEN_RESET_HMD_ENABLE_MASK 0x00000100
#define IAXXX_CNR_STMR_GEN_RESET_HMD_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_HMD_ENABLE_POS 8
#define IAXXX_CNR_STMR_GEN_RESET_HMD_ENABLE_SIZE 1
#define IAXXX_CNR_STMR_GEN_RESET_HMD_ENABLE_DECL 8

/*
 * 0: Signal to reset DMX from timer 0 is selected.
 * 1: Signal to reset DMX from timer 1 is selected
 * 2: Signal to reset DMX from timer 2 is selected
 * 3: Signal to reset DMX from timer 3 is selected
 */
#define IAXXX_CNR_STMR_GEN_RESET_DMX_SEL_MASK 0x00000600
#define IAXXX_CNR_STMR_GEN_RESET_DMX_SEL_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_DMX_SEL_POS 9
#define IAXXX_CNR_STMR_GEN_RESET_DMX_SEL_SIZE 2
#define IAXXX_CNR_STMR_GEN_RESET_DMX_SEL_DECL (10:9)

/*
 * 0/1: Signal to reset DMX is disabled/Enabled
 */
#define IAXXX_CNR_STMR_GEN_RESET_DMX_ENABLE_MASK 0x00000800
#define IAXXX_CNR_STMR_GEN_RESET_DMX_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_DMX_ENABLE_POS 11
#define IAXXX_CNR_STMR_GEN_RESET_DMX_ENABLE_SIZE 1
#define IAXXX_CNR_STMR_GEN_RESET_DMX_ENABLE_DECL 11

/*** CNR_PWR_DOMAIN_SOFT_RST (0x400010c8) ***/
/*
 * Power domain reset. The reset for PD3, where CM4 resides, is not in this
 * register. PD3 reset is logic control
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_ADDR (0x400010c8)
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_MASK_VAL 0x000000b1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_RMASK_VAL 0x000000b1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_WMASK_VAL 0x000000b1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_RESET_VAL 0x00000091

/*
 * Power Domain 0 soft reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_POS 0
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_SIZE 1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_DECL 0

/*
 * Power Domain 4 soft reset. It is the HMD processor and its peripheral
 * reset. DO NOT SET THIS FOR HW CONTROLLED SLEEP/WAKEUP<br><br>Software must
 * reset PD4 registers by writing into <a
 * href="#D4080.CNR.APB_REG_SOFT_RST">CNR:APB_REG_SOFT_RST.HMD_APB_REG_SOFT_RST</a>
 * before releasing Power Domain 4 soft reset for Software Power-Up Sequence
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_POS 4
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_SIZE 1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_DECL 4

/*
 * Power Domain 5 soft reset. It is the DMX processor and its peripheral
 * reset. DO NOT SET THIS FOR HW CONTROLLED SLEEP/WAKEUP<br><br>Software must
 * reset PD5 registers by writing into <a
 * href="#D4080.CNR.APB_REG_SOFT_RST">CNR:APB_REG_SOFT_RST.DMX_APB_REG_SOFT_RST</a>
 * before releasing Power Domain 5 soft reset for Software Power-Up Sequence
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_POS 5
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_SIZE 1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_DECL 5

/*
 * Power Domain 7 soft reset. It is the PD7 reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_POS 7
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_SIZE 1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_DECL 7

/*** CNR_FUNC_SOFT_RST (0x400010cc) ***/
/*
 * Reset the corresponding module, by default the modules,CCAL and STMR, are
 * kept in reset
 */
#define IAXXX_CNR_FUNC_SOFT_RST_ADDR (0x400010cc)
#define IAXXX_CNR_FUNC_SOFT_RST_MASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_RMASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_WMASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_RESET_VAL 0x00000003

/*
 * Clock Calibration reset in CNR. Before write 1 to this bit, set
 * CNR.CAL_CLK_SRC_SEL1 = 0xD and CNR.CAL_CLK_SRC_SEL2 = 0xD
 */
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_POS 0
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_SIZE 1
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_DECL 0

/*
 * Sensor timer reset.
 */
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_POS 1
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_SIZE 1
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_DECL 1

/*** CNR_APB_REG_SOFT_RST (0x400010d0) ***/
/*
 * Reset for AO module APB registers and PD APB registers
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_ADDR (0x400010d0)
#define IAXXX_CNR_APB_REG_SOFT_RST_MASK_VAL 0x000031fe
#define IAXXX_CNR_APB_REG_SOFT_RST_RMASK_VAL 0x00000000
#define IAXXX_CNR_APB_REG_SOFT_RST_WMASK_VAL 0x00000000
#define IAXXX_CNR_APB_REG_SOFT_RST_RESET_VAL 0x00000000

/*
 * Write 1 to reset AO APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_POS 1
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_DECL 1

/*
 * Write 1 to reset GPIO APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_MASK 0x00000004
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_POS 2
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_DECL 2

/*
 * Write 1 to reset all PD0 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_MASK 0x00000008
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_POS 3
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_DECL 3

/*
 * Write 1 to reset all PD7 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_POS 4
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_DECL 4

/*
 * Write 1 to reset all PD8 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_POS 5
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_DECL 5

/*
 * Write 1 to reset PWRC APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_MASK 0x00000040
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_POS 6
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_DECL 6

/*
 * Write 1 to reset STMR APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_POS 7
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_DECL 7

/*
 * Write 1 to reset PAD_CTRL APB registers only. It will always read back as
 * 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_MASK 0x00000100
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_POS 8
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_DECL 8

/*
 * Write 1 to reset all PD4 APB registers except HMD debug. HMD debug is
 * reset by  <a href="#D4080.AO.OCD">AO:OCD.HMD_DRESET</a> It will always
 * read back as 0<br><br>NOTE: PD4 hardware sleep/wake-up sequence will
 * always reset APB registers
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_MASK 0x00001000
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_POS 12
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_DECL 12

/*
 * Write 1 to reset all PD5 APB registers except DMX debug. DMX debug is
 * reset by  <a href="#D4080.AO.OCD">AO:OCD.DMX_DRESET</a> It will always
 * read back as 0<br><br>NOTE: PD5 hardware sleep/wake-up sequence will
 * always reset APB registers
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_MASK 0x00002000
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_POS 13
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_SIZE 1
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_DECL 13

/*** CNR_CD_CFG_0 (0x400010d4) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock has
 * turned OFF
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_0_ADDR (0x400010d4)
#define IAXXX_CNR_CD_CFG_0_MASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_0_RMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_0_WMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_0_RESET_VAL 0x00000000

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_ENABLE_MASK 0x000001fe
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_ENABLE_POS 1
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_ENABLE_DECL (8:1)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_MASK_MASK 0x0001fe00
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_MASK_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_MASK_POS 9
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_MASK_SIZE 8
#define IAXXX_CNR_CD_CFG_0_INTR_ON2OFF_MASK_DECL (16:9)

/*** CNR_CD_CFG_1 (0x400010d8) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock has
 * turned ON
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_1_ADDR (0x400010d8)
#define IAXXX_CNR_CD_CFG_1_MASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_1_RMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_1_WMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_1_RESET_VAL 0x00000000

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_ENABLE_MASK 0x000001fe
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_ENABLE_POS 1
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_ENABLE_DECL (8:1)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_MASK_MASK 0x0001fe00
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_MASK_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_MASK_POS 9
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_MASK_SIZE 8
#define IAXXX_CNR_CD_CFG_1_INTR_OFF2ON_MASK_DECL (16:9)

/*** CNR_CD_CFG_2 (0x400010dc) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock is ON
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_2_ADDR (0x400010dc)
#define IAXXX_CNR_CD_CFG_2_MASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_2_RMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_2_WMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_2_RESET_VAL 0x00000000

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_CD_CFG_2_INTR_ON_ENABLE_MASK 0x000001fe
#define IAXXX_CNR_CD_CFG_2_INTR_ON_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_2_INTR_ON_ENABLE_POS 1
#define IAXXX_CNR_CD_CFG_2_INTR_ON_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_2_INTR_ON_ENABLE_DECL (8:1)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_2_INTR_ON_MASK_MASK 0x0001fe00
#define IAXXX_CNR_CD_CFG_2_INTR_ON_MASK_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_2_INTR_ON_MASK_POS 9
#define IAXXX_CNR_CD_CFG_2_INTR_ON_MASK_SIZE 8
#define IAXXX_CNR_CD_CFG_2_INTR_ON_MASK_DECL (16:9)

/*** CNR_CD_CFG_3 (0x400010e0) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock is OFF
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_3_ADDR (0x400010e0)
#define IAXXX_CNR_CD_CFG_3_MASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_3_RMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_3_WMASK_VAL 0x0001fffe
#define IAXXX_CNR_CD_CFG_3_RESET_VAL 0x00000000

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_ENABLE_MASK 0x000001fe
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_ENABLE_POS 1
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_ENABLE_DECL (8:1)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_MASK_MASK 0x0001fe00
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_MASK_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_MASK_POS 9
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_MASK_SIZE 8
#define IAXXX_CNR_CD_CFG_3_INTR_OFF_MASK_DECL (16:9)

/*** CNR_CD_CFG_4 (0x400010e4) ***/
/*
 * Interrupt raw and status register for interrupts indicating that the clock
 * has turned OFF
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_4_ADDR (0x400010e4)
#define IAXXX_CNR_CD_CFG_4_MASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_4_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_4_WMASK_VAL 0x00000000
#define IAXXX_CNR_CD_CFG_4_RESET_VAL 0x00000000

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_4_INTR_OFF2ON_STATUS_MASK 0x000000ff
#define IAXXX_CNR_CD_CFG_4_INTR_OFF2ON_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_4_INTR_OFF2ON_STATUS_POS 0
#define IAXXX_CNR_CD_CFG_4_INTR_OFF2ON_STATUS_SIZE 8
#define IAXXX_CNR_CD_CFG_4_INTR_OFF2ON_STATUS_DECL (7:0)

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_4_INTR_ON2OFF_STATUS_MASK 0x0000ff00
#define IAXXX_CNR_CD_CFG_4_INTR_ON2OFF_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_4_INTR_ON2OFF_STATUS_POS 8
#define IAXXX_CNR_CD_CFG_4_INTR_ON2OFF_STATUS_SIZE 8
#define IAXXX_CNR_CD_CFG_4_INTR_ON2OFF_STATUS_DECL (15:8)

/*** CNR_CD_CFG_5 (0x400010e8) ***/
/*
 * Interrupt raw and status register for interrupts indicating that the clock
 * is ON
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_5_ADDR (0x400010e8)
#define IAXXX_CNR_CD_CFG_5_MASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_5_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_5_WMASK_VAL 0x00000000
#define IAXXX_CNR_CD_CFG_5_RESET_VAL 0x00000000

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_5_INTR_OFF_STATUS_MASK 0x000000ff
#define IAXXX_CNR_CD_CFG_5_INTR_OFF_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_5_INTR_OFF_STATUS_POS 0
#define IAXXX_CNR_CD_CFG_5_INTR_OFF_STATUS_SIZE 8
#define IAXXX_CNR_CD_CFG_5_INTR_OFF_STATUS_DECL (7:0)

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_CD_CFG_5_INTR_ON_STATUS_MASK 0x0000ff00
#define IAXXX_CNR_CD_CFG_5_INTR_ON_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_5_INTR_ON_STATUS_POS 8
#define IAXXX_CNR_CD_CFG_5_INTR_ON_STATUS_SIZE 8
#define IAXXX_CNR_CD_CFG_5_INTR_ON_STATUS_DECL (15:8)

/*** CNR_CD_CFG_6 (0x400010ec) ***/
/*
 * Interrupt raw and status register for interrupts indicating that the clock
 * has turned ON
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_6_ADDR (0x400010ec)
#define IAXXX_CNR_CD_CFG_6_MASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_6_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_6_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_6_RESET_VAL 0x00000000

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_CD_CFG_6_INTR_OFF2ON_RAW_MASK 0x000000ff
#define IAXXX_CNR_CD_CFG_6_INTR_OFF2ON_RAW_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_6_INTR_OFF2ON_RAW_POS 0
#define IAXXX_CNR_CD_CFG_6_INTR_OFF2ON_RAW_SIZE 8
#define IAXXX_CNR_CD_CFG_6_INTR_OFF2ON_RAW_DECL (7:0)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_CD_CFG_6_INTR_ON2OFF_RAW_MASK 0x0000ff00
#define IAXXX_CNR_CD_CFG_6_INTR_ON2OFF_RAW_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_6_INTR_ON2OFF_RAW_POS 8
#define IAXXX_CNR_CD_CFG_6_INTR_ON2OFF_RAW_SIZE 8
#define IAXXX_CNR_CD_CFG_6_INTR_ON2OFF_RAW_DECL (15:8)

/*** CNR_CD_CFG_7 (0x400010f0) ***/
/*
 * Interrupt raw and status register for interrupts indicating that the clock
 * is OFF
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_7_ADDR (0x400010f0)
#define IAXXX_CNR_CD_CFG_7_MASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_7_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_7_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_CD_CFG_7_RESET_VAL 0x00000000

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_CD_CFG_7_INTR_OFF_RAW_MASK 0x000000ff
#define IAXXX_CNR_CD_CFG_7_INTR_OFF_RAW_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_7_INTR_OFF_RAW_POS 0
#define IAXXX_CNR_CD_CFG_7_INTR_OFF_RAW_SIZE 8
#define IAXXX_CNR_CD_CFG_7_INTR_OFF_RAW_DECL (7:0)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_CD_CFG_7_INTR_ON_RAW_MASK 0x0000ff00
#define IAXXX_CNR_CD_CFG_7_INTR_ON_RAW_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_7_INTR_ON_RAW_POS 8
#define IAXXX_CNR_CD_CFG_7_INTR_ON_RAW_SIZE 8
#define IAXXX_CNR_CD_CFG_7_INTR_ON_RAW_DECL (15:8)

/*** CNR_CD_CFG_8 (0x400010f4) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock is OFF
 */
#define IAXXX_CNR_CD_CFG_8_ADDR (0x400010f4)
#define IAXXX_CNR_CD_CFG_8_MASK_VAL 0x0003fffe
#define IAXXX_CNR_CD_CFG_8_RMASK_VAL 0x0003fffe
#define IAXXX_CNR_CD_CFG_8_WMASK_VAL 0x0003fffe
#define IAXXX_CNR_CD_CFG_8_RESET_VAL 0x00000000

/*
 * Read and write register. This field is active high (default low). When
 * high, the clock divider for the always on clock of the CNR clock detection
 * circuit is bypassed, meaning the output clock of the divider is equal to
 * its input clock.
 */
#define IAXXX_CNR_CD_CFG_8_CNR_CD_AO_CLK_DIV_BYPASS_MASK 0x00000002
#define IAXXX_CNR_CD_CFG_8_CNR_CD_AO_CLK_DIV_BYPASS_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_8_CNR_CD_AO_CLK_DIV_BYPASS_POS 1
#define IAXXX_CNR_CD_CFG_8_CNR_CD_AO_CLK_DIV_BYPASS_SIZE 1
#define IAXXX_CNR_CD_CFG_8_CNR_CD_AO_CLK_DIV_BYPASS_DECL 1

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, the corresponding clock detection module is disabled, meaning no
 * interrupt is generated.
 * To enable the corresponding clock detection module, this bit must be set
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_8_ENABLE_MASK 0x000003fc
#define IAXXX_CNR_CD_CFG_8_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_8_ENABLE_POS 2
#define IAXXX_CNR_CD_CFG_8_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_8_ENABLE_DECL (9:2)

/*
 * Read and write register. This field is active high. It enables the
 * monitored input clock to clock the input counter and
 * must be set before the corresponding ENABLE bit.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_CFG_8_CLK_IN_ENABLE_MASK 0x0003fc00
#define IAXXX_CNR_CD_CFG_8_CLK_IN_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_CD_CFG_8_CLK_IN_ENABLE_POS 10
#define IAXXX_CNR_CD_CFG_8_CLK_IN_ENABLE_SIZE 8
#define IAXXX_CNR_CD_CFG_8_CLK_IN_ENABLE_DECL (17:10)

/*** CNR_CD_ON_OFF_0 (0x400010f8) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_0_ADDR (0x400010f8)
#define IAXXX_CNR_CD_ON_OFF_0_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_0_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_0_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_0_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_0_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_0_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_0_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_0_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_0_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_1 (0x400010fc) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_1_ADDR (0x400010fc)
#define IAXXX_CNR_CD_ON_OFF_1_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_1_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_1_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_1_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_1_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_1_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_1_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_1_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_1_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_2 (0x40001100) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_2_ADDR (0x40001100)
#define IAXXX_CNR_CD_ON_OFF_2_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_2_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_2_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_2_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_2_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_2_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_2_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_2_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_2_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_3 (0x40001104) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_3_ADDR (0x40001104)
#define IAXXX_CNR_CD_ON_OFF_3_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_3_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_3_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_3_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_3_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_3_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_3_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_3_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_3_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_4 (0x40001108) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_4_ADDR (0x40001108)
#define IAXXX_CNR_CD_ON_OFF_4_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_4_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_4_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_4_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_4_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_4_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_4_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_4_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_4_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_5 (0x4000110c) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_5_ADDR (0x4000110c)
#define IAXXX_CNR_CD_ON_OFF_5_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_5_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_5_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_5_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_5_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_5_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_5_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_5_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_5_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_6 (0x40001110) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_6_ADDR (0x40001110)
#define IAXXX_CNR_CD_ON_OFF_6_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_6_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_6_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_6_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_6_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_6_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_6_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_6_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_6_DURATION_DECL (12:1)

/*** CNR_CD_ON_OFF_7 (0x40001114) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles. The minimum value MUST
 * BE 1; a value of 0 is FORBIDDEN.
 * Bit[7]:   clk_in_i
 * Bit[(6:0)]: io_ref((6:0))_clk2cnr_i
 */
#define IAXXX_CNR_CD_ON_OFF_7_ADDR (0x40001114)
#define IAXXX_CNR_CD_ON_OFF_7_MASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_7_RMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_7_WMASK_VAL 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_7_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_CD_ON_OFF_7_DURATION_MASK 0x00001ffe
#define IAXXX_CNR_CD_ON_OFF_7_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_CD_ON_OFF_7_DURATION_POS 1
#define IAXXX_CNR_CD_ON_OFF_7_DURATION_SIZE 12
#define IAXXX_CNR_CD_ON_OFF_7_DURATION_DECL (12:1)

/*** CNR_PLL_SWITCH_CD_CFG_0 (0x40001118) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock has
 * turned OFF/ON or is ON/OFF
 * Bit[0]: mpll_clk
 * Bit[1]: osc_clk_div
 * Bit[2]: apll_clk
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_ADDR (0x40001118)
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_MASK_VAL 0x01fffffe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_RMASK_VAL 0x01fffffe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_WMASK_VAL 0x01fffffe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_RESET_VAL 0x00000000

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_ENABLE_MASK 0x0000000e
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_ENABLE_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_ENABLE_DECL (3:1)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_MASK_MASK 0x00000070
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_MASK_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_MASK_POS 4
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_MASK_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON2OFF_MASK_DECL (6:4)

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_ENABLE_MASK 0x00000380
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_ENABLE_POS 7
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_ENABLE_DECL (9:7)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_MASK_MASK 0x00001c00
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_MASK_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_MASK_POS 10
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_MASK_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF2ON_MASK_DECL (12:10)

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_ENABLE_MASK 0x0000e000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_ENABLE_POS 13
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_ENABLE_DECL (15:13)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_MASK_MASK 0x00070000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_MASK_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_MASK_POS 16
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_MASK_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_ON_MASK_DECL (18:16)

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, no interrupt is generated and the corresponding raw and status
 * bit will not be set. For an interrupt to be generated, this field must be
 * high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_ENABLE_MASK 0x00380000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_ENABLE_POS 19
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_ENABLE_DECL (21:19)

/*
 * Read and write register. The MASK field is active high meaning that if the
 * correspponding ENABLE field is high and an interrupt is generated, the
 * corresponding raw status bit will be set but the corresponding status bit
 * will remain low and the interrupt will not be forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_MASK_MASK 0x01c00000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_MASK_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_MASK_POS 22
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_MASK_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_0_INTR_OFF_MASK_DECL (24:22)

/*** CNR_PLL_SWITCH_CD_CFG_1 (0x4000111c) ***/
/*
 * Interrupt mask and enable for interrupts indicating that the clock is OFF
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ADDR (0x4000111c)
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_MASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_RMASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_WMASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_RESET_VAL 0x00000000

/*
 * Read and write register. This field is active high (default low). When
 * high, the clock divider for the always on clock of the CNR clock detection
 * circuit is bypassed, meaning the output clock of the divider is equal to
 * its input clock.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CNR_CD_AO_CLK_DIV_BYPASS_MASK 0x00000002
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CNR_CD_AO_CLK_DIV_BYPASS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CNR_CD_AO_CLK_DIV_BYPASS_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CNR_CD_AO_CLK_DIV_BYPASS_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CNR_CD_AO_CLK_DIV_BYPASS_DECL 1

/*
 * Read and write register. The ENABLE field is active high (default low).
 * When low, the corresponding clock detection module is disabled, meaning no
 * interrupt is generated.
 * To enable the corresponding clock detection module, this bit must be set
 * Bit[0]: mpll_clk
 * Bit[1]: osc_clk_div
 * Bit[2]: apll_clk
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ENABLE_MASK 0x0000001c
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ENABLE_POS 2
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_ENABLE_DECL (4:2)

/*
 * Read and write register. This field is active high. It enables the
 * monitored input clock to clock the input counter and
 * must be set before the corresponding ENABLE bit.
 * Bit[0]: mpll_clk
 * Bit[1]: osc_clk_div
 * Bit[2]: apll_clk
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CLK_IN_ENABLE_MASK 0x000000e0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CLK_IN_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CLK_IN_ENABLE_POS 5
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CLK_IN_ENABLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_1_CLK_IN_ENABLE_DECL (7:5)

/*** CNR_PLL_SWITCH_CD_CFG_2 (0x40001120) ***/
/*
 * Interrupt raw and status register for interrupts indicating that the clock
 * has turned OFF
 * Bit[0]: mpll_clk
 * Bit[1]: osc_clk_div
 * Bit[2]: apll_clk
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_ADDR (0x40001120)
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_MASK_VAL 0x00ffffff
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_RMASK_VAL 0x00ffffff
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_WMASK_VAL 0x00fff000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_RESET_VAL 0x00000000

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_STATUS_MASK 0x00000007
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_STATUS_POS 0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_STATUS_DECL (2:0)

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_STATUS_MASK 0x00000038
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_STATUS_POS 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_STATUS_DECL (5:3)

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_STATUS_MASK 0x000001c0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_STATUS_POS 6
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_STATUS_DECL (8:6)

/*
 * Read only register. Indicates the STATUS of the interrupt. This field is
 * the combination of the RAW and MASK registers. When an interrupt is
 * generated:
 * - If the corresponding MASK is high or the corresponding ENABLE bit is low
 * the corresponding STATUS bit will remain low
 * - If the corresponding MASK is low and the corresponding ENABLE bit is
 * high the corresponding STATUS will be set and the interrupt will be
 * forwarded to the CPUs.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_STATUS_MASK 0x00000e00
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_STATUS_POS 9
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_STATUS_DECL (11:9)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_RAW_MASK 0x00007000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_RAW_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_RAW_POS 12
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_RAW_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF2ON_RAW_DECL (14:12)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_RAW_MASK 0x00038000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_RAW_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_RAW_POS 15
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_RAW_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON2OFF_RAW_DECL (17:15)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_RAW_MASK 0x001c0000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_RAW_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_RAW_POS 18
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_RAW_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_OFF_RAW_DECL (20:18)

/*
 * Read only register; writing a 1 will reset the corresponding bit. This
 * register is set by the hardware when an interrupt is generated as long as
 * the corresponding ENABLE bit is set. This field indicates the RAW STATUS
 * of the interrupt. If the corresponding ENABLE bit is low, the RAW STATUS
 * for that bit will remain low
 */
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_RAW_MASK 0x00e00000
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_RAW_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_RAW_POS 21
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_RAW_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_CFG_2_INTR_ON_RAW_DECL (23:21)

/*** CNR_PLL_SWITCH_CD_ON_OFF_0 (0x40001124) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles for the clock detector
 * circuit monitoring the output clock of the MPLL. The minimum value MUST BE
 * 1; a value of 0 is FORBIDDEN.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_ADDR (0x40001124)
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_MASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_RMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_WMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_DURATION_MASK 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_DURATION_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_DURATION_SIZE 8
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_0_DURATION_DECL (8:1)

/*** CNR_PLL_SWITCH_CD_ON_OFF_1 (0x40001128) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles for the clock detector
 * circuit monitoring the output clock of the derived version of the
 * Oscillator. The minimum value MUST BE 1; a value of 0 is FORBIDDEN.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_ADDR (0x40001128)
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_MASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_RMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_WMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_DURATION_MASK 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_DURATION_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_DURATION_SIZE 8
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_1_DURATION_DECL (8:1)

/*** CNR_PLL_SWITCH_CD_ON_OFF_2 (0x4000112c) ***/
/*
 * ON/OFF duration: Number of always-on clock cycles for the clock detector
 * circuit monitoring the output clock of the APLL. The minimum value MUST BE
 * 1; a value of 0 is FORBIDDEN.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_ADDR (0x4000112c)
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_MASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_RMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_WMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_RESET_VAL 0x00000002

/*
 */
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_DURATION_MASK 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_DURATION_RESET_VAL 0x1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_DURATION_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_DURATION_SIZE 8
#define IAXXX_CNR_PLL_SWITCH_CD_ON_OFF_2_DURATION_DECL (8:1)

/*** CNR_PLL_SWITCH_CFG (0x40001130) ***/
/*
 * This register is used to configure the clock switch circuitry
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_ADDR (0x40001130)
#define IAXXX_CNR_PLL_SWITCH_CFG_MASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CFG_RMASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CFG_WMASK_VAL 0x000000fe
#define IAXXX_CNR_PLL_SWITCH_CFG_RESET_VAL 0x00000000

/*
 * This register is for the SW to select which clock to switch to in case the
 * current clock goes away.
 * This is to select the clock that sources "X_CLK".
 * 2'b00: Selects the MPLL output clock as the clock to switch to
 * 2'b01: Selects the derived version of the oscillator output clock as the
 * clock to switch to
 * 2'b10: Selects the APLL output clock as the clock to switch to
 * 2'b11: Selects the MPLL output clock as the clock to switch to
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_SEL_MASK 0x00000006
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_SEL_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_SEL_POS 1
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_SEL_SIZE 2
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_SEL_DECL (2:1)

/*
 * Enable the the clock switching providing a running clock to the X_CLK
 * clock root, active high (default low).
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_ENABLE_MASK 0x00000008
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_ENABLE_POS 3
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_ENABLE_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_CFG_MPLL_SWITCH_ENABLE_DECL 3

/*
 * This register is for the SW to select which clock to switch to in case the
 * current clock goes away.
 * This is to select the clock that sources "A_CLK".
 * 2'b00: Selects the APLL output clock as the clock to switch to
 * 2'b01: Selects the derived version of the oscillator output clock as the
 * clock to switch to
 * 2'b10: Selects the MPLL output clock as the clock to switch to
 * 2'b11: Selects the APLL output clock as the clock to switch to
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_SEL_MASK 0x00000030
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_SEL_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_SEL_POS 4
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_SEL_SIZE 2
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_SEL_DECL (5:4)

/*
 * Enable the the clock switching providing a running clock to the A_CLK
 * clock root, active high (default low).
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_ENABLE_MASK 0x00000040
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_ENABLE_POS 6
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_ENABLE_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_CFG_APLL_SWITCH_ENABLE_DECL 6

/*
 * Active high, enable the clock switching circuit to turn on the oscillator
 * if needed. Default low.
 */
#define IAXXX_CNR_PLL_SWITCH_CFG_TURN_ON_OSC_ENABLE_MASK 0x00000080
#define IAXXX_CNR_PLL_SWITCH_CFG_TURN_ON_OSC_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CFG_TURN_ON_OSC_ENABLE_POS 7
#define IAXXX_CNR_PLL_SWITCH_CFG_TURN_ON_OSC_ENABLE_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_CFG_TURN_ON_OSC_ENABLE_DECL 7

/*** CNR_PLL_SWITCH_CD_STATE (0x40001134) ***/
/*
 * Provide the state of the clock being monitored by the clock detection
 * module: IDLE (clock detector is idle, i.e. not enabled, ON (clock is on),
 * OFF (clock is off)
 */
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ADDR (0x40001134)
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_MASK_VAL 0x000003fe
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_RMASK_VAL 0x000003fe
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_WMASK_VAL 0x00000000
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_RESET_VAL 0x0000000e

/*
 * The clock detector is in idle state meaning it nhas not been enabled:
 * bit[0]: clock detector monitoring output clock of the MPLL
 * bit[1]: clock detector monitoring output clock of a divided version of the
 * Oscillator
 * bit[2]: clock detector monitoring output clock of the APLL
 */
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_IDLE_MASK 0x0000000e
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_IDLE_RESET_VAL 0x7
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_IDLE_POS 1
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_IDLE_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_IDLE_DECL (3:1)

/*
 * Indicates that the clock being monitored is ON:
 * bit[0]: Indicates that the output clock of the MPLL is ON, active high.
 * bit[1]: Indicates that the output clock of a divided version of the
 * Oscillator is ON, active high.
 * bit[2]: Indicates that the output clock of the APLL is ON, active high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ON_MASK 0x00000070
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ON_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ON_POS 4
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ON_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_ON_DECL (6:4)

/*
 * Indicates that the clock being monitored is OFF:
 * bit[0]: Indicates that the output clock of the MPLL is OFF, active high.
 * bit[1]: Indicates that the output clock of a divided version of the
 * Oscillator is OFF, active high.
 * bit[2]: Indicates that the output clock of the APLL is OFF, active high.
 */
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_OFF_MASK 0x00000380
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_OFF_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_OFF_POS 7
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_OFF_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_CD_STATE_OFF_DECL (9:7)

/*** CNR_PLL_SWITCH_STATUS (0x40001138) ***/
/*
 * This register provides the status of the clock switching circuitry for the
 * X_CLK and A_CLK clock roots
 */
#define IAXXX_CNR_PLL_SWITCH_STATUS_ADDR (0x40001138)
#define IAXXX_CNR_PLL_SWITCH_STATUS_MASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_STATUS_RMASK_VAL 0x000001fe
#define IAXXX_CNR_PLL_SWITCH_STATUS_WMASK_VAL 0x00000000
#define IAXXX_CNR_PLL_SWITCH_STATUS_RESET_VAL 0x00000000

/*
 * Indicates if a clock switching has been performed, active high
 */
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_DONE_MASK 0x00000002
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_DONE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_DONE_POS 1
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_DONE_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_DONE_DECL 1

/*
 * Indicates which clock the system has switched to. Valid only if a clock
 * switch has been performed.
 * 3'b001: Switched to MPLL output clock
 * 3'b010: Switched to APLL output clock
 * 3'b100: Switched to derived version of Oscillator output clock
 */
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_SEL_STATUS_MASK 0x0000001c
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_SEL_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_SEL_STATUS_POS 2
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_SEL_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_STATUS_MPLL_SWITCH_SEL_STATUS_DECL (4:2)

/*
 * Indicates if a clock switching has been performed, active high
 */
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_DONE_MASK 0x00000020
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_DONE_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_DONE_POS 5
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_DONE_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_DONE_DECL 5

/*
 * Indicates which clock the system has switched to. Valid only if a clock
 * switch has been performed.
 * 3'b001: Switched to APLL output clock
 * 3'b010: Switched to MPLL output clock
 * 3'b100: Switched to derived version of Oscillator output clock
 */
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_SEL_STATUS_MASK 0x000001c0
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_SEL_STATUS_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_SEL_STATUS_POS 6
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_SEL_STATUS_SIZE 3
#define IAXXX_CNR_PLL_SWITCH_STATUS_APLL_SWITCH_SEL_STATUS_DECL (8:6)

/*** CNR_PLL_SWITCH_RESET (0x4000113c) ***/
/*
 * This register is used to configure the clock switch circuitry
 */
#define IAXXX_CNR_PLL_SWITCH_RESET_ADDR (0x4000113c)
#define IAXXX_CNR_PLL_SWITCH_RESET_MASK_VAL 0x00000006
#define IAXXX_CNR_PLL_SWITCH_RESET_RMASK_VAL 0x00000006
#define IAXXX_CNR_PLL_SWITCH_RESET_WMASK_VAL 0x00000006
#define IAXXX_CNR_PLL_SWITCH_RESET_RESET_VAL 0x00000000

/*
 * Writing a 1 will reset and keep in reset the clock switching circuit
 * providing the "X_CLK" clock root.
 * Writing a 0 will release the reset of the clock switching circuit.
 */
#define IAXXX_CNR_PLL_SWITCH_RESET_MPLL_MUX_SWITCH_SEL_RST_MASK 0x00000002
#define IAXXX_CNR_PLL_SWITCH_RESET_MPLL_MUX_SWITCH_SEL_RST_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_RESET_MPLL_MUX_SWITCH_SEL_RST_POS 1
#define IAXXX_CNR_PLL_SWITCH_RESET_MPLL_MUX_SWITCH_SEL_RST_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_RESET_MPLL_MUX_SWITCH_SEL_RST_DECL 1

/*
 * Writing a 1 will reset and keep in reset the clock switching circuit
 * providing the "A_CLK" clock root.
 * Writing a 0 will release the reset of the clock switching circuit.
 */
#define IAXXX_CNR_PLL_SWITCH_RESET_APLL_MUX_SWITCH_SEL_RST_MASK 0x00000004
#define IAXXX_CNR_PLL_SWITCH_RESET_APLL_MUX_SWITCH_SEL_RST_RESET_VAL 0x0
#define IAXXX_CNR_PLL_SWITCH_RESET_APLL_MUX_SWITCH_SEL_RST_POS 2
#define IAXXX_CNR_PLL_SWITCH_RESET_APLL_MUX_SWITCH_SEL_RST_SIZE 1
#define IAXXX_CNR_PLL_SWITCH_RESET_APLL_MUX_SWITCH_SEL_RST_DECL 2

/*** CNR_ERR_PADDR (0x40001140) ***/
/*
 * This register has the address for which error is reported and caused
 * register bus to stall.
 *
 Software must follow the steps to recover
 * 1) Enable the source clock for the Clock Gate or Clock Divider that has
 * caused bus to stall
 * 2) Re-configure the Clock Gate or Clock Divider as per correct sequence
 */
#define IAXXX_CNR_ERR_PADDR_ADDR (0x40001140)
#define IAXXX_CNR_ERR_PADDR_MASK_VAL 0x00000fff
#define IAXXX_CNR_ERR_PADDR_RMASK_VAL 0x00000fff
#define IAXXX_CNR_ERR_PADDR_WMASK_VAL 0x00000000
#define IAXXX_CNR_ERR_PADDR_RESET_VAL 0x00000000

/*
 * CNR Address for which address bus is stalled
 */
#define IAXXX_CNR_ERR_PADDR_ADDRESS_MASK 0x00000fff
#define IAXXX_CNR_ERR_PADDR_ADDRESS_RESET_VAL 0x0
#define IAXXX_CNR_ERR_PADDR_ADDRESS_POS 0
#define IAXXX_CNR_ERR_PADDR_ADDRESS_SIZE 12
#define IAXXX_CNR_ERR_PADDR_ADDRESS_DECL (11:0)

/*** CNR_SPARE_GATES (0x40001144) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_CNR_SPARE_GATES_ADDR (0x40001144)
#define IAXXX_CNR_SPARE_GATES_MASK_VAL 0xffffffff
#define IAXXX_CNR_SPARE_GATES_RMASK_VAL 0xffffffff
#define IAXXX_CNR_SPARE_GATES_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_SPARE_GATES_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_CNR_SPARE_GATES_FIELD_1_MASK 0x0000ffff
#define IAXXX_CNR_SPARE_GATES_FIELD_1_RESET_VAL 0x0
#define IAXXX_CNR_SPARE_GATES_FIELD_1_POS 0
#define IAXXX_CNR_SPARE_GATES_FIELD_1_SIZE 16
#define IAXXX_CNR_SPARE_GATES_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_CNR_SPARE_GATES_FIELD_2_MASK 0xffff0000
#define IAXXX_CNR_SPARE_GATES_FIELD_2_RESET_VAL 0x0
#define IAXXX_CNR_SPARE_GATES_FIELD_2_POS 16
#define IAXXX_CNR_SPARE_GATES_FIELD_2_SIZE 16
#define IAXXX_CNR_SPARE_GATES_FIELD_2_DECL (31:16)

/*** CNR_EXIT_REG (0x40001fec) ***/
/*
 * Test Only
 */
#define IAXXX_CNR_EXIT_REG_ADDR (0x40001fec)
#define IAXXX_CNR_EXIT_REG_MASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_RMASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_WMASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_RESET_VAL 0x00000000

/*
 * Reserved for hardware debug
 */
#define IAXXX_CNR_EXIT_REG_EXIT_REG_MASK 0xffffffff
#define IAXXX_CNR_EXIT_REG_EXIT_REG_RESET_VAL 0x0
#define IAXXX_CNR_EXIT_REG_EXIT_REG_POS 0
#define IAXXX_CNR_EXIT_REG_EXIT_REG_SIZE 32
#define IAXXX_CNR_EXIT_REG_EXIT_REG_DECL (31:0)

/*** CNR_CNR_DUMMY (0x40001ff0) ***/
/*
 * Test Only
 */
#define IAXXX_CNR_CNR_DUMMY_ADDR (0x40001ff0)
#define IAXXX_CNR_CNR_DUMMY_MASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_RMASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_WMASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_RESET_VAL 0x00000000

/*
 * Read/Write Dummy Registers
 */
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_MASK 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_RESET_VAL 0x0
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_POS 0
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_SIZE 32
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_DECL (31:0)

/* Number of registers in the module */
#define IAXXX_CNR_REG_NUM 84

#endif /* __IAXXX_REGISTER_DEFS_CNR_H__*/
