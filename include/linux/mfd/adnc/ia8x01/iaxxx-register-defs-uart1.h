/*
 * iaxxx-register-defs-uart1.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_UART1_H__
#define __IAXXX_REGISTER_DEFS_UART1_H__

/*** The base address for this set of registers ***/
#define IAXXX_UART1_REGS_ADDR (0x40069000)

/*** UART1_DLL (0x40069000) ***/
/*
 * Divisor Latch Low
 */
#define IAXXX_UART1_DLL_ADDR (0x40069000)
#define IAXXX_UART1_DLL_MASK_VAL 0x000000ff
#define IAXXX_UART1_DLL_RMASK_VAL 0x000000ff
#define IAXXX_UART1_DLL_WMASK_VAL 0x000000ff
#define IAXXX_UART1_DLL_RESET_VAL 0x00000000

/*
 * Lower 8 bits of a 16-bit, read/write, Divisor Latch register that contains
 * the baud rate divisor for the UART. If UART_16550_COMPATIBLE == No, then
 * this register may only be accessed when the DLAB bit (LCR[7]) is set and
 * the UART is not busy (USR[0] is zero); otherwise this register may be
 * accessed only when the DLAB bit (LCR[7]) is set.The output baud rate is
 * equal to the serial clock (pclk if one clock design, sclk if two clock
 * design (CLOCK_MODE == Enabled)) frequency divided by sixteen times the
 * value of the baud rate divisor,as follows:
 *  baud rate = (serial clock freq) / (16 * divisor).
 *  Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the
 * baud clock is disabled and no serial communications occur. Also, once the
 * DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock
 * should be allowed to pass before transmitting or receiving data
 */
#define IAXXX_UART1_DLL_DIVISOR_MASK 0x000000ff
#define IAXXX_UART1_DLL_DIVISOR_RESET_VAL 0x0
#define IAXXX_UART1_DLL_DIVISOR_POS 0
#define IAXXX_UART1_DLL_DIVISOR_SIZE 8
#define IAXXX_UART1_DLL_DIVISOR_DECL (7:0)

/*** UART1_RBR (0x40069000) ***/
/*
 * Receive Buffer Register
 */
#define IAXXX_UART1_RBR_ADDR (0x40069000)
#define IAXXX_UART1_RBR_MASK_VAL 0x000000ff
#define IAXXX_UART1_RBR_RMASK_VAL 0x000000ff
#define IAXXX_UART1_RBR_WMASK_VAL 0x00000000
#define IAXXX_UART1_RBR_RESET_VAL 0x00000000

/*
 * Data byte received on the serial input port (sin) in UART mode, or the
 * serial infrared input (sir_in) in infrared mode. The data in this register
 * is valid only if the Data Ready (DR) bit in the Line Status Register (LSR)
 * is set.
 *  If in non-FIFO mode (FIFO_MODE = NONE) or FIFOs are disabled (FCR[0] set
 * to 0), the data in the RBR must be read before the next data arrives,
 * otherwise it is overwritten, resulting in an over-run error.
 *  If in FIFO mode (FIFO_MODE != NONE) and FIFOs are enabled (FCR[0] set to
 * 1), this register accesses the head of the receive FIFO. If the receive
 * FIFO is full and this register is not read before the next data character
 * arrives, then the data already in the FIFO is preserved, but any incoming
 * data are lost and an over-run error occurs.
 */
#define IAXXX_UART1_RBR_RECEIVE_MASK 0x000000ff
#define IAXXX_UART1_RBR_RECEIVE_RESET_VAL 0x0
#define IAXXX_UART1_RBR_RECEIVE_POS 0
#define IAXXX_UART1_RBR_RECEIVE_SIZE 8
#define IAXXX_UART1_RBR_RECEIVE_DECL (7:0)

/*** UART1_THR (0x40069000) ***/
/*
 * Transmit Holding Register
 */
#define IAXXX_UART1_THR_ADDR (0x40069000)
#define IAXXX_UART1_THR_MASK_VAL 0x000000ff
#define IAXXX_UART1_THR_RMASK_VAL 0x00000000
#define IAXXX_UART1_THR_WMASK_VAL 0x000000ff
#define IAXXX_UART1_THR_RESET_VAL 0x00000000

/*
 * Data to be transmitted on the serial output port (sout) in UART mode or
 * the serial infrared output (sir_out_n) in infrared mode. Data should only
 * be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set.
 *  In FIFO mode and FIFOs are enabled (FCR[0] = 1) and THRE is set, x number
 * of characters of data may be written to the THR before the FIFO is full.
 * The number x (default=16) is determined by the value of FIFO Depth that
 * you set during configuration. Any attempt to write data when the FIFO is
 * full results in the write data being lost
 */
#define IAXXX_UART1_THR_TRANSMIT_MASK 0x000000ff
#define IAXXX_UART1_THR_TRANSMIT_RESET_VAL 0x0
#define IAXXX_UART1_THR_TRANSMIT_POS 0
#define IAXXX_UART1_THR_TRANSMIT_SIZE 8
#define IAXXX_UART1_THR_TRANSMIT_DECL (7:0)

/*** UART1_DLH (0x40069004) ***/
/*
 * Divisor Latch High
 */
#define IAXXX_UART1_DLH_ADDR (0x40069004)
#define IAXXX_UART1_DLH_MASK_VAL 0x000000ff
#define IAXXX_UART1_DLH_RMASK_VAL 0x000000ff
#define IAXXX_UART1_DLH_WMASK_VAL 0x000000ff
#define IAXXX_UART1_DLH_RESET_VAL 0x00000000

/*
 * Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains
 * the baud rate divisor for the UART. If UART_16550_COMPATIBLE == No, then
 * this register may only be accessed when the DLAB bit (LCR[7]) is set and
 * the UART is not busy (USR[0] is zero); otherwise this register may be
 * accessed only when the DLAB bit (LCR[7]) is set.
 *  The output baud rate is equal to the serial clock (pclk if one clock
 * design, sclk if two clock design (CLOCK_MODE == Enabled)) frequency
 * divided by sixteen times the value of the baud rate divisor, as follows:
 *  baud rate = (serial clock freq) / (16 * divisor).
 *  Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the
 * baud clock is disabled and no serial communications occur. Also, once the
 * DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock
 * should be allowed to pass before transmitting or receiving data
 */
#define IAXXX_UART1_DLH_DIVISOR_MASK 0x000000ff
#define IAXXX_UART1_DLH_DIVISOR_RESET_VAL 0x0
#define IAXXX_UART1_DLH_DIVISOR_POS 0
#define IAXXX_UART1_DLH_DIVISOR_SIZE 8
#define IAXXX_UART1_DLH_DIVISOR_DECL (7:0)

/*** UART1_IER (0x40069004) ***/
/*
 * Interrupt Enable Register
 */
#define IAXXX_UART1_IER_ADDR (0x40069004)
#define IAXXX_UART1_IER_MASK_VAL 0x0000008f
#define IAXXX_UART1_IER_RMASK_VAL 0x0000008f
#define IAXXX_UART1_IER_WMASK_VAL 0x0000008f
#define IAXXX_UART1_IER_RESET_VAL 0x00000000

/*
 * Enable Received Data Available Interrupt. This is used to enable/disable
 * the generation of Received Data Available Interrupt and the Character
 * Timeout Interrupt (if in FIFO mode and FIFOs enabled). These are the
 * second highest priority interrupts.
 *  0 = disabled
 *  1 = enabled
 */
#define IAXXX_UART1_IER_ERBFI_MASK 0x00000001
#define IAXXX_UART1_IER_ERBFI_RESET_VAL 0x0
#define IAXXX_UART1_IER_ERBFI_POS 0
#define IAXXX_UART1_IER_ERBFI_SIZE 1
#define IAXXX_UART1_IER_ERBFI_DECL 0

/*
 * Enable Transmit Holding Register Empty Interrupt. This is used to
 * enable/disable the generation of Transmitter Holding Register Empty
 * Interrupt. This is the third highest priority interrupt.
 *  0 = disabled
 *  1 = enabled
 */
#define IAXXX_UART1_IER_ETBEI_MASK 0x00000002
#define IAXXX_UART1_IER_ETBEI_RESET_VAL 0x0
#define IAXXX_UART1_IER_ETBEI_POS 1
#define IAXXX_UART1_IER_ETBEI_SIZE 1
#define IAXXX_UART1_IER_ETBEI_DECL 1

/*
 * Enable Receiver Line Status Interrupt. This is used to enable/disable the
 * generation of Receiver Line Status Interrupt. This is the highest priority
 * interrupt.
 *  0 = disabled
 *  1 = enabled
 */
#define IAXXX_UART1_IER_ELSI_MASK 0x00000004
#define IAXXX_UART1_IER_ELSI_RESET_VAL 0x0
#define IAXXX_UART1_IER_ELSI_POS 2
#define IAXXX_UART1_IER_ELSI_SIZE 1
#define IAXXX_UART1_IER_ELSI_DECL 2

/*
 * Enable Modem Status Interrupt. This is used to enable/disable the
 * generation of Modem Status Interrupt. This is the fourth highest priority
 * interrupt.
 *  0 = disabled
 *  1 = enabled
 */
#define IAXXX_UART1_IER_EDSSI_MASK 0x00000008
#define IAXXX_UART1_IER_EDSSI_RESET_VAL 0x0
#define IAXXX_UART1_IER_EDSSI_POS 3
#define IAXXX_UART1_IER_EDSSI_SIZE 1
#define IAXXX_UART1_IER_EDSSI_DECL 3

/*
 * Programmable THRE Interrupt Mode Enable that can be written to only when
 * THRE_MODE_USER == Enabled, always readable. This is used to enable/disable
 * the generation of THRE Interrupt.
 *  0 = disabled
 *  1 = enabled
 */
#define IAXXX_UART1_IER_PTIME_MASK 0x00000080
#define IAXXX_UART1_IER_PTIME_RESET_VAL 0x0
#define IAXXX_UART1_IER_PTIME_POS 7
#define IAXXX_UART1_IER_PTIME_SIZE 1
#define IAXXX_UART1_IER_PTIME_DECL 7

/*** UART1_FCR (0x40069008) ***/
/*
 * FIFO Control Register
 */
#define IAXXX_UART1_FCR_ADDR (0x40069008)
#define IAXXX_UART1_FCR_MASK_VAL 0x000000ff
#define IAXXX_UART1_FCR_RMASK_VAL 0x00000000
#define IAXXX_UART1_FCR_WMASK_VAL 0x000000ff
#define IAXXX_UART1_FCR_RESET_VAL 0x00000000

/*
 * FIFO Enable. This enables/disables the transmit (XMIT) and receive (RCVR)
 * FIFOs. Whenever the value of this bit is changed both the XMIT and RCVR
 * controller portion of FIFOs is reset
 */
#define IAXXX_UART1_FCR_FIFOE_MASK 0x00000001
#define IAXXX_UART1_FCR_FIFOE_RESET_VAL 0x0
#define IAXXX_UART1_FCR_FIFOE_POS 0
#define IAXXX_UART1_FCR_FIFOE_SIZE 1
#define IAXXX_UART1_FCR_FIFOE_DECL 0

/*
 * RCVR FIFO Reset. This resets the control portion of the receive FIFO and
 * treats the FIFO as empty. This also de-asserts the DMA RX request and
 * single signals when additional DMA handshaking signals are selected
 * (DMA_EXTRA == YES). Note that this bit is ''self-clearing''. It is not
 * necessary to clear this bitX
 */
#define IAXXX_UART1_FCR_RFIFOR_MASK 0x00000002
#define IAXXX_UART1_FCR_RFIFOR_RESET_VAL 0x0
#define IAXXX_UART1_FCR_RFIFOR_POS 1
#define IAXXX_UART1_FCR_RFIFOR_SIZE 1
#define IAXXX_UART1_FCR_RFIFOR_DECL 1

/*
 * XMIT FIFO Reset. This resets the control portion of the transmit FIFO and
 * treats the FIFO as empty. This also de-asserts the DMA TX request and
 * single signals when additional DMA handshaking signals are selected
 * (DMA_EXTRA == YES). Note that this bit is ''self-clearing''. It is not
 * necessary to clear this bitX
 */
#define IAXXX_UART1_FCR_XFIFOR_MASK 0x00000004
#define IAXXX_UART1_FCR_XFIFOR_RESET_VAL 0x0
#define IAXXX_UART1_FCR_XFIFOR_POS 2
#define IAXXX_UART1_FCR_XFIFOR_SIZE 1
#define IAXXX_UART1_FCR_XFIFOR_DECL 2

/*
 * DMA Mode. This determines the DMA signalling mode used for the
 * dma_tx_req_n and dma_rx_req_n output signals when additional DMA
 * handshaking signals are not selected (DMA_EXTRA == No)
 */
#define IAXXX_UART1_FCR_DMAM_MASK 0x00000008
#define IAXXX_UART1_FCR_DMAM_RESET_VAL 0x0
#define IAXXX_UART1_FCR_DMAM_POS 3
#define IAXXX_UART1_FCR_DMAM_SIZE 1
#define IAXXX_UART1_FCR_DMAM_DECL 3

/*
 * TX Empty Trigger. Writes have no effect when THRE_MODE_USER == Disabled.
 * This is used to select the empty threshold level at which the THRE
 * Interrupts are generated when the mode is active. It also determines when
 * the dma_tx_req_n signal is asserted when in certain modes of operation.
 *  00:FIFO empty
 *  (01:2) characters in the FIFO
 *  10:FIFO 1/4 full
 *  11:FIFO 1/2 full
 */
#define IAXXX_UART1_FCR_TET_MASK 0x00000030
#define IAXXX_UART1_FCR_TET_RESET_VAL 0x0
#define IAXXX_UART1_FCR_TET_POS 4
#define IAXXX_UART1_FCR_TET_SIZE 2
#define IAXXX_UART1_FCR_TET_DECL (5:4)

/*
 * RCVR Trigger. This is used to select the trigger level in the receiver
 * FIFO at which the Received Data Available Interrupt is generated. In auto
 * flow control mode, this trigger is used to determine when the rts_n signal
 * is de-asserted only when RTC_FCT is disabled. It also determines when the
 * dma_rx_req_n signal is asserted in certain modes of operation. For details
 * on DMA support, refer to “DMA Support” on page 53. The following trigger
 * levels are supported:
 *  (00:1) character in the FIFO
 *  01:FIFO 1/4 full
 *  10:FIFO 1/2 full
 *  11:FIFO 2 less than full
 */
#define IAXXX_UART1_FCR_RCVR_MASK 0x000000c0
#define IAXXX_UART1_FCR_RCVR_RESET_VAL 0x0
#define IAXXX_UART1_FCR_RCVR_POS 6
#define IAXXX_UART1_FCR_RCVR_SIZE 2
#define IAXXX_UART1_FCR_RCVR_DECL (7:6)

/*** UART1_IIR (0x40069008) ***/
/*
 * Interrupt Identification Register
 */
#define IAXXX_UART1_IIR_ADDR (0x40069008)
#define IAXXX_UART1_IIR_MASK_VAL 0x000000cf
#define IAXXX_UART1_IIR_RMASK_VAL 0x000000cf
#define IAXXX_UART1_IIR_WMASK_VAL 0x00000000
#define IAXXX_UART1_IIR_RESET_VAL 0x00000001

/*
 * Interrupt ID. This indicates the highest priority pending interrupt which
 * can be one of the following types:
 *  0000 = modem status
 *  0001 = no interrupt pending
 *  0010 = THR empty
 *  0100 = received data available
 *  0110 = receiver line status
 *  0111 = busy detect
 *  1100 = character timeout
 */
#define IAXXX_UART1_IIR_INTERRUPT_MASK 0x0000000f
#define IAXXX_UART1_IIR_INTERRUPT_RESET_VAL 0x1
#define IAXXX_UART1_IIR_INTERRUPT_POS 0
#define IAXXX_UART1_IIR_INTERRUPT_SIZE 4
#define IAXXX_UART1_IIR_INTERRUPT_DECL (3:0)

/*
 * FIFOs Enabled. This is used to indicate whether the FIFOs are enabled or
 * disabled
 *  00:disabled
 *  11:enabled
 */
#define IAXXX_UART1_IIR_FIFOS_MASK 0x000000c0
#define IAXXX_UART1_IIR_FIFOS_RESET_VAL 0x0
#define IAXXX_UART1_IIR_FIFOS_POS 6
#define IAXXX_UART1_IIR_FIFOS_SIZE 2
#define IAXXX_UART1_IIR_FIFOS_DECL (7:6)

/*** UART1_LCR (0x4006900c) ***/
/*
 * Line Control Register
 */
#define IAXXX_UART1_LCR_ADDR (0x4006900c)
#define IAXXX_UART1_LCR_MASK_VAL 0x000000ff
#define IAXXX_UART1_LCR_RMASK_VAL 0x000000ff
#define IAXXX_UART1_LCR_WMASK_VAL 0x000000ff
#define IAXXX_UART1_LCR_RESET_VAL 0x00000000

/*
 * Data Length Select. If UART_16550_COMPATIBLE == NO, then writeable only
 * when UART is not busy (USR[0] is zero); otherwise always writable, always
 * readable. This is used to select the number of data bits per character
 * that the peripheral transmits and receives. The number of bit that may be
 * selected areas follows:
 *  00 = 5 bits
 *  01 = 6 bits
 *  10 = 7 bits
 *  11 = 8 bits
 */
#define IAXXX_UART1_LCR_DLS_MASK 0x00000003
#define IAXXX_UART1_LCR_DLS_RESET_VAL 0x0
#define IAXXX_UART1_LCR_DLS_POS 0
#define IAXXX_UART1_LCR_DLS_SIZE 2
#define IAXXX_UART1_LCR_DLS_DECL (1:0)

/*
 * Number of stop bits. If UART_16550_COMPATIBLE == NO, then writeable only
 * when UART is not busy (USR[0] is zero); otherwise always writable, always
 * readable. This is used to select the number of stop bits per character
 * that the peripheral transmits and receives. If set to zero, one stop bit
 * is transmitted in the serial data.
 *  If set to one and the data bits are set to 5 (LCR[(1:0)] set to zero) one
 * and a half stop bits is transmitted. Otherwise, two stop bits are
 * transmitted.
 *  Note that regardless of the number of stop bits selected, the receiver
 * checks only the first stop bit.
 *  0 = 1 stop bit
 *  1 = 1.5 stop bits when DLS (LCR[(1:0)]) is zero, else 2 stop bits
 */
#define IAXXX_UART1_LCR_STOP_MASK 0x00000004
#define IAXXX_UART1_LCR_STOP_RESET_VAL 0x0
#define IAXXX_UART1_LCR_STOP_POS 2
#define IAXXX_UART1_LCR_STOP_SIZE 1
#define IAXXX_UART1_LCR_STOP_DECL 2

/*
 * Parity Enable. If UART_16550_COMPATIBLE == NO, then writeable only when
 * UART is not busy (USR[0] is zero); otherwise always writable, always
 * readable. This bit is used to enable and disable parity generation and
 * detection in transmitted and received serial character respectively.
 *  0 = parity disabled
 *  1 = parity enabled
 */
#define IAXXX_UART1_LCR_PEN_MASK 0x00000008
#define IAXXX_UART1_LCR_PEN_RESET_VAL 0x0
#define IAXXX_UART1_LCR_PEN_POS 3
#define IAXXX_UART1_LCR_PEN_SIZE 1
#define IAXXX_UART1_LCR_PEN_DECL 3

/*
 * Even Parity Select. If UART_16550_COMPATIBLE == NO, then writeable only
 * when UART is not busy (USR[0] is zero); otherwise always writable, always
 * readable. This is used to select between even and odd parity, when parity
 * is enabled (PEN set to one). If set to one, an even number of logic 1s is
 * transmitted or checked. If set to zero, an odd number of logic 1s is
 * transmitted or checked
 */
#define IAXXX_UART1_LCR_EPS_MASK 0x00000010
#define IAXXX_UART1_LCR_EPS_RESET_VAL 0x0
#define IAXXX_UART1_LCR_EPS_POS 4
#define IAXXX_UART1_LCR_EPS_SIZE 1
#define IAXXX_UART1_LCR_EPS_DECL 4

/*
 * Stick Parity. If UART_16550_COMPATIBLE = NO, which it is NO, then
 * writeable only when UART is not busy (USR[0] is 0); otherwise always
 * writable, always readable. This bit is used to force parity value. When
 * PEN, EPS, and Stick Parity are set to 1, the parity bit is transmitted and
 * checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a
 * logic 0, then parity bit is transmitted and checked as a logic 1. If this
 * bit is set to 0, Stick Parity is disabled.
 */
#define IAXXX_UART1_LCR_STICK_MASK 0x00000020
#define IAXXX_UART1_LCR_STICK_RESET_VAL 0x0
#define IAXXX_UART1_LCR_STICK_POS 5
#define IAXXX_UART1_LCR_STICK_SIZE 1
#define IAXXX_UART1_LCR_STICK_DECL 5

/*
 * Break Control Bit.This is used to cause a break condition to be
 * transmitted to the receiving device. If set to one the serial output is
 * forced to the spacing (logic 0) state. When not in Loopback Mode, as
 * determined by MCR[4], the sout line is forced low until the Break bit is
 * cleared. If SIR_MODE == Enabled and active (MCR[6] set to one) the
 * sir_out_n line is continuously pulsed. When in Loopback Mode, the break
 * condition is internally looped back to the receiver and the sir_out_n line
 * is forced low
 */
#define IAXXX_UART1_LCR_BREAK_MASK 0x00000040
#define IAXXX_UART1_LCR_BREAK_RESET_VAL 0x0
#define IAXXX_UART1_LCR_BREAK_POS 6
#define IAXXX_UART1_LCR_BREAK_SIZE 1
#define IAXXX_UART1_LCR_BREAK_DECL 6

/*
 * Divisor Latch Access Bit.  This bit is used to enable reading and writing
 * of the Divisor Latch register (DLL and DLH) to set the baud rate of the
 * UART. This bit must be cleared after initial baud rate setup to access
 * other registers.
 */
#define IAXXX_UART1_LCR_DLAB_MASK 0x00000080
#define IAXXX_UART1_LCR_DLAB_RESET_VAL 0x0
#define IAXXX_UART1_LCR_DLAB_POS 7
#define IAXXX_UART1_LCR_DLAB_SIZE 1
#define IAXXX_UART1_LCR_DLAB_DECL 7

/*** UART1_MCR (0x40069010) ***/
/*
 * Modem Control Register
 */
#define IAXXX_UART1_MCR_ADDR (0x40069010)
#define IAXXX_UART1_MCR_MASK_VAL 0x0000007f
#define IAXXX_UART1_MCR_RMASK_VAL 0x0000007f
#define IAXXX_UART1_MCR_WMASK_VAL 0x0000007f
#define IAXXX_UART1_MCR_RESET_VAL 0x00000000

/*
 * Data Terminal Ready. This is used to directly control the Data Terminal
 * Ready (dtr_n) output. The value written to this location is inverted and
 * driven out on dtr_n, that is:
 *  0 = dtr_n de-asserted (logic 1)
 *  1 = dtr_n asserted (logic 0)
 *  The Data Terminal Ready output is used to inform the modem or data set
 * that the UART is ready to establish communications. Note that in Loopback
 * mode (MCR[4] set to one), the dtr_n output is held inactive high while the
 * value of this location is internally looped back to an input
 */
#define IAXXX_UART1_MCR_DTR_MASK 0x00000001
#define IAXXX_UART1_MCR_DTR_RESET_VAL 0x0
#define IAXXX_UART1_MCR_DTR_POS 0
#define IAXXX_UART1_MCR_DTR_SIZE 1
#define IAXXX_UART1_MCR_DTR_DECL 0

/*
 * Request to Send. This is used to directly control the Request to Send(
 * rts_n) output. The Request to send output is used to inform the modem or
 * data set that the UART is ready to exchange data
 */
#define IAXXX_UART1_MCR_RTS_MASK 0x00000002
#define IAXXX_UART1_MCR_RTS_RESET_VAL 0x0
#define IAXXX_UART1_MCR_RTS_POS 1
#define IAXXX_UART1_MCR_RTS_SIZE 1
#define IAXXX_UART1_MCR_RTS_DECL 1

/*
 * OUT1. This is used to directly control the user-designated Output1. The
 * value written to this location is inverted and driven out on out1_n that
 * is
 *  0:out1_n de-asserted 1:out1_n asserted
 */
#define IAXXX_UART1_MCR_OUT1_MASK 0x00000004
#define IAXXX_UART1_MCR_OUT1_RESET_VAL 0x0
#define IAXXX_UART1_MCR_OUT1_POS 2
#define IAXXX_UART1_MCR_OUT1_SIZE 1
#define IAXXX_UART1_MCR_OUT1_DECL 2

/*
 * OUT2. This is used to directly control the user designated Output2. The
 * value written to this location is inverted and driven out on out2_n that
 * is
 *  0:out2_n de-asserted
 *  1:out2_n asserted
 */
#define IAXXX_UART1_MCR_OUT2_MASK 0x00000008
#define IAXXX_UART1_MCR_OUT2_RESET_VAL 0x0
#define IAXXX_UART1_MCR_OUT2_POS 3
#define IAXXX_UART1_MCR_OUT2_SIZE 1
#define IAXXX_UART1_MCR_OUT2_DECL 3

/*
 * Loopback bit. This is used to put the UART into a diagnostic mode for test
 * purposes.
 */
#define IAXXX_UART1_MCR_LB_MASK 0x00000010
#define IAXXX_UART1_MCR_LB_RESET_VAL 0x0
#define IAXXX_UART1_MCR_LB_POS 4
#define IAXXX_UART1_MCR_LB_SIZE 1
#define IAXXX_UART1_MCR_LB_DECL 4

/*
 * Auto Flow Control Enable.
 */
#define IAXXX_UART1_MCR_AFCE_MASK 0x00000020
#define IAXXX_UART1_MCR_AFCE_RESET_VAL 0x0
#define IAXXX_UART1_MCR_AFCE_POS 5
#define IAXXX_UART1_MCR_AFCE_SIZE 1
#define IAXXX_UART1_MCR_AFCE_DECL 5

/*
 * SIR Mode Enable
 */
#define IAXXX_UART1_MCR_SIRE_MASK 0x00000040
#define IAXXX_UART1_MCR_SIRE_RESET_VAL 0x0
#define IAXXX_UART1_MCR_SIRE_POS 6
#define IAXXX_UART1_MCR_SIRE_SIZE 1
#define IAXXX_UART1_MCR_SIRE_DECL 6

/*** UART1_LSR (0x40069014) ***/
/*
 * Line Status Register
 */
#define IAXXX_UART1_LSR_ADDR (0x40069014)
#define IAXXX_UART1_LSR_MASK_VAL 0x000000ff
#define IAXXX_UART1_LSR_RMASK_VAL 0x000000ff
#define IAXXX_UART1_LSR_WMASK_VAL 0x00000000
#define IAXXX_UART1_LSR_RESET_VAL 0x00000000

/*
 * Data Ready bit. This is used to indicate that the receiver contains at
 * least one character in the RBR or the receiver FIFO.
 *  0:no data ready
 *  1:data ready
 *  This bit is cleared when receiver FIFO is empty.
 */
#define IAXXX_UART1_LSR_DR_MASK 0x00000001
#define IAXXX_UART1_LSR_DR_RESET_VAL 0x0
#define IAXXX_UART1_LSR_DR_POS 0
#define IAXXX_UART1_LSR_DR_SIZE 1
#define IAXXX_UART1_LSR_DR_DECL 0

/*
 * Overrun error bit. This is used to indicate the occurrence of an overrun
 * error.
 */
#define IAXXX_UART1_LSR_OE_MASK 0x00000002
#define IAXXX_UART1_LSR_OE_RESET_VAL 0x0
#define IAXXX_UART1_LSR_OE_POS 1
#define IAXXX_UART1_LSR_OE_SIZE 1
#define IAXXX_UART1_LSR_OE_DECL 1

/*
 * Parity Error bit. This is used to indicate the occurrence of a parity
 * error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set. In
 * the FIFO mode, since the parity error is associated with a character
 * received, it is revealed when the character with the parity error arrives
 * at the top of the FIFO. It should be noted that the Parity Error (PE) bit
 * (LSR[2]) can be set if a break interrupt has occurred, as indicated by
 * Break Interrupt (BI) bit (LSR[4]). In this situation, the Parity Error bit
 * is set if parity generation and detection is enabled (LCR[3]=1) and the
 * parity is set to odd (LCR[4]=0).
 *  0: no parity error
 *  1: parity error
 *  Reading the LSR clears the PE bit.
 */
#define IAXXX_UART1_LSR_PE_MASK 0x00000004
#define IAXXX_UART1_LSR_PE_RESET_VAL 0x0
#define IAXXX_UART1_LSR_PE_POS 2
#define IAXXX_UART1_LSR_PE_SIZE 1
#define IAXXX_UART1_LSR_PE_DECL 2

/*
 * Framing Error bit. This is used to indicate the occurrence of a framing
 * error in the receiver. A framing error occurs when the receiver does not
 * detect a valid STOP bit in the received data. In the FIFO mode, since the
 * framing error is associated with a character received, it is revealed when
 * the character with the framing error is at the top of the FIFO. When a
 * framing error occurs, the DW_apb_uart tries to resynchronize. It does this
 * by assuming that the error was due to the start bit of the next character
 * and then continues receiving the other bit; that is, data, and/or parity
 * and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is
 * set if a break interrupt has occurred, as indicated by Break Interrupt
 * (BI) bit (LSR[4]). This happens because the break character implicitly
 * generates a framing error by holding the sin input to logic 0 for longer
 * than the duration of a character.
 *  0: no framing error
 *  1: framing error
 *  Reading the LSR clears the FE bit.
 */
#define IAXXX_UART1_LSR_FE_MASK 0x00000008
#define IAXXX_UART1_LSR_FE_RESET_VAL 0x0
#define IAXXX_UART1_LSR_FE_POS 3
#define IAXXX_UART1_LSR_FE_SIZE 1
#define IAXXX_UART1_LSR_FE_DECL 3

/*
 * Break Interrupt bit. This is used to indicate the detection of a break
 * sequence on the serial input data. If in UART mode (SIR_MODE = Disabled),
 * it is set whenever the serial input, sin, is held in a logic '0' state for
 * longer than the sum of start time + data bits + parity + stop bits. If in
 * infrared mode (SIR_MODE = Enabled), it is set whenever the serial input,
 * sir_in, is continuously pulsed to logic '0' for longer than the sum of
 * start time + data bits + parity + stop bits. A break condition on serial
 * input causes one and only one character, consisting of all 0s, to be
 * received by the UART.
 *  In FIFO mode, the character associated with the break condition is
 * carried through the FIFO and is revealed when the character is at the top
 * of the FIFO. Reading the LSR clears the BI bit. In non-FIFO mode, the BI
 * indication occurs immediately and persists until the LSR is read.
 *  NOTE: If a FIFO is full when a break condition is received, a FIFO
 * overrun occurs. The break condition and all the information associated
 * with it -parity and framing errors- is discarded; any information that a
 * break character was received is lost.
 */
#define IAXXX_UART1_LSR_BI_MASK 0x00000010
#define IAXXX_UART1_LSR_BI_RESET_VAL 0x0
#define IAXXX_UART1_LSR_BI_POS 4
#define IAXXX_UART1_LSR_BI_SIZE 1
#define IAXXX_UART1_LSR_BI_DECL 4

/*
 * Transmit Holding Register empty bit.  This bit is set whenever data is
 * transferred from the THR or TX FIFO to the transmitter shift register and
 * no new data has been written to the THR or TX FIFO. This also causes a
 * THRE interrupt to occur.
 */
#define IAXXX_UART1_LSR_THRE_MASK 0x00000020
#define IAXXX_UART1_LSR_THRE_RESET_VAL 0x0
#define IAXXX_UART1_LSR_THRE_POS 5
#define IAXXX_UART1_LSR_THRE_SIZE 1
#define IAXXX_UART1_LSR_THRE_DECL 5

/*
 * Transmitter FIFO empty bit. This bit is set whenever the transmitter shift
 * register and the FIFO are both empty.
 */
#define IAXXX_UART1_LSR_TEMT_MASK 0x00000040
#define IAXXX_UART1_LSR_TEMT_RESET_VAL 0x0
#define IAXXX_UART1_LSR_TEMT_POS 6
#define IAXXX_UART1_LSR_TEMT_SIZE 1
#define IAXXX_UART1_LSR_TEMT_DECL 6

/*
 * Receiver FIFO Error Bit.
 *  0: no error in RX FIFO
 *  1: error in RX FIFO
 *  This bit is cleared when the LSR is read and the character with the error
 * is at the top of the receiver FIFO and there are no subsequent errors in
 * the FIFO
 */
#define IAXXX_UART1_LSR_RFE_MASK 0x00000080
#define IAXXX_UART1_LSR_RFE_RESET_VAL 0x0
#define IAXXX_UART1_LSR_RFE_POS 7
#define IAXXX_UART1_LSR_RFE_SIZE 1
#define IAXXX_UART1_LSR_RFE_DECL 7

/*** UART1_MSR (0x40069018) ***/
/*
 * Modem Status Register
 */
#define IAXXX_UART1_MSR_ADDR (0x40069018)
#define IAXXX_UART1_MSR_MASK_VAL 0x000000ff
#define IAXXX_UART1_MSR_RMASK_VAL 0x000000ff
#define IAXXX_UART1_MSR_WMASK_VAL 0x00000000
#define IAXXX_UART1_MSR_RESET_VAL 0x00000000

/*
 * Delta Clear to Send
 */
#define IAXXX_UART1_MSR_DCTS_MASK 0x00000001
#define IAXXX_UART1_MSR_DCTS_RESET_VAL 0x0
#define IAXXX_UART1_MSR_DCTS_POS 0
#define IAXXX_UART1_MSR_DCTS_SIZE 1
#define IAXXX_UART1_MSR_DCTS_DECL 0

/*
 * Delta Data Set Ready
 */
#define IAXXX_UART1_MSR_DDSR_MASK 0x00000002
#define IAXXX_UART1_MSR_DDSR_RESET_VAL 0x0
#define IAXXX_UART1_MSR_DDSR_POS 1
#define IAXXX_UART1_MSR_DDSR_SIZE 1
#define IAXXX_UART1_MSR_DDSR_DECL 1

/*
 * Trailing Edge of Ring indicator
 */
#define IAXXX_UART1_MSR_TERI_MASK 0x00000004
#define IAXXX_UART1_MSR_TERI_RESET_VAL 0x0
#define IAXXX_UART1_MSR_TERI_POS 2
#define IAXXX_UART1_MSR_TERI_SIZE 1
#define IAXXX_UART1_MSR_TERI_DECL 2

/*
 * Delta Data Carrier Detect
 */
#define IAXXX_UART1_MSR_DDCD_MASK 0x00000008
#define IAXXX_UART1_MSR_DDCD_RESET_VAL 0x0
#define IAXXX_UART1_MSR_DDCD_POS 3
#define IAXXX_UART1_MSR_DDCD_SIZE 1
#define IAXXX_UART1_MSR_DDCD_DECL 3

/*
 * Clear to Send
 */
#define IAXXX_UART1_MSR_CTS_MASK 0x00000010
#define IAXXX_UART1_MSR_CTS_RESET_VAL 0x0
#define IAXXX_UART1_MSR_CTS_POS 4
#define IAXXX_UART1_MSR_CTS_SIZE 1
#define IAXXX_UART1_MSR_CTS_DECL 4

/*
 * Data Set Ready
 */
#define IAXXX_UART1_MSR_DSR_MASK 0x00000020
#define IAXXX_UART1_MSR_DSR_RESET_VAL 0x0
#define IAXXX_UART1_MSR_DSR_POS 5
#define IAXXX_UART1_MSR_DSR_SIZE 1
#define IAXXX_UART1_MSR_DSR_DECL 5

/*
 * Ring Indicator.
 */
#define IAXXX_UART1_MSR_RI_MASK 0x00000040
#define IAXXX_UART1_MSR_RI_RESET_VAL 0x0
#define IAXXX_UART1_MSR_RI_POS 6
#define IAXXX_UART1_MSR_RI_SIZE 1
#define IAXXX_UART1_MSR_RI_DECL 6

/*
 * Data Carrier Detect.
 */
#define IAXXX_UART1_MSR_DCD_MASK 0x00000080
#define IAXXX_UART1_MSR_DCD_RESET_VAL 0x0
#define IAXXX_UART1_MSR_DCD_POS 7
#define IAXXX_UART1_MSR_DCD_SIZE 1
#define IAXXX_UART1_MSR_DCD_DECL 7

/*** UART1_SCR (0x4006901c) ***/
/*
 * Scratchpad Register
 */
#define IAXXX_UART1_SCR_ADDR (0x4006901c)
#define IAXXX_UART1_SCR_MASK_VAL 0x000000ff
#define IAXXX_UART1_SCR_RMASK_VAL 0x000000ff
#define IAXXX_UART1_SCR_WMASK_VAL 0x000000ff
#define IAXXX_UART1_SCR_RESET_VAL 0x00000000

/*
 * This register is for programmers to use as temporary storage space. It has
 * no defined purpose in the DW_apb_uart.
 */
#define IAXXX_UART1_SCR_SCR_MASK 0x000000ff
#define IAXXX_UART1_SCR_SCR_RESET_VAL 0x0
#define IAXXX_UART1_SCR_SCR_POS 0
#define IAXXX_UART1_SCR_SCR_SIZE 8
#define IAXXX_UART1_SCR_SCR_DECL (7:0)

/*** UART1_FAR (0x40069070) ***/
/*
 * FIFO Access Register
 */
#define IAXXX_UART1_FAR_ADDR (0x40069070)
#define IAXXX_UART1_FAR_MASK_VAL 0x00000001
#define IAXXX_UART1_FAR_RMASK_VAL 0x00000001
#define IAXXX_UART1_FAR_WMASK_VAL 0x00000000
#define IAXXX_UART1_FAR_RESET_VAL 0x00000000

/*
 * Writes have no effect when FIFO_ACCESS = No, which is the case, however it
 * is always readable. This register is use to enable a FIFO access mode for
 * testing, so that the receive FIFO can be written by the master and the
 * transmit FIFO can be read by the master when FIFOs are implemented and
 * enabled. When FIFOs are not implemented or not enabled it allows the RBR
 * to be written by the master and the THR to be read by the master.
 *  0: FIFO access mode disabled
 *  1: FIFO access mode enabled
 *  Note, that when the FIFO access mode is enabled/disabled, the control
 * portion of the receive FIFO and transmit FIFO is reset and the FIFOs are
 * treated as empty.
 */
#define IAXXX_UART1_FAR_FIFO_MASK 0x00000001
#define IAXXX_UART1_FAR_FIFO_RESET_VAL 0x0
#define IAXXX_UART1_FAR_FIFO_POS 0
#define IAXXX_UART1_FAR_FIFO_SIZE 1
#define IAXXX_UART1_FAR_FIFO_DECL 0

/*** UART1_USR (0x4006907c) ***/
/*
 * UART status register
 */
#define IAXXX_UART1_USR_ADDR (0x4006907c)
#define IAXXX_UART1_USR_MASK_VAL 0x0000001f
#define IAXXX_UART1_USR_RMASK_VAL 0x0000001f
#define IAXXX_UART1_USR_WMASK_VAL 0x00000000
#define IAXXX_UART1_USR_RESET_VAL 0x00000006

/*
 * UART Busy. Indicates that a serial transfer is in progress; when cleared,
 * indicates that the DW_apb_uart is idle or inactive.
 *  0: DW_apb_uart is idle or inactive
 *  1: DW_apb_uart is busy (actively transferring data)
 *  This bit will be set to 1 (busy) under any of the following conditions:
 *  1. Transmission in progress on serial interface
 *  2. Transmit data present in THR, when FIFO access mode is not being used
 * (FAR = 0)
 *  and the baud divisor is non-zero ({DLH,DLL} does not equal 0) when the
 * divisor latch access bit is 0 (LCR.DLAB = 0)
 *  3. Reception in progress on the interface
 *  4. Receive data present in RBR, when FIFO access mode is not being used
 * (FAR = 0)
 *  NOTE: It is possible for the UART Busy bit to be cleared even though a
 * new character may have been sent from another device. That is, if the
 * DW_apb_uart has no data in THR and RBR and there is no transmission in
 * progress and a start bit of a new character has just reached the
 * DW_apb_uart. This is due to the fact that a valid start is not seen until
 * the middle of the bit period and this duration is dependent on the baud
 * divisor that has been programmed. If a second system clock has been
 * implemented (CLOCK_MODE = Enabled), the assertion of this bit is also
 * delayed by several cycles of the slower clock.
 */
#define IAXXX_UART1_USR_BUSY_MASK 0x00000001
#define IAXXX_UART1_USR_BUSY_RESET_VAL 0x0
#define IAXXX_UART1_USR_BUSY_POS 0
#define IAXXX_UART1_USR_BUSY_SIZE 1
#define IAXXX_UART1_USR_BUSY_DECL 0

/*
 * Transmit FIFO not full. This is used to indicate that the transmit FIFO in
 * not full.
 *  0: Transmit FIFO is full
 *  1: Transmit FIFO is not full
 *  This bit is cleared when the TX FIFO is full.
 */
#define IAXXX_UART1_USR_TFNF_MASK 0x00000002
#define IAXXX_UART1_USR_TFNF_RESET_VAL 0x1
#define IAXXX_UART1_USR_TFNF_POS 1
#define IAXXX_UART1_USR_TFNF_SIZE 1
#define IAXXX_UART1_USR_TFNF_DECL 1

/*
 * Transmit FIFO Empty. This is used to indicate that the transmit FIFO is
 * completely empty.
 *  0: Transmit FIFO is not empty
 *  1: Transmit FIFO is empty
 *  This bit is cleared when the TX FIFO is no longer empty.
 */
#define IAXXX_UART1_USR_TFE_MASK 0x00000004
#define IAXXX_UART1_USR_TFE_RESET_VAL 0x1
#define IAXXX_UART1_USR_TFE_POS 2
#define IAXXX_UART1_USR_TFE_SIZE 1
#define IAXXX_UART1_USR_TFE_DECL 2

/*
 * Receive FIFO Not Empty. This is used to indicate that the receive FIFO
 * contains one or more entries.
 *  0: Receive FIFO is empty
 *  1: Receive FIFO is not empty
 *  This bit is cleared when the RX FIFO is empty.
 */
#define IAXXX_UART1_USR_RFNE_MASK 0x00000008
#define IAXXX_UART1_USR_RFNE_RESET_VAL 0x0
#define IAXXX_UART1_USR_RFNE_POS 3
#define IAXXX_UART1_USR_RFNE_SIZE 1
#define IAXXX_UART1_USR_RFNE_DECL 3

/*
 * Receive FIFO Full. This is used to indicate that the receive FIFO is
 * completely full.
 *  0: Receive FIFO not full
 *  1: Receive FIFO Full
 *  This bit is cleared when the RX FIFO is no longer full.
 */
#define IAXXX_UART1_USR_RFF_MASK 0x00000010
#define IAXXX_UART1_USR_RFF_RESET_VAL 0x0
#define IAXXX_UART1_USR_RFF_POS 4
#define IAXXX_UART1_USR_RFF_SIZE 1
#define IAXXX_UART1_USR_RFF_DECL 4

/*** UART1_TFL (0x40069080) ***/
/*
 * Transmit FIFO Level
 */
#define IAXXX_UART1_TFL_ADDR (0x40069080)
#define IAXXX_UART1_TFL_MASK_VAL 0x0000007f
#define IAXXX_UART1_TFL_RMASK_VAL 0x0000007f
#define IAXXX_UART1_TFL_WMASK_VAL 0x00000000
#define IAXXX_UART1_TFL_RESET_VAL 0x00000000

/*
 * Transmit FIFO Level.This is indicates the number of data entries in the
 * transmit FIFO.
 */
#define IAXXX_UART1_TFL_TRANSMIT_MASK 0x0000007f
#define IAXXX_UART1_TFL_TRANSMIT_RESET_VAL 0x0
#define IAXXX_UART1_TFL_TRANSMIT_POS 0
#define IAXXX_UART1_TFL_TRANSMIT_SIZE 7
#define IAXXX_UART1_TFL_TRANSMIT_DECL (6:0)

/*** UART1_RFL (0x40069084) ***/
/*
 * Receive FIFO Level
 */
#define IAXXX_UART1_RFL_ADDR (0x40069084)
#define IAXXX_UART1_RFL_MASK_VAL 0x0000007f
#define IAXXX_UART1_RFL_RMASK_VAL 0x0000007f
#define IAXXX_UART1_RFL_WMASK_VAL 0x00000000
#define IAXXX_UART1_RFL_RESET_VAL 0x00000000

/*
 * Receive FIFO Level.This is indicates the number of data entries in the
 * receive FIFO.
 */
#define IAXXX_UART1_RFL_RECEIVE_MASK 0x0000007f
#define IAXXX_UART1_RFL_RECEIVE_RESET_VAL 0x0
#define IAXXX_UART1_RFL_RECEIVE_POS 0
#define IAXXX_UART1_RFL_RECEIVE_SIZE 7
#define IAXXX_UART1_RFL_RECEIVE_DECL (6:0)

/*** UART1_HTX (0x400690a4) ***/
/*
 * Halt TX
 */
#define IAXXX_UART1_HTX_ADDR (0x400690a4)
#define IAXXX_UART1_HTX_MASK_VAL 0x00000001
#define IAXXX_UART1_HTX_RMASK_VAL 0x00000001
#define IAXXX_UART1_HTX_WMASK_VAL 0x00000001
#define IAXXX_UART1_HTX_RESET_VAL 0x00000000

/*
 * This register is used to halt transmissions for testing. So that the
 * transmit FIFO can be filled by the master when FIFOs are implemented and
 * enabled.
 *  0:Halt TX disabled
 *  1:Halt TX enabled
 */
#define IAXXX_UART1_HTX_HALT_MASK 0x00000001
#define IAXXX_UART1_HTX_HALT_RESET_VAL 0x0
#define IAXXX_UART1_HTX_HALT_POS 0
#define IAXXX_UART1_HTX_HALT_SIZE 1
#define IAXXX_UART1_HTX_HALT_DECL 0

/*** UART1_DMASA (0x400690a8) ***/
/*
 * DMA Software Acknowledge
 */
#define IAXXX_UART1_DMASA_ADDR (0x400690a8)
#define IAXXX_UART1_DMASA_MASK_VAL 0x00000001
#define IAXXX_UART1_DMASA_RMASK_VAL 0x00000000
#define IAXXX_UART1_DMASA_WMASK_VAL 0x00000001
#define IAXXX_UART1_DMASA_RESET_VAL 0x00000000

/*
 * This register is use to perform a DMA software acknowledge if a transfer
 * needs to be terminated due to an error condition. For example, if the DMA
 * disables the channel, then the DW_apb_uart should clear its request. This
 * causes the TX request, TX single, RX request and RX single signals to
 * de-assert. Note that this bit is 'self-clearing'. It is not necessary to
 * clear this bit.
 */
#define IAXXX_UART1_DMASA_DMA_MASK 0x00000001
#define IAXXX_UART1_DMASA_DMA_RESET_VAL 0x0
#define IAXXX_UART1_DMASA_DMA_POS 0
#define IAXXX_UART1_DMASA_DMA_SIZE 1
#define IAXXX_UART1_DMASA_DMA_DECL 0

/*** UART1_CPR (0x400690f4) ***/
/*
 * Component Parameter Register
 */
#define IAXXX_UART1_CPR_ADDR (0x400690f4)
#define IAXXX_UART1_CPR_MASK_VAL 0x00ff3ff3
#define IAXXX_UART1_CPR_RMASK_VAL 0x00ff3ff3
#define IAXXX_UART1_CPR_WMASK_VAL 0x00000000
#define IAXXX_UART1_CPR_RESET_VAL 0x00043532

/*
 * 00: 8 bits
 *  01: 16 bits
 *  10: 32 bits
 *  11: reserved
 */
#define IAXXX_UART1_CPR_APB_DATA_WIDTH_MASK 0x00000003
#define IAXXX_UART1_CPR_APB_DATA_WIDTH_RESET_VAL 0x2
#define IAXXX_UART1_CPR_APB_DATA_WIDTH_POS 0
#define IAXXX_UART1_CPR_APB_DATA_WIDTH_SIZE 2
#define IAXXX_UART1_CPR_APB_DATA_WIDTH_DECL (1:0)

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_AFCE_MODE_MASK 0x00000010
#define IAXXX_UART1_CPR_AFCE_MODE_RESET_VAL 0x1
#define IAXXX_UART1_CPR_AFCE_MODE_POS 4
#define IAXXX_UART1_CPR_AFCE_MODE_SIZE 1
#define IAXXX_UART1_CPR_AFCE_MODE_DECL 4

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_THRE_MODE_MASK 0x00000020
#define IAXXX_UART1_CPR_THRE_MODE_RESET_VAL 0x1
#define IAXXX_UART1_CPR_THRE_MODE_POS 5
#define IAXXX_UART1_CPR_THRE_MODE_SIZE 1
#define IAXXX_UART1_CPR_THRE_MODE_DECL 5

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_SIR_MODE_MASK 0x00000040
#define IAXXX_UART1_CPR_SIR_MODE_RESET_VAL 0x0
#define IAXXX_UART1_CPR_SIR_MODE_POS 6
#define IAXXX_UART1_CPR_SIR_MODE_SIZE 1
#define IAXXX_UART1_CPR_SIR_MODE_DECL 6

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_SIR_LP_MODE_MASK 0x00000080
#define IAXXX_UART1_CPR_SIR_LP_MODE_RESET_VAL 0x0
#define IAXXX_UART1_CPR_SIR_LP_MODE_POS 7
#define IAXXX_UART1_CPR_SIR_LP_MODE_SIZE 1
#define IAXXX_UART1_CPR_SIR_LP_MODE_DECL 7

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_ADDITIONAL_FEAT_MASK 0x00000100
#define IAXXX_UART1_CPR_ADDITIONAL_FEAT_RESET_VAL 0x1
#define IAXXX_UART1_CPR_ADDITIONAL_FEAT_POS 8
#define IAXXX_UART1_CPR_ADDITIONAL_FEAT_SIZE 1
#define IAXXX_UART1_CPR_ADDITIONAL_FEAT_DECL 8

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_FIFO_ACCESS_MASK 0x00000200
#define IAXXX_UART1_CPR_FIFO_ACCESS_RESET_VAL 0x0
#define IAXXX_UART1_CPR_FIFO_ACCESS_POS 9
#define IAXXX_UART1_CPR_FIFO_ACCESS_SIZE 1
#define IAXXX_UART1_CPR_FIFO_ACCESS_DECL 9

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_FIFO_STAT_MASK 0x00000400
#define IAXXX_UART1_CPR_FIFO_STAT_RESET_VAL 0x1
#define IAXXX_UART1_CPR_FIFO_STAT_POS 10
#define IAXXX_UART1_CPR_FIFO_STAT_SIZE 1
#define IAXXX_UART1_CPR_FIFO_STAT_DECL 10

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_SHADOW_MASK 0x00000800
#define IAXXX_UART1_CPR_SHADOW_RESET_VAL 0x0
#define IAXXX_UART1_CPR_SHADOW_POS 11
#define IAXXX_UART1_CPR_SHADOW_SIZE 1
#define IAXXX_UART1_CPR_SHADOW_DECL 11

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_UART_ADD_ENCODED_PARAMS_MASK 0x00001000
#define IAXXX_UART1_CPR_UART_ADD_ENCODED_PARAMS_RESET_VAL 0x1
#define IAXXX_UART1_CPR_UART_ADD_ENCODED_PARAMS_POS 12
#define IAXXX_UART1_CPR_UART_ADD_ENCODED_PARAMS_SIZE 1
#define IAXXX_UART1_CPR_UART_ADD_ENCODED_PARAMS_DECL 12

/*
 * 0: False
 *  1: True
 */
#define IAXXX_UART1_CPR_DMA_EXTRA_MASK 0x00002000
#define IAXXX_UART1_CPR_DMA_EXTRA_RESET_VAL 0x1
#define IAXXX_UART1_CPR_DMA_EXTRA_POS 13
#define IAXXX_UART1_CPR_DMA_EXTRA_SIZE 1
#define IAXXX_UART1_CPR_DMA_EXTRA_DECL 13

/*
 * 0x00 = 0
 *  0x01 = 16
 *  0x02 = 32
 *  to
 *  0x80 = 2048
 *  0x81- 0xff = reserved
 */
#define IAXXX_UART1_CPR_FIFO_MODE_MASK 0x00ff0000
#define IAXXX_UART1_CPR_FIFO_MODE_RESET_VAL 0x4
#define IAXXX_UART1_CPR_FIFO_MODE_POS 16
#define IAXXX_UART1_CPR_FIFO_MODE_SIZE 8
#define IAXXX_UART1_CPR_FIFO_MODE_DECL (23:16)

/*** UART1_UCV (0x400690f8) ***/
/*
 * UART Component Version
 */
#define IAXXX_UART1_UCV_ADDR (0x400690f8)
#define IAXXX_UART1_UCV_MASK_VAL 0xffffffff
#define IAXXX_UART1_UCV_RMASK_VAL 0xffffffff
#define IAXXX_UART1_UCV_WMASK_VAL 0x00000000
#define IAXXX_UART1_UCV_RESET_VAL 0x3430302a

/*
 */
#define IAXXX_UART1_UCV_UART_MASK 0xffffffff
#define IAXXX_UART1_UCV_UART_RESET_VAL 0x3430302a
#define IAXXX_UART1_UCV_UART_POS 0
#define IAXXX_UART1_UCV_UART_SIZE 32
#define IAXXX_UART1_UCV_UART_DECL (31:0)

/*** UART1_CTR (0x400690fc) ***/
/*
 * Component Type Register
 */
#define IAXXX_UART1_CTR_ADDR (0x400690fc)
#define IAXXX_UART1_CTR_MASK_VAL 0xffffffff
#define IAXXX_UART1_CTR_RMASK_VAL 0xffffffff
#define IAXXX_UART1_CTR_WMASK_VAL 0x00000000
#define IAXXX_UART1_CTR_RESET_VAL 0x44570110

/*
 */
#define IAXXX_UART1_CTR_COMPONENT_MASK 0xffffffff
#define IAXXX_UART1_CTR_COMPONENT_RESET_VAL 0x44570110
#define IAXXX_UART1_CTR_COMPONENT_POS 0
#define IAXXX_UART1_CTR_COMPONENT_SIZE 32
#define IAXXX_UART1_CTR_COMPONENT_DECL (31:0)

/* Number of registers in the module */
#define IAXXX_UART1_REG_NUM 21

#endif /* __IAXXX_REGISTER_DEFS_UART1_H__*/
