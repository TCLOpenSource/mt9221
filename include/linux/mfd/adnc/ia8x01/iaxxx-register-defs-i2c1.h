/*
 * iaxxx-register-defs-i2c1.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_I2C1_H__
#define __IAXXX_REGISTER_DEFS_I2C1_H__

/*** The base address for this set of registers ***/
#define IAXXX_I2C1_REGS_ADDR (0x40059000)

/*** I2C1_IC_CON (0x40059000) ***/
/*
 * I2C Control Register
 */
#define IAXXX_I2C1_IC_CON_ADDR (0x40059000)
#define IAXXX_I2C1_IC_CON_MASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_CON_RMASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_CON_WMASK_VAL 0x00000fef
#define IAXXX_I2C1_IC_CON_RESET_VAL 0x00000026

/*
 * This bit controls whether the DW_apb_i2c master is enabled.
 *  1: master enabled
 *  0: master disabled
 */
#define IAXXX_I2C1_IC_CON_MASTER_MODE_MASK 0x00000001
#define IAXXX_I2C1_IC_CON_MASTER_MODE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_MASTER_MODE_POS 0
#define IAXXX_I2C1_IC_CON_MASTER_MODE_SIZE 1
#define IAXXX_I2C1_IC_CON_MASTER_MODE_DECL 0

/*
 * These bits control at which speed the DW_apb_i2c operates; its setting is
 * relevant only if one is operating the DW_apb_i2c in master mode. Hardware
 * protects against illegal values being programmed by software.
 *  1: standard mode (100 kbit/s)
 *  2: fast mode ( 400 kbit/s)
 *  3: high speed mode (3.4 Mbit/s)
 */
#define IAXXX_I2C1_IC_CON_SPEED_MASK 0x00000006
#define IAXXX_I2C1_IC_CON_SPEED_RESET_VAL 0x3
#define IAXXX_I2C1_IC_CON_SPEED_POS 1
#define IAXXX_I2C1_IC_CON_SPEED_SIZE 2
#define IAXXX_I2C1_IC_CON_SPEED_DECL (2:1)

/*
 * When acting as a slave, this bit controls the DW_apb_i2c responds to 7 or
 * 10 bit addresses.
 *  0: 7 bit addressing
 *  1: 10 bit addressing
 */
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_SLAVE_MASK 0x00000008
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_SLAVE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_SLAVE_POS 3
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_SLAVE_SIZE 1
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_SLAVE_DECL 3

/*
 * Function of this bit is handled by bit 12 of IC_TAR register.
 *  0: 7 bit addressing
 *  1: 10 bit addressing
 */
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_MASTER_RD_ONLY_MASK 0x00000010
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_MASTER_RD_ONLY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_MASTER_RD_ONLY_POS 4
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_MASTER_RD_ONLY_SIZE 1
#define IAXXX_I2C1_IC_CON_IC_10BITADDR_MASTER_RD_ONLY_DECL 4

/*
 * Determines whether RESTART conditions may be sent when acting as a
 * master.Some older slaves do not support handling RESTART conditions.
 * However,
 * RESTART conditions are used in several DW_apb_i2c operations.
 *  0: disable
 *  1: enable
 *  When RESTART is disabled, the master is prohibited from performing the
 * following functions:
 *  * Change direction within a transfer (split)
 *  * Send a START BYTE
 *  * High-speed mode operation
 *  * Combined format transfers in 7-bit addressing modes
 *  * Read operation with a 10 bit address
 *  * Send multiple bytes per transfer
 */
#define IAXXX_I2C1_IC_CON_IC_RESTART_EN_MASK 0x00000020
#define IAXXX_I2C1_IC_CON_IC_RESTART_EN_RESET_VAL 0x1
#define IAXXX_I2C1_IC_CON_IC_RESTART_EN_POS 5
#define IAXXX_I2C1_IC_CON_IC_RESTART_EN_SIZE 1
#define IAXXX_I2C1_IC_CON_IC_RESTART_EN_DECL 5

/*
 * This bit control whether I2C has its slave disabled, which means once the
 * presetn is applied, then this bit takes on the configuration value which
 * is disabled in this case.
 */
#define IAXXX_I2C1_IC_CON_IC_SLAVE_DISABLE_MASK 0x00000040
#define IAXXX_I2C1_IC_CON_IC_SLAVE_DISABLE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_IC_SLAVE_DISABLE_POS 6
#define IAXXX_I2C1_IC_CON_IC_SLAVE_DISABLE_SIZE 1
#define IAXXX_I2C1_IC_CON_IC_SLAVE_DISABLE_DECL 6

/*
 * In slave mode:
 *  1'b1: issues the STOP_DET interrupt only when it is addressed.
 *  1'b0: issues the STOP_DET irrespective of whether it is addressed or not.
 *  Dependencies: This register bit value is applicable in the slave mode
 * only (MASTER_MODE = 1'b0)
 *  NOTE: During a general call address, this slave does not issue the
 * STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave
 * responds to the general call address by generating ACK. The STOP_DET
 * interrupt is generated only when the transmitted address matches the slave
 * address (SAR).
 */
#define IAXXX_I2C1_IC_CON_STOP_DET_IFADDRESSED_MASK 0x00000080
#define IAXXX_I2C1_IC_CON_STOP_DET_IFADDRESSED_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_STOP_DET_IFADDRESSED_POS 7
#define IAXXX_I2C1_IC_CON_STOP_DET_IFADDRESSED_SIZE 1
#define IAXXX_I2C1_IC_CON_STOP_DET_IFADDRESSED_DECL 7

/*
 * This bit controls the generation of the TX_EMPTY interrupt, as described
 * in the IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CON_TX_EMPTY_CTRL_MASK 0x00000100
#define IAXXX_I2C1_IC_CON_TX_EMPTY_CTRL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_TX_EMPTY_CTRL_POS 8
#define IAXXX_I2C1_IC_CON_TX_EMPTY_CTRL_SIZE 1
#define IAXXX_I2C1_IC_CON_TX_EMPTY_CTRL_DECL 8

/*
 * This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO
 * is physically full to its RX_BUFFER_DEPTH, as described in the
 * IC_RX_FULL_HLD_BUS_EN parameter. Below is the description: When the
 * Receive fifo is physically full to its RX_BUFFER_DEPTH, this enables a
 * hardware method to hold the bus till receive fifo data has read out to
 * make space available in it. This works for when DW_apb_i2c is either a
 * Slave/Receiver (data being written to the device) or as a Master/Receiver
 * (device is reading data from a slave). Note: if this parameter is set to
 * 1, which it is for this version, then the rx_over interrupt is never set
 * to 1 as the criteria to set this interrupt is never met i.e. data never
 * written the receive buffer if it is full.  The rx_over interrupt can be
 * found in IC_INTR_STAT[1] and IC_RAW_INTR_STAT[1]. It is also an optional
 * output called ic_rx_over_intr(_n).
 */
#define IAXXX_I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL_MASK 0x00000200
#define IAXXX_I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL_POS 9
#define IAXXX_I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL_SIZE 1
#define IAXXX_I2C1_IC_CON_RX_FIFO_FULL_HLD_CTRL_DECL 9

/*
 * In Master mode:
 *  1: Issues the STOP_DET interrupt only when the master is active
 *  0: Issues the STOP_DET irrespective of whether the master is active.
 */
#define IAXXX_I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE_MASK 0x00000400
#define IAXXX_I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE_POS 10
#define IAXXX_I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE_SIZE 1
#define IAXXX_I2C1_IC_CON_STOP_DET_IF_MASTER_ACTIVE_DECL 10

/*
 * In Master mode:
 *  1: Bus Clear Feature is enabled.
 *  0: Bus Clear Feature is disabled.
 *  In Slave mode this register bit is not applicable.
 */
#define IAXXX_I2C1_IC_CON_BUS_CLEAR_FEATURE_CTRL_MASK 0x00000800
#define IAXXX_I2C1_IC_CON_BUS_CLEAR_FEATURE_CTRL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CON_BUS_CLEAR_FEATURE_CTRL_POS 11
#define IAXXX_I2C1_IC_CON_BUS_CLEAR_FEATURE_CTRL_SIZE 1
#define IAXXX_I2C1_IC_CON_BUS_CLEAR_FEATURE_CTRL_DECL 11

/*** I2C1_IC_TAR (0x40059004) ***/
/*
 * I2C Target address register
 */
#define IAXXX_I2C1_IC_TAR_ADDR (0x40059004)
#define IAXXX_I2C1_IC_TAR_MASK_VAL 0x00001fff
#define IAXXX_I2C1_IC_TAR_RMASK_VAL 0x00001fff
#define IAXXX_I2C1_IC_TAR_WMASK_VAL 0x00001fff
#define IAXXX_I2C1_IC_TAR_RESET_VAL 0x00000055

/*
 * This is the targer address for any master transaction. When transmitting a
 * general call, these bits are ignored. To generate a START BYTE, the CPU
 * needs to write only once into these bits.
 */
#define IAXXX_I2C1_IC_TAR_IC_TAR_MASK 0x000003ff
#define IAXXX_I2C1_IC_TAR_IC_TAR_RESET_VAL 0x55
#define IAXXX_I2C1_IC_TAR_IC_TAR_POS 0
#define IAXXX_I2C1_IC_TAR_IC_TAR_SIZE 10
#define IAXXX_I2C1_IC_TAR_IC_TAR_DECL (9:0)

/*
 * If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General
 * call or START byte command is to be performed by DW_apb_i2c.
 */
#define IAXXX_I2C1_IC_TAR_GC_OR_START_MASK 0x00000400
#define IAXXX_I2C1_IC_TAR_GC_OR_START_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TAR_GC_OR_START_POS 10
#define IAXXX_I2C1_IC_TAR_GC_OR_START_SIZE 1
#define IAXXX_I2C1_IC_TAR_GC_OR_START_DECL 10

/*
 * This bit indicates whether software performs a General Call or START BYTE
 * command.
 *  0: ignore bit 10 GC_OR_START and use IC_TAR normally
 *  1: perform special I2C command as specified in GC_OR_START bit
 */
#define IAXXX_I2C1_IC_TAR_SPECIAL_MASK 0x00000800
#define IAXXX_I2C1_IC_TAR_SPECIAL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TAR_SPECIAL_POS 11
#define IAXXX_I2C1_IC_TAR_SPECIAL_SIZE 1
#define IAXXX_I2C1_IC_TAR_SPECIAL_DECL 11

/*
 * Master mode bit
 *  0: 7 bit addressing
 *  1: 10 bit addressing
 */
#define IAXXX_I2C1_IC_TAR_IC_10BITADDR_MASTER_MASK 0x00001000
#define IAXXX_I2C1_IC_TAR_IC_10BITADDR_MASTER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TAR_IC_10BITADDR_MASTER_POS 12
#define IAXXX_I2C1_IC_TAR_IC_10BITADDR_MASTER_SIZE 1
#define IAXXX_I2C1_IC_TAR_IC_10BITADDR_MASTER_DECL 12

/*** I2C1_IC_SAR (0x40059008) ***/
/*
 * I2C Slave address register
 */
#define IAXXX_I2C1_IC_SAR_ADDR (0x40059008)
#define IAXXX_I2C1_IC_SAR_MASK_VAL 0x000003ff
#define IAXXX_I2C1_IC_SAR_RMASK_VAL 0x000003ff
#define IAXXX_I2C1_IC_SAR_WMASK_VAL 0x000003ff
#define IAXXX_I2C1_IC_SAR_RESET_VAL 0x00000266

/*
 * Holds the slave address when I2C is operating as a slave. For 7 bit
 * addressing only [(6:0)] is used.
 */
#define IAXXX_I2C1_IC_SAR_IC_SAR_MASK 0x000003ff
#define IAXXX_I2C1_IC_SAR_IC_SAR_RESET_VAL 0x266
#define IAXXX_I2C1_IC_SAR_IC_SAR_POS 0
#define IAXXX_I2C1_IC_SAR_IC_SAR_SIZE 10
#define IAXXX_I2C1_IC_SAR_IC_SAR_DECL (9:0)

/*** I2C1_IC_HS_MADDR (0x4005900c) ***/
/*
 * I2C High Speed Master Mode Code Address Register
 */
#define IAXXX_I2C1_IC_HS_MADDR_ADDR (0x4005900c)
#define IAXXX_I2C1_IC_HS_MADDR_MASK_VAL 0x00000007
#define IAXXX_I2C1_IC_HS_MADDR_RMASK_VAL 0x00000007
#define IAXXX_I2C1_IC_HS_MADDR_WMASK_VAL 0x00000007
#define IAXXX_I2C1_IC_HS_MADDR_RESET_VAL 0x00000001

/*
 * This bit field holds the value of the I2C HS mode master code. HS-mode
 * master codes are reserved 8-bit codes (00001xxx) that are not used for
 * slave addressing or other purposes. Each master has its unique master
 * code; up to eight high-speed mode masters can be present on the same I2C
 * bus system. Valid values are from 0 to 7. This register goes away and
 * becomes read-only returning 0s if the IC_MAX_SPEED_MODE configuration
 * parameter is set to either Standard (1) or Fast (2). This register can be
 * written only when the I2C interface is disabled, which corresponds to the
 * IC_ENABLE register being set to 0. Writes at other times have no effect.
 */
#define IAXXX_I2C1_IC_HS_MADDR_IC_HS_MAR_MASK 0x00000007
#define IAXXX_I2C1_IC_HS_MADDR_IC_HS_MAR_RESET_VAL 0x1
#define IAXXX_I2C1_IC_HS_MADDR_IC_HS_MAR_POS 0
#define IAXXX_I2C1_IC_HS_MADDR_IC_HS_MAR_SIZE 3
#define IAXXX_I2C1_IC_HS_MADDR_IC_HS_MAR_DECL (2:0)

/*** I2C1_IC_DATA_CMD (0x40059010) ***/
/*
 * I2C RX/TX Data Buffer and Command register
 */
#define IAXXX_I2C1_IC_DATA_CMD_ADDR (0x40059010)
#define IAXXX_I2C1_IC_DATA_CMD_MASK_VAL 0x000007ff
#define IAXXX_I2C1_IC_DATA_CMD_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_DATA_CMD_WMASK_VAL 0x000007ff
#define IAXXX_I2C1_IC_DATA_CMD_RESET_VAL 0x00000000

/*
 * This register contains the data to be transmitted or received on the I2C
 * bus. If you are writing to this register and want to perform a read, bits
 * (7:0) (DAT) are ignored by the DW_apb_i2c. However, when you read this
 * register, these bits return the value of data received on the DW_apb_i2c
 * interface.
 */
#define IAXXX_I2C1_IC_DATA_CMD_DAT_MASK 0x000000ff
#define IAXXX_I2C1_IC_DATA_CMD_DAT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DATA_CMD_DAT_POS 0
#define IAXXX_I2C1_IC_DATA_CMD_DAT_SIZE 8
#define IAXXX_I2C1_IC_DATA_CMD_DAT_DECL (7:0)

/*
 * This bit controls whether a read or a write is performed. This bit does
 * not control the direction when the DW_apb_i2c acts as a slave. It controls
 * only the direction when it acts as a master. 1 = Read 0 = Write
 * When a command is entered in the TX FIFO, this bit distinguishes the write
 * and read commands. In slave-receiver mode, this bit is a dont care because
 * writes to this register are not required. In slave-transmitter mode, a 0
 * indicates that CPU data is to be transmitted and as DAT or
 * IC_DATA_CMD[(7:0)].
 * When programming this bit, you should remember the following: attempting
 * to perform a read operation after a General Call command has been sent
 * results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register),
 * unless bit 11 (SPECIAL) in the IC_TAR register has been cleared.
 * If a 1 is written to this bit after receiving a RD_REQ interrupt, then a
 * TX_ABRT interrupt occurs. NOTE: It is possible that while attempting a
 * master I2C read transfer on DW_apb_i2c, a RD_REQ interrupt may have
 * occurred simultaneously due to a remote I2C master addressing DW_apb_i2c.
 * In this type of scenario, DW_apb_i2c ignores the IC_DATA_CMD write,
 * generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt
 */
#define IAXXX_I2C1_IC_DATA_CMD_CMD_MASK 0x00000100
#define IAXXX_I2C1_IC_DATA_CMD_CMD_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DATA_CMD_CMD_POS 8
#define IAXXX_I2C1_IC_DATA_CMD_CMD_SIZE 1
#define IAXXX_I2C1_IC_DATA_CMD_CMD_DECL 8

/*
 * This bit controls whether a STOP is issued after the byte is sent or
 * received.
 *  0: STOP is not issued after this byte, regardless of whether or not the
 * Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the
 * current transfer by sending/receiving data bytes according to the value of
 * the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low
 * and stalls the bus until a new command is available in the Tx FIFO.
 *  1: STOP is issued after this byte, regardless of whether or not the Tx
 * FIFO is empty. If the Tx FIFO is not empty, the master immediately tries
 * to start a new transfer by issuing a START and arbitrating for the bus.
 */
#define IAXXX_I2C1_IC_DATA_CMD_STOP_MASK 0x00000200
#define IAXXX_I2C1_IC_DATA_CMD_STOP_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DATA_CMD_STOP_POS 9
#define IAXXX_I2C1_IC_DATA_CMD_STOP_SIZE 1
#define IAXXX_I2C1_IC_DATA_CMD_STOP_DECL 9

/*
 * This bit controls whether a RESTART is issued before the byte is sent or
 * received.
 *  0: If IC_RESTART_EN is 1, a RESTART is issued only if the transfer
 * direction is changing from the previous command; if IC_RESTART_EN is 0, a
 * STOP followed by a START is issued instead.
 *
 1: If IC_RESTART_EN is 1, a RESTART is issued before the data is
 * sent/received (according to the value of CMD), regardless of whether or
 * not the transfer direction is changing from the previous command; if
 * IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
 */
#define IAXXX_I2C1_IC_DATA_CMD_RESTART_MASK 0x00000400
#define IAXXX_I2C1_IC_DATA_CMD_RESTART_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DATA_CMD_RESTART_POS 10
#define IAXXX_I2C1_IC_DATA_CMD_RESTART_SIZE 1
#define IAXXX_I2C1_IC_DATA_CMD_RESTART_DECL 10

/*** I2C1_IC_SS_SCL_HCNT (0x40059014) ***/
/*
 * Standard speed I2C Clock SCL High count register
 */
#define IAXXX_I2C1_IC_SS_SCL_HCNT_ADDR (0x40059014)
#define IAXXX_I2C1_IC_SS_SCL_HCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_HCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_HCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_HCNT_RESET_VAL 0x00000190

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock high-period
 * count for standard speed.
 */
#define IAXXX_I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_RESET_VAL 0x190
#define IAXXX_I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_POS 0
#define IAXXX_I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_SIZE 16
#define IAXXX_I2C1_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_DECL (15:0)

/*** I2C1_IC_SS_SCL_LCNT (0x40059018) ***/
/*
 * Standard speed I2C Clock SCL Low count register
 */
#define IAXXX_I2C1_IC_SS_SCL_LCNT_ADDR (0x40059018)
#define IAXXX_I2C1_IC_SS_SCL_LCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_LCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_LCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_LCNT_RESET_VAL 0x000001d6

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock low period
 * count for standard speed.
 */
#define IAXXX_I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_RESET_VAL 0x1d6
#define IAXXX_I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_POS 0
#define IAXXX_I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_SIZE 16
#define IAXXX_I2C1_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_DECL (15:0)

/*** I2C1_IC_FS_SCL_HCNT (0x4005901c) ***/
/*
 * Fast speed I2C Clock SCL High count register
 */
#define IAXXX_I2C1_IC_FS_SCL_HCNT_ADDR (0x4005901c)
#define IAXXX_I2C1_IC_FS_SCL_HCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_HCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_HCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_HCNT_RESET_VAL 0x0000003c

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock high period
 * count for fast speed.
 */
#define IAXXX_I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_RESET_VAL 0x3c
#define IAXXX_I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_POS 0
#define IAXXX_I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_SIZE 16
#define IAXXX_I2C1_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_DECL (15:0)

/*** I2C1_IC_FS_SCL_LCNT (0x40059020) ***/
/*
 * Fast speed I2C Clock SCL Low count register
 */
#define IAXXX_I2C1_IC_FS_SCL_LCNT_ADDR (0x40059020)
#define IAXXX_I2C1_IC_FS_SCL_LCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_LCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_LCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_LCNT_RESET_VAL 0x00000082

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock low period
 * count for fast speed.
 */
#define IAXXX_I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_RESET_VAL 0x82
#define IAXXX_I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_POS 0
#define IAXXX_I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_SIZE 16
#define IAXXX_I2C1_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_DECL (15:0)

/*** I2C1_IC_HS_SCL_HCNT (0x40059024) ***/
/*
 * Fast speed I2C Clock SCL High count register
 */
#define IAXXX_I2C1_IC_HS_SCL_HCNT_ADDR (0x40059024)
#define IAXXX_I2C1_IC_HS_SCL_HCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_HCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_HCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_HCNT_RESET_VAL 0x00000006

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock high period
 * count for high speed.
 */
#define IAXXX_I2C1_IC_HS_SCL_HCNT_IC_HS_SCL_HCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_HCNT_IC_HS_SCL_HCNT_RESET_VAL 0x6
#define IAXXX_I2C1_IC_HS_SCL_HCNT_IC_HS_SCL_HCNT_POS 0
#define IAXXX_I2C1_IC_HS_SCL_HCNT_IC_HS_SCL_HCNT_SIZE 16
#define IAXXX_I2C1_IC_HS_SCL_HCNT_IC_HS_SCL_HCNT_DECL (15:0)

/*** I2C1_IC_HS_SCL_LCNT (0x40059028) ***/
/*
 * Fast speed I2C Clock SCL Low count register
 */
#define IAXXX_I2C1_IC_HS_SCL_LCNT_ADDR (0x40059028)
#define IAXXX_I2C1_IC_HS_SCL_LCNT_MASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_LCNT_RMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_LCNT_WMASK_VAL 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_LCNT_RESET_VAL 0x00000010

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure proper I/O timing. This register sets the SCL clock low period
 * count for high speed.
 */
#define IAXXX_I2C1_IC_HS_SCL_LCNT_IC_FS_SCL_LCNT_MASK 0x0000ffff
#define IAXXX_I2C1_IC_HS_SCL_LCNT_IC_FS_SCL_LCNT_RESET_VAL 0x10
#define IAXXX_I2C1_IC_HS_SCL_LCNT_IC_FS_SCL_LCNT_POS 0
#define IAXXX_I2C1_IC_HS_SCL_LCNT_IC_FS_SCL_LCNT_SIZE 16
#define IAXXX_I2C1_IC_HS_SCL_LCNT_IC_FS_SCL_LCNT_DECL (15:0)

/*** I2C1_IC_INTR_STAT (0x4005902c) ***/
/*
 * I2C Interrupt status register
 */
#define IAXXX_I2C1_IC_INTR_STAT_ADDR (0x4005902c)
#define IAXXX_I2C1_IC_INTR_STAT_MASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_INTR_STAT_RMASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_INTR_STAT_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_INTR_STAT_RESET_VAL 0x00000000

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_UNDER_MASK 0x00000001
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_UNDER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_UNDER_POS 0
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_UNDER_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_UNDER_DECL 0

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_OVER_MASK 0x00000002
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_OVER_POS 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_OVER_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_OVER_DECL 1

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_FULL_MASK 0x00000004
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_FULL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_FULL_POS 2
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_FULL_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_FULL_DECL 2

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_OVER_MASK 0x00000008
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_OVER_POS 3
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_OVER_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_OVER_DECL 3

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_EMPTY_MASK 0x00000010
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_EMPTY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_EMPTY_POS 4
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_EMPTY_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_EMPTY_DECL 4

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_RD_REQ_MASK 0x00000020
#define IAXXX_I2C1_IC_INTR_STAT_R_RD_REQ_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_RD_REQ_POS 5
#define IAXXX_I2C1_IC_INTR_STAT_R_RD_REQ_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RD_REQ_DECL 5

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_ABRT_MASK 0x00000040
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_ABRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_ABRT_POS 6
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_ABRT_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_TX_ABRT_DECL 6

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_DONE_MASK 0x00000080
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_DONE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_DONE_POS 7
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_DONE_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_RX_DONE_DECL 7

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_ACTIVITY_MASK 0x00000100
#define IAXXX_I2C1_IC_INTR_STAT_R_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_ACTIVITY_POS 8
#define IAXXX_I2C1_IC_INTR_STAT_R_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_ACTIVITY_DECL 8

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_STOP_DET_MASK 0x00000200
#define IAXXX_I2C1_IC_INTR_STAT_R_STOP_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_STOP_DET_POS 9
#define IAXXX_I2C1_IC_INTR_STAT_R_STOP_DET_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_STOP_DET_DECL 9

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_START_DET_MASK 0x00000400
#define IAXXX_I2C1_IC_INTR_STAT_R_START_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_START_DET_POS 10
#define IAXXX_I2C1_IC_INTR_STAT_R_START_DET_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_START_DET_DECL 10

/*
 * See IC_RAW_INTR_STAT for details
 */
#define IAXXX_I2C1_IC_INTR_STAT_R_GEN_CALL_MASK 0x00000800
#define IAXXX_I2C1_IC_INTR_STAT_R_GEN_CALL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_STAT_R_GEN_CALL_POS 11
#define IAXXX_I2C1_IC_INTR_STAT_R_GEN_CALL_SIZE 1
#define IAXXX_I2C1_IC_INTR_STAT_R_GEN_CALL_DECL 11

/*** I2C1_IC_INTR_MASK (0x40059030) ***/
/*
 * I2C Interrupt mask register
 */
#define IAXXX_I2C1_IC_INTR_MASK_ADDR (0x40059030)
#define IAXXX_I2C1_IC_INTR_MASK_MASK_VAL 0x00007fff
#define IAXXX_I2C1_IC_INTR_MASK_RMASK_VAL 0x00007fff
#define IAXXX_I2C1_IC_INTR_MASK_WMASK_VAL 0x00007fff
#define IAXXX_I2C1_IC_INTR_MASK_RESET_VAL 0x000048ff

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_UNDER_MASK 0x00000001
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_UNDER_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_UNDER_POS 0
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_UNDER_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_UNDER_DECL 0

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_OVER_MASK 0x00000002
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_OVER_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_OVER_POS 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_OVER_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_OVER_DECL 1

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_FULL_MASK 0x00000004
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_FULL_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_FULL_POS 2
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_FULL_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_FULL_DECL 2

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_OVER_MASK 0x00000008
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_OVER_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_OVER_POS 3
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_OVER_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_OVER_DECL 3

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_EMPTY_MASK 0x00000010
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_EMPTY_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_EMPTY_POS 4
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_EMPTY_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_EMPTY_DECL 4

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RD_REQ_MASK 0x00000020
#define IAXXX_I2C1_IC_INTR_MASK_M_RD_REQ_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_RD_REQ_POS 5
#define IAXXX_I2C1_IC_INTR_MASK_M_RD_REQ_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RD_REQ_DECL 5

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_ABRT_MASK 0x00000040
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_ABRT_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_ABRT_POS 6
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_ABRT_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_TX_ABRT_DECL 6

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_DONE_MASK 0x00000080
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_DONE_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_DONE_POS 7
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_DONE_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RX_DONE_DECL 7

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_ACTIVITY_MASK 0x00000100
#define IAXXX_I2C1_IC_INTR_MASK_M_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_MASK_M_ACTIVITY_POS 8
#define IAXXX_I2C1_IC_INTR_MASK_M_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_ACTIVITY_DECL 8

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_STOP_DET_MASK 0x00000200
#define IAXXX_I2C1_IC_INTR_MASK_M_STOP_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_MASK_M_STOP_DET_POS 9
#define IAXXX_I2C1_IC_INTR_MASK_M_STOP_DET_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_STOP_DET_DECL 9

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_START_DET_MASK 0x00000400
#define IAXXX_I2C1_IC_INTR_MASK_M_START_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_MASK_M_START_DET_POS 10
#define IAXXX_I2C1_IC_INTR_MASK_M_START_DET_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_START_DET_DECL 10

/*
 * Masks corresponding bits in IC_INTR_STAT
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_GEN_CALL_MASK 0x00000800
#define IAXXX_I2C1_IC_INTR_MASK_M_GEN_CALL_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_GEN_CALL_POS 11
#define IAXXX_I2C1_IC_INTR_MASK_M_GEN_CALL_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_GEN_CALL_DECL 11

/*
 * This bit masks the R_RESTART_DET interrupt status bit in the IC_INTR_STAT
 * register.
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_RESTART_DET_MASK 0x00001000
#define IAXXX_I2C1_IC_INTR_MASK_M_RESTART_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_MASK_M_RESTART_DET_POS 12
#define IAXXX_I2C1_IC_INTR_MASK_M_RESTART_DET_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_RESTART_DET_DECL 12

/*
 * This bit masks the R_MST_ON_HOLD interrupt bit in the IC_INTR_STAT
 * register.
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_ON_HOLD_MASK 0x00002000
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_ON_HOLD_RESET_VAL 0x0
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_ON_HOLD_POS 13
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_ON_HOLD_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_ON_HOLD_DECL 13

/*
 * This bit mask the R_SCL_STUCK_AT_LOW interrupt in IC_INTR_STAT register.
 *  0x1(DISABLED):SCL_STUCK_AT_LOW interrupt is unmasked
 *  0x0(DISABLED):SCL_STUCK_AT_LOW interrupt is masked.
 */
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_STUCK_AT_LOW_MASK 0x00004000
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_STUCK_AT_LOW_RESET_VAL 0x1
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_STUCK_AT_LOW_POS 14
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_STUCK_AT_LOW_SIZE 1
#define IAXXX_I2C1_IC_INTR_MASK_M_MST_STUCK_AT_LOW_DECL 14

/*** I2C1_IC_RAW_INTR_STAT (0x40059034) ***/
/*
 * I2C Raw Interrupt Status register
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ADDR (0x40059034)
#define IAXXX_I2C1_IC_RAW_INTR_STAT_MASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RMASK_VAL 0x00000fff
#define IAXXX_I2C1_IC_RAW_INTR_STAT_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RESET_VAL 0x00000000

/*
 * Set if the processor attempts to read the receive buffer when it is empty
 * by reading from the IC_DATA_CMD register.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_UNDER_MASK 0x00000001
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_UNDER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_UNDER_POS 0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_UNDER_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_UNDER_DECL 0

/*
 * Set if the receive buffer is completely filled and an additional byte is
 * received from external I2C device. The DW_apb_i2c acknowledges this but
 * any data bytes received after the FIFO is full are lost.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_OVER_MASK 0x00000002
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_OVER_POS 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_OVER_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_OVER_DECL 1

/*
 * Set when the receive buffer reaches or goes above the RX_TL threshold in
 * the IC_RX_TL register. It is automatically cleared by hardware when buffer
 * level goes below the threshold.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_FULL_MASK 0x00000004
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_FULL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_FULL_POS 2
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_FULL_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_FULL_DECL 2

/*
 * Set during transmit if the transmit buffer is filled and the processor
 * attempts to issue another I2C command by writing to the IC_DATA_CMD
 * register.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_OVER_MASK 0x00000008
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_OVER_POS 3
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_OVER_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_OVER_DECL 3

/*
 * This bit is set to 1 when the transmit buffer is at or below the threshold
 * value set in the IC_TX_TL register. It is automatically cleared by
 * hardware when the buffer level goes above the threshold.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_EMPTY_MASK 0x00000010
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_EMPTY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_EMPTY_POS 4
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_EMPTY_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_EMPTY_DECL 4

/*
 * This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C
 * master is attempting to read data from DW_apb_i2c. The DW_apb_i2c hold the
 * I2C bus in a wait state (SCL=0) unti this interrupt is serviced, which
 * means that the slave has been addressed by a remote master that is asking
 * for data to be transferred.The processor must respond to this interrupt
 * and then write the requested data IC_DATA_CMD register. This bit is set to
 * 0 just after processor read the IC_CLR_RD_REQ register.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RD_REQ_MASK 0x00000020
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RD_REQ_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RD_REQ_POS 5
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RD_REQ_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RD_REQ_DECL 5

/*
 * This bit indicates if DW_apb_i2c, as a I2C transmitter, is unable to
 * complete the intended actions on the contents of the transmit FIFO. The
 * situation can occur both as an I2C master or an I2C slave, and is referred
 * to as a transmit abort.When this bit is set to 1, the IC_TX_ABRT_SOURCE
 * register indicates the reason why the transmit abort took place.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_ABRT_MASK 0x00000040
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_ABRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_ABRT_POS 6
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_ABRT_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_TX_ABRT_DECL 6

/*
 * When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1
 * if the master does not acknowledge a transmitted byte. This occurs on the
 * last byte of the transmission, indicating that the transmission is done.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_DONE_MASK 0x00000080
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_DONE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_DONE_POS 7
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_DONE_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_RX_DONE_DECL 7

/*
 * This bit captures DW_apb_i2c activity and stays set until it is cleared.
 * There are four ways to clear it:
 *
 * Disabling DW_apb_i2c
 * * Reading the IC_CLR_ACTIVITY register
 * * Reading the IC_CLR_INTR register
 * * System reset
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ACTIVITY_MASK 0x00000100
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ACTIVITY_POS 8
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_ACTIVITY_DECL 8

/*
 * Indicates whether a STOP condition has occurred on the I2C interface
 * regardless of whether DW_apb_i2c is operating in slave or master mode.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_STOP_DET_MASK 0x00000200
#define IAXXX_I2C1_IC_RAW_INTR_STAT_STOP_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_STOP_DET_POS 9
#define IAXXX_I2C1_IC_RAW_INTR_STAT_STOP_DET_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_STOP_DET_DECL 9

/*
 * Indicates whether a START or RESTART condition has occurred on the I2C
 * interface regardless of whether DW_apb_i2c is operating in slave or master
 * mode.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_START_DET_MASK 0x00000400
#define IAXXX_I2C1_IC_RAW_INTR_STAT_START_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_START_DET_POS 10
#define IAXXX_I2C1_IC_RAW_INTR_STAT_START_DET_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_START_DET_DECL 10

/*
 * Set only when a General Call address is received and it is acknowledged.
 * It stays set until it is cleared either by disabling DW_apb_i2c or when
 * the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the
 * received data in Rx buffer.
 */
#define IAXXX_I2C1_IC_RAW_INTR_STAT_GEN_CALL_MASK 0x00000800
#define IAXXX_I2C1_IC_RAW_INTR_STAT_GEN_CALL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RAW_INTR_STAT_GEN_CALL_POS 11
#define IAXXX_I2C1_IC_RAW_INTR_STAT_GEN_CALL_SIZE 1
#define IAXXX_I2C1_IC_RAW_INTR_STAT_GEN_CALL_DECL 11

/*** I2C1_IC_RX_TL (0x40059038) ***/
/*
 * I2C Receive FIFO Threshold register
 */
#define IAXXX_I2C1_IC_RX_TL_ADDR (0x40059038)
#define IAXXX_I2C1_IC_RX_TL_MASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_RX_TL_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_RX_TL_WMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_RX_TL_RESET_VAL 0x00000000

/*
 * Receive FIFO Threshold Level; Controls the level of entries (or above)
 * that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register).
 * The valid range is 0-255, with the additional restriction that hardware
 * does not allow this value to be set to a value larger than the depth of
 * the buffer. If an attempt is made to do that, the actual value set will be
 * the maximum depth of the buffer.
 *  A value of 0 sets the threshold for 1 entry, and a value of 255 sets the
 * threshold for 256 entries.
 */
#define IAXXX_I2C1_IC_RX_TL_RX_TL_MASK 0x000000ff
#define IAXXX_I2C1_IC_RX_TL_RX_TL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RX_TL_RX_TL_POS 0
#define IAXXX_I2C1_IC_RX_TL_RX_TL_SIZE 8
#define IAXXX_I2C1_IC_RX_TL_RX_TL_DECL (7:0)

/*** I2C1_IC_TX_TL (0x4005903c) ***/
/*
 * I2C Transmit FIFO Threshold register
 */
#define IAXXX_I2C1_IC_TX_TL_ADDR (0x4005903c)
#define IAXXX_I2C1_IC_TX_TL_MASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_TX_TL_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_TX_TL_WMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_TX_TL_RESET_VAL 0x00000000

/*
 * Transmit FIFO Threshold Level ;Controls the level of entries (or below)
 * that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register).
 * The valid range is 0-255, with the additional restriction that it may not
 * be set to value larger than the depth of the buffer. If an attempt is made
 * to do that, the actual value set will be the maximum depth of the buffer.
 *  A value of 0 sets the threshold for 0 entries, and a value of 255 sets
 * the threshold for 255 entries.
 */
#define IAXXX_I2C1_IC_TX_TL_TX_TL_MASK 0x000000ff
#define IAXXX_I2C1_IC_TX_TL_TX_TL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_TL_TX_TL_POS 0
#define IAXXX_I2C1_IC_TX_TL_TX_TL_SIZE 8
#define IAXXX_I2C1_IC_TX_TL_TX_TL_DECL (7:0)

/*** I2C1_IC_CLR_INTR (0x40059040) ***/
/*
 * Clear Combined and Individual Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_INTR_ADDR (0x40059040)
#define IAXXX_I2C1_IC_CLR_INTR_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_INTR_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_INTR_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_INTR_RESET_VAL 0x00000000

/*
 * Read this register to clear the combined interrupt, all individual
 * interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear
 * hardware clearable interrupts but software clearable interrupts. Refer to
 * Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing
 * IC_TX_ABRT_SOURCE.
 */
#define IAXXX_I2C1_IC_CLR_INTR_CLR_INTR_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_INTR_CLR_INTR_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_INTR_CLR_INTR_POS 0
#define IAXXX_I2C1_IC_CLR_INTR_CLR_INTR_SIZE 1
#define IAXXX_I2C1_IC_CLR_INTR_CLR_INTR_DECL 0

/*** I2C1_IC_CLR_RX_UNDER (0x40059044) ***/
/*
 * Clear RX_UNDER Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_RX_UNDER_ADDR (0x40059044)
#define IAXXX_I2C1_IC_CLR_RX_UNDER_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_UNDER_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_UNDER_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_RX_UNDER_RESET_VAL 0x00000000

/*
 * Read this register to clear the RX_UNDER interrupt (bit 0) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER_POS 0
#define IAXXX_I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER_SIZE 1
#define IAXXX_I2C1_IC_CLR_RX_UNDER_CLR_RX_UNDER_DECL 0

/*** I2C1_IC_CLR_RX_OVER (0x40059048) ***/
/*
 * Clear RX_OVER Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_RX_OVER_ADDR (0x40059048)
#define IAXXX_I2C1_IC_CLR_RX_OVER_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_OVER_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_OVER_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_RX_OVER_RESET_VAL 0x00000000

/*
 * Read this register to clear the RX_OVER interrupt (bit 1) of the
 * IC_RAW_INTR_STAT register
 */
#define IAXXX_I2C1_IC_CLR_RX_OVER_CLR_RX_OVER_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_OVER_CLR_RX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_RX_OVER_CLR_RX_OVER_POS 0
#define IAXXX_I2C1_IC_CLR_RX_OVER_CLR_RX_OVER_SIZE 1
#define IAXXX_I2C1_IC_CLR_RX_OVER_CLR_RX_OVER_DECL 0

/*** I2C1_IC_CLR_TX_OVER (0x4005904c) ***/
/*
 * Clear TX_OVER Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_TX_OVER_ADDR (0x4005904c)
#define IAXXX_I2C1_IC_CLR_TX_OVER_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_OVER_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_OVER_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_TX_OVER_RESET_VAL 0x00000000

/*
 * Read this register to clear the TX_OVER interrupt (bit 2) of the
 * IC_RAW_INTR_STAT register
 */
#define IAXXX_I2C1_IC_CLR_TX_OVER_CLR_TX_OVER_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_OVER_CLR_TX_OVER_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_TX_OVER_CLR_TX_OVER_POS 0
#define IAXXX_I2C1_IC_CLR_TX_OVER_CLR_TX_OVER_SIZE 1
#define IAXXX_I2C1_IC_CLR_TX_OVER_CLR_TX_OVER_DECL 0

/*** I2C1_IC_CLR_RD_REQ (0x40059050) ***/
/*
 * Clear RD_REQ Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_RD_REQ_ADDR (0x40059050)
#define IAXXX_I2C1_IC_CLR_RD_REQ_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RD_REQ_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RD_REQ_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_RD_REQ_RESET_VAL 0x00000000

/*
 * Read this register to clear the RD_REQ interrupt (bit 5) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_RD_REQ_CLR_RD_REQ_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_RD_REQ_CLR_RD_REQ_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_RD_REQ_CLR_RD_REQ_POS 0
#define IAXXX_I2C1_IC_CLR_RD_REQ_CLR_RD_REQ_SIZE 1
#define IAXXX_I2C1_IC_CLR_RD_REQ_CLR_RD_REQ_DECL 0

/*** I2C1_IC_CLR_TX_ABRT (0x40059054) ***/
/*
 * Clear TX_ABRT Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_TX_ABRT_ADDR (0x40059054)
#define IAXXX_I2C1_IC_CLR_TX_ABRT_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_ABRT_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_ABRT_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_TX_ABRT_RESET_VAL 0x00000000

/*
 * Read this register to clear the TX_ABRT interrupt (bit 6) of the
 * IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also
 * releases the TX FIFO from the flushed/reset state, allowing more writes to
 * the TX FIFO.
 *  Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to
 * clearing IC_TX_ABRT_SOURCE.
 */
#define IAXXX_I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT_POS 0
#define IAXXX_I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT_SIZE 1
#define IAXXX_I2C1_IC_CLR_TX_ABRT_CLR_TX_ABRT_DECL 0

/*** I2C1_IC_CLR_RX_DONE (0x40059058) ***/
/*
 * Clear RX_DONE Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_RX_DONE_ADDR (0x40059058)
#define IAXXX_I2C1_IC_CLR_RX_DONE_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_DONE_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_DONE_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_RX_DONE_RESET_VAL 0x00000000

/*
 * Read this register to clear the RX_DONE interrupt (bit 7) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_RX_DONE_CLR_RX_DONE_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_RX_DONE_CLR_RX_DONE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_RX_DONE_CLR_RX_DONE_POS 0
#define IAXXX_I2C1_IC_CLR_RX_DONE_CLR_RX_DONE_SIZE 1
#define IAXXX_I2C1_IC_CLR_RX_DONE_CLR_RX_DONE_DECL 0

/*** I2C1_IC_CLR_ACTIVITY (0x4005905c) ***/
/*
 * Clear ACTIVITY Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_ACTIVITY_ADDR (0x4005905c)
#define IAXXX_I2C1_IC_CLR_ACTIVITY_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_ACTIVITY_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_ACTIVITY_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_ACTIVITY_RESET_VAL 0x00000000

/*
 * Reading this register clears the ACTIVITY interrupt if the I2C is not
 * active anymore. If the I2C module is still active on the bus, the ACTIVITY
 * interrupt bit continues to be set. It is automatically cleared by hardware
 * if the module is disabled and if there is no further activity on the bus.
 * The value read from this register to get status of the ACTIVITY interrupt
 * (bit 8) of the IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY_POS 0
#define IAXXX_I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_CLR_ACTIVITY_CLR_ACTIVITY_DECL 0

/*** I2C1_IC_CLR_STOP_DET (0x40059060) ***/
/*
 * Clear STOP_DET Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_STOP_DET_ADDR (0x40059060)
#define IAXXX_I2C1_IC_CLR_STOP_DET_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_STOP_DET_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_STOP_DET_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_STOP_DET_RESET_VAL 0x00000000

/*
 * Read this register to clear the STOP_DET interrupt (bit 9) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_STOP_DET_CLR_STOP_DET_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_STOP_DET_CLR_STOP_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_STOP_DET_CLR_STOP_DET_POS 0
#define IAXXX_I2C1_IC_CLR_STOP_DET_CLR_STOP_DET_SIZE 1
#define IAXXX_I2C1_IC_CLR_STOP_DET_CLR_STOP_DET_DECL 0

/*** I2C1_IC_CLR_START_DET (0x40059064) ***/
/*
 * Clear START_DET Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_START_DET_ADDR (0x40059064)
#define IAXXX_I2C1_IC_CLR_START_DET_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_START_DET_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_START_DET_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_START_DET_RESET_VAL 0x00000000

/*
 * Read this register to clear the START_DET interrupt (bit 10) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_START_DET_CLR_START_DET_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_START_DET_CLR_START_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_START_DET_CLR_START_DET_POS 0
#define IAXXX_I2C1_IC_CLR_START_DET_CLR_START_DET_SIZE 1
#define IAXXX_I2C1_IC_CLR_START_DET_CLR_START_DET_DECL 0

/*** I2C1_IC_CLR_GEN_CALL (0x40059068) ***/
/*
 * Clear GEN_CALL Interrupt Register
 */
#define IAXXX_I2C1_IC_CLR_GEN_CALL_ADDR (0x40059068)
#define IAXXX_I2C1_IC_CLR_GEN_CALL_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_GEN_CALL_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_GEN_CALL_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_GEN_CALL_RESET_VAL 0x00000000

/*
 * Read this register to clear the GEN_CALL interrupt (bit 11) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL_POS 0
#define IAXXX_I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL_SIZE 1
#define IAXXX_I2C1_IC_CLR_GEN_CALL_CLR_GEN_CALL_DECL 0

/*** I2C1_IC_ENABLE (0x4005906c) ***/
/*
 * I2C Enable Register
 */
#define IAXXX_I2C1_IC_ENABLE_ADDR (0x4005906c)
#define IAXXX_I2C1_IC_ENABLE_MASK_VAL 0x00000003
#define IAXXX_I2C1_IC_ENABLE_RMASK_VAL 0x00000003
#define IAXXX_I2C1_IC_ENABLE_WMASK_VAL 0x00000003
#define IAXXX_I2C1_IC_ENABLE_RESET_VAL 0x00000000

/*
 * Controls whether the DW_apb_i2c is enabled.
 *  0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state)
 *  1: Enables DW_apb_i2c
 *  Software can disable DW_apb_i2c while it is active. However, it is
 * important that care be taken to ensure that DW_apb_i2c is disabled
 * properly. A recommended procedure is described in Disabling DW_apb_i2c on
 * page 53. When DW_apb_i2c is disabled, the following occurs:
 *  - The TX FIFO and RX FIFO get flushed.
 *  - Status bits in the IC_INTR_STAT register are still active until
 * DW_apb_i2c goes into IDLE state.
 *  If the module is transmitting, it stops as well as deletes the contents
 * of the transmit buffer after the current transfer is complete. If the
 * module is receiving, the DW_apb_i2c stops the current transfer at the end
 * of the current byte and does not acknowledge the transfer.
 *  In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter
 * set to asynchronous (1), there is a two ic_clk delay when enabling or
 * disabling the DW_apb_i2c.
 *  For a detailed description on how to disable DW_apb_i2c, refer to
 * Disabling DW_apb_i2c on page 53.
 */
#define IAXXX_I2C1_IC_ENABLE_ENABLE_MASK 0x00000001
#define IAXXX_I2C1_IC_ENABLE_ENABLE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_ENABLE_ENABLE_POS 0
#define IAXXX_I2C1_IC_ENABLE_ENABLE_SIZE 1
#define IAXXX_I2C1_IC_ENABLE_ENABLE_DECL 0

/*
 * When set, the controller initiates the transfer abort.
 *  0: ABORT not initiated or ABORT done
 *  1: ABORT operation in progress
 *  The software can abort the I2C transfer in master mode by setting this
 * bit. The software can set this bit only when ENABLE is already set;
 * otherwise, the controller ignores any write to ABORT bit. The software
 * cannot clear the ABORT bit once set. In response to an ABORT, the
 * controller issues a STOP and flushes the Tx FIFO after completing the
 * current transfer, then sets the TX_ABORT interrupt after the abort
 * operation. The ABORT bit is cleared automatically after the abort
 * operation.
 *  For a detailed description on how to abort I2C transfers, refer to
 * Aborting I2C Transfers on page 54
 */
#define IAXXX_I2C1_IC_ENABLE_ABORT_MASK 0x00000002
#define IAXXX_I2C1_IC_ENABLE_ABORT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_ENABLE_ABORT_POS 1
#define IAXXX_I2C1_IC_ENABLE_ABORT_SIZE 1
#define IAXXX_I2C1_IC_ENABLE_ABORT_DECL 1

/*** I2C1_IC_STATUS (0x40059070) ***/
/*
 * I2C Status Register
 */
#define IAXXX_I2C1_IC_STATUS_ADDR (0x40059070)
#define IAXXX_I2C1_IC_STATUS_MASK_VAL 0x0000007f
#define IAXXX_I2C1_IC_STATUS_RMASK_VAL 0x0000007f
#define IAXXX_I2C1_IC_STATUS_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_STATUS_RESET_VAL 0x00000006

/*
 * I2C Activity status
 */
#define IAXXX_I2C1_IC_STATUS_ACTIVITY_MASK 0x00000001
#define IAXXX_I2C1_IC_STATUS_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_STATUS_ACTIVITY_POS 0
#define IAXXX_I2C1_IC_STATUS_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_STATUS_ACTIVITY_DECL 0

/*
 * Transmit FIFO Not Full. Set when the transmit FIFO contains one or more
 * empty locations, and is cleared when the FIFO is full.
 *  0: Transmit FIFO is full
 *  1: Transmit FIFO is not full
 */
#define IAXXX_I2C1_IC_STATUS_TFNF_MASK 0x00000002
#define IAXXX_I2C1_IC_STATUS_TFNF_RESET_VAL 0x1
#define IAXXX_I2C1_IC_STATUS_TFNF_POS 1
#define IAXXX_I2C1_IC_STATUS_TFNF_SIZE 1
#define IAXXX_I2C1_IC_STATUS_TFNF_DECL 1

/*
 * Transmit FIFO Completely Empty. When the transmit FIFO is completely
 * empty, this bit is set. When it contains one or more valid entries, this
 * bit is cleared. This bit field does not request an interrupt.
 *  0: Transmit FIFO is not empty
 *  1: Transmit FIFO is empty
 */
#define IAXXX_I2C1_IC_STATUS_TFE_MASK 0x00000004
#define IAXXX_I2C1_IC_STATUS_TFE_RESET_VAL 0x1
#define IAXXX_I2C1_IC_STATUS_TFE_POS 2
#define IAXXX_I2C1_IC_STATUS_TFE_SIZE 1
#define IAXXX_I2C1_IC_STATUS_TFE_DECL 2

/*
 * Receive FIFO Not Empty. This bit is set when the receive FIFO contains one
 * or more entries; it is cleared when the receive FIFO is empty.
 *  0: Receive FIFO is empty
 *  1: Receive FIFO is not empty
 */
#define IAXXX_I2C1_IC_STATUS_RFNE_MASK 0x00000008
#define IAXXX_I2C1_IC_STATUS_RFNE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_STATUS_RFNE_POS 3
#define IAXXX_I2C1_IC_STATUS_RFNE_SIZE 1
#define IAXXX_I2C1_IC_STATUS_RFNE_DECL 3

/*
 * Receive FIFO Completely Full. When the receive FIFO is completely full,
 * this bit is set. When the receive FIFO contains one or more empty
 * location, this bit is cleared.
 *  0: Receive FIFO is not full
 *  1: Receive FIFO is full
 */
#define IAXXX_I2C1_IC_STATUS_RFF_MASK 0x00000010
#define IAXXX_I2C1_IC_STATUS_RFF_RESET_VAL 0x0
#define IAXXX_I2C1_IC_STATUS_RFF_POS 4
#define IAXXX_I2C1_IC_STATUS_RFF_SIZE 1
#define IAXXX_I2C1_IC_STATUS_RFF_DECL 4

/*
 * Master FSM Activity Status. When the Master Finite State Machine (FSM) is
 * not in the IDLE state, this bit is set.
 *  0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not
 * Active
 *  1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is
 * Active
 */
#define IAXXX_I2C1_IC_STATUS_MST_ACTIVITY_MASK 0x00000020
#define IAXXX_I2C1_IC_STATUS_MST_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_STATUS_MST_ACTIVITY_POS 5
#define IAXXX_I2C1_IC_STATUS_MST_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_STATUS_MST_ACTIVITY_DECL 5

/*
 * Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is
 * not in the IDLE state, this bit is set.
 *  0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not
 * Active
 *  1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is
 * Active
 */
#define IAXXX_I2C1_IC_STATUS_SLV_ACTIVITY_MASK 0x00000040
#define IAXXX_I2C1_IC_STATUS_SLV_ACTIVITY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_STATUS_SLV_ACTIVITY_POS 6
#define IAXXX_I2C1_IC_STATUS_SLV_ACTIVITY_SIZE 1
#define IAXXX_I2C1_IC_STATUS_SLV_ACTIVITY_DECL 6

/*** I2C1_IC_TXFLR (0x40059074) ***/
/*
 * I2C Transmit FIFO Level Register
 */
#define IAXXX_I2C1_IC_TXFLR_ADDR (0x40059074)
#define IAXXX_I2C1_IC_TXFLR_MASK_VAL 0x0000001f
#define IAXXX_I2C1_IC_TXFLR_RMASK_VAL 0x0000001f
#define IAXXX_I2C1_IC_TXFLR_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_TXFLR_RESET_VAL 0x00000000

/*
 * Transmit FIFO Level. Contains the number of valid data entries in the
 * transmit fifo
 */
#define IAXXX_I2C1_IC_TXFLR_TXFLR_MASK 0x0000001f
#define IAXXX_I2C1_IC_TXFLR_TXFLR_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TXFLR_TXFLR_POS 0
#define IAXXX_I2C1_IC_TXFLR_TXFLR_SIZE 5
#define IAXXX_I2C1_IC_TXFLR_TXFLR_DECL (4:0)

/*** I2C1_IC_RXFLR (0x40059078) ***/
/*
 * I2C Transmit FIFO Level Register
 */
#define IAXXX_I2C1_IC_RXFLR_ADDR (0x40059078)
#define IAXXX_I2C1_IC_RXFLR_MASK_VAL 0x0000001f
#define IAXXX_I2C1_IC_RXFLR_RMASK_VAL 0x0000001f
#define IAXXX_I2C1_IC_RXFLR_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_RXFLR_RESET_VAL 0x00000000

/*
 * Receive FIFO Level. Contains the number of valid data entries in the
 * receive fifo
 */
#define IAXXX_I2C1_IC_RXFLR_RXFLR_MASK 0x0000001f
#define IAXXX_I2C1_IC_RXFLR_RXFLR_RESET_VAL 0x0
#define IAXXX_I2C1_IC_RXFLR_RXFLR_POS 0
#define IAXXX_I2C1_IC_RXFLR_RXFLR_SIZE 5
#define IAXXX_I2C1_IC_RXFLR_RXFLR_DECL (4:0)

/*** I2C1_IC_SDA_HOLD (0x4005907c) ***/
/*
 * I2C SDA Hold Time Length Register
 */
#define IAXXX_I2C1_IC_SDA_HOLD_ADDR (0x4005907c)
#define IAXXX_I2C1_IC_SDA_HOLD_MASK_VAL 0x00ffffff
#define IAXXX_I2C1_IC_SDA_HOLD_RMASK_VAL 0x00ffffff
#define IAXXX_I2C1_IC_SDA_HOLD_WMASK_VAL 0x00ffffff
#define IAXXX_I2C1_IC_SDA_HOLD_RESET_VAL 0x00000001

/*
 * Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c
 * acts as a transmitter.
 */
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_TX_HOLD_MASK 0x0000ffff
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_TX_HOLD_RESET_VAL 0x1
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_TX_HOLD_POS 0
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_TX_HOLD_SIZE 16
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_TX_HOLD_DECL (15:0)

/*
 * Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c
 * acts as a receiver.
 */
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_RX_HOLD_MASK 0x00ff0000
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_RX_HOLD_RESET_VAL 0x0
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_RX_HOLD_POS 16
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_RX_HOLD_SIZE 8
#define IAXXX_I2C1_IC_SDA_HOLD_SDA_RX_HOLD_DECL (23:16)

/*** I2C1_IC_TX_ABRT_SOURCE (0x40059080) ***/
/*
 * I2C Transmit Abort source register
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ADDR (0x40059080)
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_MASK_VAL 0x0080ffff
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_RMASK_VAL 0x0080ffff
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_RESET_VAL 0x00000000

/*
 * 1: Master is in 7-bit addressing mode and the address sent was not
 * acknowledged by any slave
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_MASK 0x00000001
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_POS 0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_DECL 0

/*
 * 1: Master is in 10-bit address mode and the first 10-bit address byte was
 * not acknowledged by any slave
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_MASK 0x00000002
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_POS 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_DECL 1

/*
 * 1: Master is in 10-bit address mode and the second address byte of the
 * 10-bit address was not acknowledged by any slave
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_MASK 0x00000004
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_POS 2
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_DECL 2

/*
 * 1: This is a master-mode only bit. Master has received an acknowledgment
 * for the address, but when it sent data byte(s) following the address, it
 * did not receive an acknowledge from the remote slave(s).
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_MASK 0x00000008
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_POS 3
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_DECL 3

/*
 * 1: DW_apb_i2c in master mode sent a General Call and no slave on the bus
 * acknowledged the General Call
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_MASK 0x00000010
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_POS 4
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_DECL 4

/*
 * 1: DW_apb_i2c in master mode sent a General Call but the user programmed
 * the byte following the General Call to be a read from the bus
 * (IC_DATA_CMD[9] is set to 1)
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_MASK 0x00000020
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_POS 5
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_DECL 5

/*
 * 1: Master is in High Speed mode and the High Speed Master code was
 * acknowledged (wrong behavior)
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_MASK 0x00000040
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_POS 6
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_DECL 6

/*
 * 1: Master has sent a START Byte and the START Byte was acknowledged (wrong
 * behavior)
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_MASK 0x00000080
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_POS 7
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_DECL 7

/*
 * 1: The restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the
 * user is trying to use the master to transfer data in High Speed mode
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_MASK 0x00000100
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_POS 8
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_DECL 8

/*
 * To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first;
 * restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared
 * (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once
 * the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be
 * cleared in the same manner as other bits in this register. If the source
 * of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this
 * bit, bit 9 clears for one cycle and then gets re-asserted.
 *
 1: The restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the
 * user is trying to send a START Byte
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_MASK 0x00000200
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_POS 9
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_DECL 9

/*
 * 1: The restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the
 * master sends a read command in 10-bit addressing mode
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_MASK 0x00000400
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_POS 10
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_DECL 10

/*
 * 1:User tries to initiate a Master operation with the Master mode disabled.
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_MASK 0x00000800
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_POS 11
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_DECL 11

/*
 * 1:Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set,
 * then the transmitter has lost arbitration.
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ARB_LOST_MASK 0x00001000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ARB_LOST_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ARB_LOST_POS 12
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ARB_LOST_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ARB_LOST_DECL 12

/*
 * 1:Slave has received a read command and some data exists in the TX FIFO so
 * the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_MASK 0x00002000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_POS 13
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_DECL 13

/*
 * 1:Slave lost the bus while transmitting data to a remote master.
 * IC_TX_ABRT_SOURCE[12] is set at the same time.
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_MASK 0x00004000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_POS 14
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_DECL 14

/*
 * 1: When processor side responds to a slave mode request for data to be
 * transmitted to a remote master and user writes a 1 in CMD(bit8) of
 * IC_DATA)CMD register
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_MASK 0x00008000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_POS 15
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_DECL 15

/*
 * This field preserves the TXFLR value prior to the last TX_ABRT event. It
 * is cleared whenever I2C is disabled
 */
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_MASK 0x00800000
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_RESET_VAL 0x0
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_POS 23
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_SIZE 1
#define IAXXX_I2C1_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_DECL 23

/*** I2C1_IC_SLV_DATA_NACK_ONLY (0x40059084) ***/
/*
 * Generate Slave Data NACK Register
 */
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_ADDR (0x40059084)
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_WMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_RESET_VAL 0x00000000

/*
 * Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
 * slave-receiver. If this register is set to a value of 1, it can only
 * generate a NACK after a data byte is received; hence, the data transfer is
 * aborted and the data received is not pushed to the receive buffer.
 *  When the register is set to a value of 0, it generates NACK/ACK,
 * depending on normal criteria.
 *
 1 = generate NACK after data byte received
 * 0 = generate NACK/ACK normally
 */
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_NACK_MASK 0x00000001
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_NACK_RESET_VAL 0x0
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_NACK_POS 0
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_NACK_SIZE 1
#define IAXXX_I2C1_IC_SLV_DATA_NACK_ONLY_NACK_DECL 0

/*** I2C1_IC_DMA_CR (0x40059088) ***/
/*
 * I2C DMA Control Register
 */
#define IAXXX_I2C1_IC_DMA_CR_ADDR (0x40059088)
#define IAXXX_I2C1_IC_DMA_CR_MASK_VAL 0x00000003
#define IAXXX_I2C1_IC_DMA_CR_RMASK_VAL 0x00000003
#define IAXXX_I2C1_IC_DMA_CR_WMASK_VAL 0x00000003
#define IAXXX_I2C1_IC_DMA_CR_RESET_VAL 0x00000000

/*
 * Receive DMA Enable. This bit enables/disables the Receive FIFO DMA
 * channel.
 *  0 = Receive DMA disabled
 *  1 = Receive DMA enabled
 */
#define IAXXX_I2C1_IC_DMA_CR_RDMAE_MASK 0x00000001
#define IAXXX_I2C1_IC_DMA_CR_RDMAE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DMA_CR_RDMAE_POS 0
#define IAXXX_I2C1_IC_DMA_CR_RDMAE_SIZE 1
#define IAXXX_I2C1_IC_DMA_CR_RDMAE_DECL 0

/*
 * Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA
 * channel.
 *  0 = Transmit DMA disabled
 *  1 = Transmit DMA enabled
 */
#define IAXXX_I2C1_IC_DMA_CR_TDMAE_MASK 0x00000002
#define IAXXX_I2C1_IC_DMA_CR_TDMAE_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DMA_CR_TDMAE_POS 1
#define IAXXX_I2C1_IC_DMA_CR_TDMAE_SIZE 1
#define IAXXX_I2C1_IC_DMA_CR_TDMAE_DECL 1

/*** I2C1_IC_DMA_TDLR (0x4005908c) ***/
/*
 * I2C DMA Transmit Data Level Register
 */
#define IAXXX_I2C1_IC_DMA_TDLR_ADDR (0x4005908c)
#define IAXXX_I2C1_IC_DMA_TDLR_MASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_TDLR_RMASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_TDLR_WMASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_TDLR_RESET_VAL 0x00000000

/*
 * Transmit Data Level. This bit field controls the level at which a DMA
 * request is made by the transmit logic. It is equal to the watermark level;
 * that is, the dma_tx_req signal is generated when the number of valid data
 * entries in the transmit FIFO is equal to or below this field value, and
 * TDMAE = 1.
 */
#define IAXXX_I2C1_IC_DMA_TDLR_DMATDL_MASK 0x0000000f
#define IAXXX_I2C1_IC_DMA_TDLR_DMATDL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DMA_TDLR_DMATDL_POS 0
#define IAXXX_I2C1_IC_DMA_TDLR_DMATDL_SIZE 4
#define IAXXX_I2C1_IC_DMA_TDLR_DMATDL_DECL (3:0)

/*** I2C1_IC_DMA_RDLR (0x40059090) ***/
/*
 * I2C DMA Receive Data Level Register
 */
#define IAXXX_I2C1_IC_DMA_RDLR_ADDR (0x40059090)
#define IAXXX_I2C1_IC_DMA_RDLR_MASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_RDLR_RMASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_RDLR_WMASK_VAL 0x0000000f
#define IAXXX_I2C1_IC_DMA_RDLR_RESET_VAL 0x00000000

/*
 * Receive Data Level. This bit field controls the level at which a DMA
 * request is made by the receive logic. The watermark level = DMARDL+1; that
 * is, dma_rx_req is generated when the number of valid data entries in the
 * receive FIFO is equal to or more than this field value + 1, and RDMAE = 1.
 * For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more
 * data entries are present in the receive FIFO.
 */
#define IAXXX_I2C1_IC_DMA_RDLR_DMARDL_MASK 0x0000000f
#define IAXXX_I2C1_IC_DMA_RDLR_DMARDL_RESET_VAL 0x0
#define IAXXX_I2C1_IC_DMA_RDLR_DMARDL_POS 0
#define IAXXX_I2C1_IC_DMA_RDLR_DMARDL_SIZE 4
#define IAXXX_I2C1_IC_DMA_RDLR_DMARDL_DECL (3:0)

/*** I2C1_IC_SDA_SETUP (0x40059094) ***/
/*
 * I2C SDA Setup Register
 */
#define IAXXX_I2C1_IC_SDA_SETUP_ADDR (0x40059094)
#define IAXXX_I2C1_IC_SDA_SETUP_MASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_SDA_SETUP_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_SDA_SETUP_WMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_SDA_SETUP_RESET_VAL 0x00000021

/*
 * SDA Setup. It is recommended that if the required delay is 1000ns, then
 * for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a
 * value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
 */
#define IAXXX_I2C1_IC_SDA_SETUP_SDA_SETUP_MASK 0x000000ff
#define IAXXX_I2C1_IC_SDA_SETUP_SDA_SETUP_RESET_VAL 0x21
#define IAXXX_I2C1_IC_SDA_SETUP_SDA_SETUP_POS 0
#define IAXXX_I2C1_IC_SDA_SETUP_SDA_SETUP_SIZE 8
#define IAXXX_I2C1_IC_SDA_SETUP_SDA_SETUP_DECL (7:0)

/*** I2C1_IC_ACK_GENERAL_CALL (0x40059098) ***/
/*
 * I2C ACK General Call Register
 */
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ADDR (0x40059098)
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_WMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_RESET_VAL 0x00000001

/*
 * ACK General Call. When set to 1, DW_apb_i2c responds with a ACK when it
 * receives a General Call. When set to 0, the DW_apb_i2c does not generate
 * General Call interrupts
 */
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_MASK 0x00000001
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_RESET_VAL 0x1
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_POS 0
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_SIZE 1
#define IAXXX_I2C1_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_DECL 0

/*** I2C1_IC_ENABLE_STATUS (0x4005909c) ***/
/*
 * I2C Enable Status Register
 */
#define IAXXX_I2C1_IC_ENABLE_STATUS_ADDR (0x4005909c)
#define IAXXX_I2C1_IC_ENABLE_STATUS_MASK_VAL 0x00000007
#define IAXXX_I2C1_IC_ENABLE_STATUS_RMASK_VAL 0x00000007
#define IAXXX_I2C1_IC_ENABLE_STATUS_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_ENABLE_STATUS_RESET_VAL 0x00000000

/*
 * ic_en Status. This bit always reflects the value driven on the output port
 * ic_en. When read as 1, DW_apb_i2c is deemed to be in an enabled state.
 * When read as 0, DW_apb_i2c is deemed completely inactive
 */
#define IAXXX_I2C1_IC_ENABLE_STATUS_IC_EN_MASK 0x00000001
#define IAXXX_I2C1_IC_ENABLE_STATUS_IC_EN_RESET_VAL 0x0
#define IAXXX_I2C1_IC_ENABLE_STATUS_IC_EN_POS 0
#define IAXXX_I2C1_IC_ENABLE_STATUS_IC_EN_SIZE 1
#define IAXXX_I2C1_IC_ENABLE_STATUS_IC_EN_DECL 0

/*
 * Slave Disabled While Busy (Transmit, Receive). This bit indicates if a
 * potential or active Slave operation has been aborted due to the setting of
 * the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a
 * 0 to the IC_ENABLE register while: (a) DW_apb_i2c is receiving the address
 * byte of the Slave-Transmitter operation from a remote master; OR, (b)
 * address and data bytes of the Slave-Receiver operation from a remote
 * master
 */
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_MASK 0x00000002
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_RESET_VAL 0x0
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_POS 1
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_SIZE 1
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_DECL 1

/*
 * Slave Received Data Lost. This bit indicates if a slave-receiver operation
 * has been aborted with at least one data byte received from an I2C transfer
 * due to the setting of IC_ENABLE from 1 to 0.
 */
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_MASK 0x00000004
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_RESET_VAL 0x0
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_POS 2
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_SIZE 1
#define IAXXX_I2C1_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_DECL 2

/*** I2C1_IC_FS_SPKLEN (0x400590a0) ***/
/*
 * I2C FS Spike Suppression Limit Register
 */
#define IAXXX_I2C1_IC_FS_SPKLEN_ADDR (0x400590a0)
#define IAXXX_I2C1_IC_FS_SPKLEN_MASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_FS_SPKLEN_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_FS_SPKLEN_WMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_FS_SPKLEN_RESET_VAL 0x00000001

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure stable operation. This register sets the duration, measured in
 * ic_clk cycles, of the longest spike in the SCL or SDA lines that are
 * filtered out by the spike suppression logic; for more information, refer
 * to Spike Suppression on page 57.
 *  This register can be written only when the I2C interface is disabled,
 * which corresponds to IC_ENABLE[0] being set to 0. Writes at other times
 * have no effect.
 *  The minimum valid value is 1; hardware prevents values less than this
 * being written, and if attempted, results in 1 being set.
 */
#define IAXXX_I2C1_IC_FS_SPKLEN_FS_SPKLEN_MASK 0x000000ff
#define IAXXX_I2C1_IC_FS_SPKLEN_FS_SPKLEN_RESET_VAL 0x1
#define IAXXX_I2C1_IC_FS_SPKLEN_FS_SPKLEN_POS 0
#define IAXXX_I2C1_IC_FS_SPKLEN_FS_SPKLEN_SIZE 8
#define IAXXX_I2C1_IC_FS_SPKLEN_FS_SPKLEN_DECL (7:0)

/*** I2C1_IC_HS_SPKLEN (0x400590a4) ***/
/*
 * I2C HS Spike Suppression Limit Register
 */
#define IAXXX_I2C1_IC_HS_SPKLEN_ADDR (0x400590a4)
#define IAXXX_I2C1_IC_HS_SPKLEN_MASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_HS_SPKLEN_RMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_HS_SPKLEN_WMASK_VAL 0x000000ff
#define IAXXX_I2C1_IC_HS_SPKLEN_RESET_VAL 0x00000001

/*
 * This register must be set before any I2C bus transaction can take place to
 * ensure stable operation. This register sets the duration, measured in
 * ic_clk cycles, of the longest spike in the SCL or SDA lines that are
 * filtered out by the spike suppression logic; for more information, refer
 * to Spike Suppression on page 57.
 *  This register can be written only when the I2C interface is disabled,
 * which corresponds to IC_ENABLE[0] being set to 0. Writes at other times
 * have no effect.
 *  The minimum valid value is 1; hardware prevents values less than this
 * being written, and if attempted, results in 1 being set. This register is
 * implemented only if the component is configured to support HS mode; that
 * is, if the IC_MAX_SPEED_MODE parameter is set to 3.
 */
#define IAXXX_I2C1_IC_HS_SPKLEN_HS_SPKLEN_MASK 0x000000ff
#define IAXXX_I2C1_IC_HS_SPKLEN_HS_SPKLEN_RESET_VAL 0x1
#define IAXXX_I2C1_IC_HS_SPKLEN_HS_SPKLEN_POS 0
#define IAXXX_I2C1_IC_HS_SPKLEN_HS_SPKLEN_SIZE 8
#define IAXXX_I2C1_IC_HS_SPKLEN_HS_SPKLEN_DECL (7:0)

/*** I2C1_IC_CLR_RESTART_DET (0x400590a8) ***/
/*
 * I2C Clear RESTART_DET Register
 */
#define IAXXX_I2C1_IC_CLR_RESTART_DET_ADDR (0x400590a8)
#define IAXXX_I2C1_IC_CLR_RESTART_DET_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RESTART_DET_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_RESTART_DET_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_RESTART_DET_RESET_VAL 0x00000000

/*
 * Read this register to clear the RESTART_DET interrupt (bit 12) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET_POS 0
#define IAXXX_I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET_SIZE 1
#define IAXXX_I2C1_IC_CLR_RESTART_DET_CLR_RESTART_DET_DECL 0

/*** I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT (0x400590ac) ***/
/*
 * I2C SCL STUCK AT LOW TIMEOUT Register
 */
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_ADDR (0x400590ac)
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_MASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_RMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_WMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_RESET_VAL 0xffffffff

/*
 * DW_apb_i2c generate the interrupt to indicate SCL stuck at low
 * (SCL_STUCK_AT_LOW) if it detects the SCL stuck at low for the
 * IC_SCL_STUCK_LOW_TIMEOUT in units of ic_clk period. This register can be
 * written only when the I2C interface is disabled which corresponds to the
 * IC_ENABLE[0] register being set to 0. Writes at other times have no
 * effect.
 */
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_MASK 0xffffffff
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_RESET_VAL 0xffffffff
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_POS 0
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_SIZE 32
#define IAXXX_I2C1_IC_SCL_STUCK_AT_LOW_TIMEOUT_IC_SCL_STUCK_LOW_TIMEOUT_DECL (31:0)

/*** I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT (0x400590b0) ***/
/*
 * I2C SDA STUCK AT LOW TIMEOUT Register
 */
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_ADDR (0x400590b0)
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_MASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_RMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_WMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_RESET_VAL 0xffffffff

/*
 * DW_apb_i2c generate the interrupt to an tx abort interrupt indicating the
 * SDA is low for the DW_apb_i2c initiate the recovery of SDA line,
 * (ABRT_SDA_STUCK_AT_LOW) if it detects the SDA stuck at low
 * IC_SDA_STUCK_LOW_TIMEOUT timeout. After receiving this abort the user can
 * initiate the SDA recovery machanism though IC_ENABLE register.for the
 * IC_SDA_STUCK_LOW_TIMEOUT in units of ic_clk period during the generation
 * of START on the I2C bus. If the SDA line is not recovered after the
 * automatic recovery, then DW_apb_i2c will generate the interrupt
 * (SDA_STUCK_AT_LOW). This register can be written only when the I2C
 * interface is disabled which corresponds to the IC_ENABLE[0] register being
 * set to 0. Writes at other times have no effect.
 */
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_MASK 0xffffffff
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_RESET_VAL 0xffffffff
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_POS 0
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_SIZE 32
#define IAXXX_I2C1_IC_SDA_STUCK_AT_LOW_TIMEOUT_IC_SDA_STUCK_LOW_TIMEOUT_DECL (31:0)

/*** I2C1_IC_CLR_SCL_STUCK_DET (0x400590b4) ***/
/*
 * I2C CLR SCL STUCK DETECT Register
 */
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_ADDR (0x400590b4)
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_MASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_RMASK_VAL 0x00000001
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_RESET_VAL 0x00000000

/*
 * Read this register to clear the SCL_STRUCT_AT_LOW interrupt (bit 15) of the
 * IC_RAW_INTR_STAT register.
 */
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_MASK 0x00000001
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_RESET_VAL 0x0
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_POS 0
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_SIZE 1
#define IAXXX_I2C1_IC_CLR_SCL_STUCK_DET_CLR_SCL_STUCK_DET_DECL 0

/*** I2C1_IC_COMP_PARAM_1 (0x400590f4) ***/
/*
 * Component Parameter Register 1
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADDR (0x400590f4)
#define IAXXX_I2C1_IC_COMP_PARAM_1_MASK_VAL 0x00ffffff
#define IAXXX_I2C1_IC_COMP_PARAM_1_RMASK_VAL 0x00ffffff
#define IAXXX_I2C1_IC_COMP_PARAM_1_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_COMP_PARAM_1_RESET_VAL 0x000f0fee

/*
 * 0x0 = 8 bits
 *  0x1 = 16 bits
 *  0x2 = 32 bits
 *  0x3 = Reserved
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH_MASK 0x00000003
#define IAXXX_I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH_RESET_VAL 0x2
#define IAXXX_I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH_POS 0
#define IAXXX_I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH_SIZE 2
#define IAXXX_I2C1_IC_COMP_PARAM_1_APB_DATA_WIDTH_DECL (1:0)

/*
 *  0x0 = Reserved
 *  0x1 = Standard
 *  0x2 = Fast
 *  0x3 = High
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE_MASK 0x0000000c
#define IAXXX_I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE_RESET_VAL 0x3
#define IAXXX_I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE_POS 2
#define IAXXX_I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE_SIZE 2
#define IAXXX_I2C1_IC_COMP_PARAM_1_MAX_SPEED_MODE_DECL (3:2)

/*
 * 0:False
 *  1:True
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES_MASK 0x00000010
#define IAXXX_I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES_RESET_VAL 0x0
#define IAXXX_I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES_POS 4
#define IAXXX_I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES_SIZE 1
#define IAXXX_I2C1_IC_COMP_PARAM_1_HC_COUNT_VALUES_DECL 4

/*
 * 0:Individual
 *  1:Combined
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_INTR_IO_MASK 0x00000020
#define IAXXX_I2C1_IC_COMP_PARAM_1_INTR_IO_RESET_VAL 0x1
#define IAXXX_I2C1_IC_COMP_PARAM_1_INTR_IO_POS 5
#define IAXXX_I2C1_IC_COMP_PARAM_1_INTR_IO_SIZE 1
#define IAXXX_I2C1_IC_COMP_PARAM_1_INTR_IO_DECL 5

/*
 * 0:False
 *  1:True
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_HAS_DMA_MASK 0x00000040
#define IAXXX_I2C1_IC_COMP_PARAM_1_HAS_DMA_RESET_VAL 0x1
#define IAXXX_I2C1_IC_COMP_PARAM_1_HAS_DMA_POS 6
#define IAXXX_I2C1_IC_COMP_PARAM_1_HAS_DMA_SIZE 1
#define IAXXX_I2C1_IC_COMP_PARAM_1_HAS_DMA_DECL 6

/*
 * Reading 1 in this bit means that the capability of reading these encoded
 * parameters via software has been included. Otherwise, the entire register
 * is 0 regardless of the setting of any other parameters that are encoded in
 * the bits.
 *  0: False
 *  1: True
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_MASK 0x00000080
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_RESET_VAL 0x1
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_POS 7
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_SIZE 1
#define IAXXX_I2C1_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_DECL 7

/*
 * 0x00 = Reserved
 *  0x01 = 2
 *  0x02 = 3
 *  to 0xFF = 256
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_MASK 0x0000ff00
#define IAXXX_I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_RESET_VAL 0xf
#define IAXXX_I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_POS 8
#define IAXXX_I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_SIZE 8
#define IAXXX_I2C1_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_DECL (15:8)

/*
 * 0x00 = Reserved
 *  0x01 = 2
 *  0x02 = 3
 *  to 0xFF = 256
 */
#define IAXXX_I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_MASK 0x00ff0000
#define IAXXX_I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_RESET_VAL 0xf
#define IAXXX_I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_POS 16
#define IAXXX_I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_SIZE 8
#define IAXXX_I2C1_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_DECL (23:16)

/*** I2C1_IC_COMP_VERSION (0x400590f8) ***/
/*
 * I2C Revision ID
 */
#define IAXXX_I2C1_IC_COMP_VERSION_ADDR (0x400590f8)
#define IAXXX_I2C1_IC_COMP_VERSION_MASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_COMP_VERSION_RMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_COMP_VERSION_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_COMP_VERSION_RESET_VAL 0x3230302a

/*
 * Revision number of I2C Core
 */
#define IAXXX_I2C1_IC_COMP_VERSION_VERSION_MASK 0xffffffff
#define IAXXX_I2C1_IC_COMP_VERSION_VERSION_RESET_VAL 0x3230302a
#define IAXXX_I2C1_IC_COMP_VERSION_VERSION_POS 0
#define IAXXX_I2C1_IC_COMP_VERSION_VERSION_SIZE 32
#define IAXXX_I2C1_IC_COMP_VERSION_VERSION_DECL (31:0)

/*** I2C1_IC_COMP_TYPE (0x400590fc) ***/
/*
 * I2C Core Type
 */
#define IAXXX_I2C1_IC_COMP_TYPE_ADDR (0x400590fc)
#define IAXXX_I2C1_IC_COMP_TYPE_MASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_COMP_TYPE_RMASK_VAL 0xffffffff
#define IAXXX_I2C1_IC_COMP_TYPE_WMASK_VAL 0x00000000
#define IAXXX_I2C1_IC_COMP_TYPE_RESET_VAL 0x44570140

/*
 * Core Type
 */
#define IAXXX_I2C1_IC_COMP_TYPE_TYPE_MASK 0xffffffff
#define IAXXX_I2C1_IC_COMP_TYPE_TYPE_RESET_VAL 0x44570140
#define IAXXX_I2C1_IC_COMP_TYPE_TYPE_POS 0
#define IAXXX_I2C1_IC_COMP_TYPE_TYPE_SIZE 32
#define IAXXX_I2C1_IC_COMP_TYPE_TYPE_DECL (31:0)

/* Number of registers in the module */
#define IAXXX_I2C1_REG_NUM 49

#endif /* __IAXXX_REGISTER_DEFS_I2C1_H__*/
