/*
 * iaxxx-register-defs-hmd.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_HMD_H__
#define __IAXXX_REGISTER_DEFS_HMD_H__

/*** The base address for this set of registers ***/
#define IAXXX_HMD_REGS_ADDR (0x40033000)

/*** HMD_MAC_WIN_BYPASS (0x40033000) ***/
/*
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_ADDR (0x40033000)
#define IAXXX_HMD_MAC_WIN_BYPASS_MASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_BYPASS_RMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_BYPASS_WMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_BYPASS_RESET_VAL 0x00000fff

/*
 * Bypass MAC for IRAM0 address window 0.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN0_MASK 0x00000001
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN0_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN0_POS 0
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN0_DECL 0

/*
 * Bypass MAC for IRAM0 address window 1.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN1_MASK 0x00000002
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN1_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN1_POS 1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN1_DECL 1

/*
 * Bypass MAC for IRAM0 address window 2.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN2_MASK 0x00000004
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN2_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN2_POS 2
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN2_DECL 2

/*
 * Bypass MAC for IRAM0 address window 3.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN3_MASK 0x00000008
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN3_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN3_POS 3
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_IRAM0_WIN3_DECL 3

/*
 * Bypass MAC for DRAM0 address window 0.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN0_MASK 0x00000010
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN0_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN0_POS 4
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN0_DECL 4

/*
 * Bypass MAC for DRAM0 address window 1.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN1_MASK 0x00000020
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN1_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN1_POS 5
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN1_DECL 5

/*
 * Bypass MAC for DRAM0 address window 2.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN2_MASK 0x00000040
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN2_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN2_POS 6
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN2_DECL 6

/*
 * Bypass MAC for DRAM0 address window 3.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN3_MASK 0x00000080
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN3_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN3_POS 7
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN3_DECL 7

/*
 * Bypass MAC for DRAM0 address window 4.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN4_MASK 0x00000100
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN4_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN4_POS 8
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN4_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN4_DECL 8

/*
 * Bypass MAC for DRAM0 address window 5.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN5_MASK 0x00000200
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN5_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN5_POS 9
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN5_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN5_DECL 9

/*
 * Bypass MAC for DRAM0 address window 6.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN6_MASK 0x00000400
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN6_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN6_POS 10
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN6_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN6_DECL 10

/*
 * Bypass MAC for DRAM0 address window 7.
 */
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN7_MASK 0x00000800
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN7_RESET_VAL 0x1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN7_POS 11
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN7_SIZE 1
#define IAXXX_HMD_MAC_WIN_BYPASS_DRAM0_WIN7_DECL 11

/*** HMD_MAC_IRAM0_WIN0_RANGE (0x40033004) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_ADDR (0x40033004)
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_RESET_VAL 0x00000000

/*
 * IRAM0 address window0 base address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BASE_DECL (11:0)

/*
 * IRAM0 address window0 bound address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_IRAM0_WIN0_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_IRAM0_WIN0_OFFSET (0x40033008) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_ADDR (0x40033008)
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_RESET_VAL 0x00000000

/*
 * IRAM0 address window0 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_OFFSET_DECL (11:0)

/*
 * IRAM0 address window0offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_IRAM0_WIN0_OFFSET_SIGN_DECL 16

/*** HMD_MAC_IRAM0_WIN1_RANGE (0x4003300c) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_ADDR (0x4003300c)
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_RESET_VAL 0x00000000

/*
 * IRAM0 address window1 base address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BASE_DECL (11:0)

/*
 * IRAM0 address window1 bound address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_IRAM0_WIN1_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_IRAM0_WIN1_OFFSET (0x40033010) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_ADDR (0x40033010)
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_RESET_VAL 0x00000000

/*
 * IRAM0 address window1 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_OFFSET_DECL (11:0)

/*
 * IRAM0 address window1offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_IRAM0_WIN1_OFFSET_SIGN_DECL 16

/*** HMD_MAC_IRAM0_WIN2_RANGE (0x40033014) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_ADDR (0x40033014)
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_RESET_VAL 0x00000000

/*
 * IRAM0 address window2 base address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BASE_DECL (11:0)

/*
 * IRAM0 address window2 bound address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_IRAM0_WIN2_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_IRAM0_WIN2_OFFSET (0x40033018) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_ADDR (0x40033018)
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_RESET_VAL 0x00000000

/*
 * IRAM0 address window2 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_OFFSET_DECL (11:0)

/*
 * IRAM0 address window2offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_IRAM0_WIN2_OFFSET_SIGN_DECL 16

/*** HMD_MAC_IRAM0_WIN3_RANGE (0x4003301c) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_ADDR (0x4003301c)
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_RESET_VAL 0x00000000

/*
 * IRAM0 address window3 base address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BASE_DECL (11:0)

/*
 * IRAM0 address window3 bound address
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_IRAM0_WIN3_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_IRAM0_WIN3_OFFSET (0x40033020) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_ADDR (0x40033020)
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_RESET_VAL 0x00000000

/*
 * IRAM0 address window3 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_OFFSET_DECL (11:0)

/*
 * IRAM0 address window3offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_IRAM0_WIN3_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN0_RANGE (0x40033024) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_ADDR (0x40033024)
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window0 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window0 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN0_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN0_OFFSET (0x40033028) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_ADDR (0x40033028)
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window0 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window0 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN0_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN1_RANGE (0x4003302c) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_ADDR (0x4003302c)
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window1 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window1 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN1_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN1_OFFSET (0x40033030) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_ADDR (0x40033030)
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window1 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window1 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN1_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN2_RANGE (0x40033034) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_ADDR (0x40033034)
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window2 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window2 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN2_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN2_OFFSET (0x40033038) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_ADDR (0x40033038)
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window2 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window2 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN2_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN3_RANGE (0x4003303c) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_ADDR (0x4003303c)
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window3 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window3 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN3_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN3_OFFSET (0x40033040) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_ADDR (0x40033040)
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window3 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window3 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN3_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN4_RANGE (0x40033044) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_ADDR (0x40033044)
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window4 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window4 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN4_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN4_OFFSET (0x40033048) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_ADDR (0x40033048)
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window4 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window4 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN4_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN5_RANGE (0x4003304c) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_ADDR (0x4003304c)
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window5 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window5 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN5_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN5_OFFSET (0x40033050) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_ADDR (0x40033050)
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window5 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window5 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN5_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN6_RANGE (0x40033054) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_ADDR (0x40033054)
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window6 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window6 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN6_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN6_OFFSET (0x40033058) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_ADDR (0x40033058)
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window6 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window6 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN6_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DRAM0_WIN7_RANGE (0x4003305c) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_ADDR (0x4003305c)
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_MASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_RMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_WMASK_VAL 0x1fff0fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_RESET_VAL 0x00000000

/*
 * DRAM0 window7 base address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BASE_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BASE_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BASE_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BASE_DECL (11:0)

/*
 * DRAM0 address window7 bound address
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BOUND_MASK 0x1fff0000
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BOUND_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BOUND_SIZE 13
#define IAXXX_HMD_MAC_DRAM0_WIN7_RANGE_BOUND_DECL (28:16)

/*** HMD_MAC_DRAM0_WIN7_OFFSET (0x40033060) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_ADDR (0x40033060)
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_MASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_RMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_WMASK_VAL 0x00010fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_RESET_VAL 0x00000000

/*
 * DRAM0 address window7 offset value with address unit 1 kilobyte
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_OFFSET_MASK 0x00000fff
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_OFFSET_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_OFFSET_POS 0
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_OFFSET_SIZE 12
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_OFFSET_DECL (11:0)

/*
 * DRAM0 address window7 offset sign bit; 1=negative; 0=positive
 */
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_SIGN_MASK 0x00010000
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_SIGN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_SIGN_POS 16
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_SIGN_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_WIN7_OFFSET_SIGN_DECL 16

/*** HMD_MAC_DFLT_DENY_PERM (0x40033064) ***/
/*
 */
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_ADDR (0x40033064)
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_MASK_VAL 0x00000003
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_RMASK_VAL 0x00000003
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_WMASK_VAL 0x00000003
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_RESET_VAL 0x00000000

/*
 * If this bit is 0: accesses outside of a IRAM0 address window are passed to
 * and from MSW.
 * Else if this bit is 1: any access outside of an IRAM0 address window
 * causes IRAM0_DFLT_DENY asserted in MAC_EXCP_STS1 register
 */
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_IRAM0_WIN_MASK 0x00000001
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_IRAM0_WIN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_IRAM0_WIN_POS 0
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_IRAM0_WIN_SIZE 1
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_IRAM0_WIN_DECL 0

/*
 * If this bit is 0: accesses outside of a DRAM0 address window are passed to
 * and from MSW.
 * Else if this bit is 1: any access outside of a DRAM0 address window causes
 * DRAM0_DFLT_DENY asserted in MAC_EXCP_STS1 register
 */
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_DRAM0_WIN_MASK 0x00000002
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_DRAM0_WIN_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_DRAM0_WIN_POS 1
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_DRAM0_WIN_SIZE 1
#define IAXXX_HMD_MAC_DFLT_DENY_PERM_DRAM0_WIN_DECL 1

/*** HMD_MAC_WIN_DENY_PERM (0x40033068) ***/
/*
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_ADDR (0x40033068)
#define IAXXX_HMD_MAC_WIN_DENY_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_DENY_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_DENY_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_DENY_PERM_RESET_VAL 0x00000000

/*
 * If this bit is set to be 1 then :
 * Any accesses within the IRAM0 window0 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be 0x0.
 * IRAM0_WIN0_DENY is asserted in MAC_EXCP_STS1 register .
 * If this bit is to be 0 then:
 * Read access within the IRAM0 window of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * MAC_WIN_WR_PERM bits in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN0_MASK 0x00000001
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN0_POS 0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN0_DECL 0

/*
 * If this bit is set to be 1 then :
 * Any accesses within the IRAM0 window1 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be 0x0.
 * IRAM0_WIN1_DENY is asserted in MAC_EXCP_STS1 register .
 * If this bit is to be 0 then:
 * Read access within the IRAM0 window of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * MAC_WIN_WR_PERM bits in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN1_MASK 0x00000002
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN1_POS 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN1_DECL 1

/*
 * If this bit is set to be 1 then :
 * Any accesses within the IRAM0 window2 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be 0x0.
 * IRAM0_WIN2_DENY is asserted in MAC_EXCP_STS1 register .
 * If this bit is to be 0 then:
 * Read access within the IRAM0 window of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * MAC_WIN_WR_PERM bits in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN2_MASK 0x00000004
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN2_POS 2
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN2_DECL 2

/*
 * If this bit is set to be 1 then :
 * Any accesses within the IRAM0 window3 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be 0x0.
 * IRAM0_WIN3_DENY is asserted in MAC_EXCP_STS1 register .
 * If this bit is to be 0 then:
 * Read access within the IRAM0 window of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * MAC_WIN_WR_PERM bits in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN3_MASK 0x00000008
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN3_POS 3
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_IRAM0_WIN3_DECL 3

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window0 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN0_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN0_MASK 0x00000010
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN0_POS 4
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN0_DECL 4

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window1 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN1_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN1_MASK 0x00000020
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN1_POS 5
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN1_DECL 5

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window2 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN2_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN2_MASK 0x00000040
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN2_POS 6
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN2_DECL 6

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window3 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN3_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN3_MASK 0x00000080
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN3_POS 7
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN3_DECL 7

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window4 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN4_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN4_MASK 0x00000100
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN4_POS 8
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN4_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN4_DECL 8

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window5 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN5_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN5_MASK 0x00000200
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN5_POS 9
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN5_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN5_DECL 9

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window6 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN6_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN6_MASK 0x00000400
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN6_POS 10
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN6_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN6_DECL 10

/*
 * If this bit is set to be 1 then:
 * Any accesses within the DRAM0 window7 will not be propaged to the MSW;
 * Write access will not be allowed and read accesses will return to be
 * 0xdeadbeef. DRAM0_WIN7_DENY is asserted in MAC_EXCP_STS1 register.
 * If this bit is to be 0 then:
 * Read access of the memory will be allowed;
 * Write accesses to the memory is determined by the corresponding
 * WIN_WRITE_PERM in the next register
 */
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN7_MASK 0x00000800
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN7_POS 11
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN7_SIZE 1
#define IAXXX_HMD_MAC_WIN_DENY_PERM_DRAM0_WIN7_DECL 11

/*** HMD_MAC_WIN_WR_PERM (0x4003306c) ***/
/*
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_ADDR (0x4003306c)
#define IAXXX_HMD_MAC_WIN_WR_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_WR_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_WR_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_MAC_WIN_WR_PERM_RESET_VAL 0x00000000

/*
 * If it is set to be 1 and corresponding IRAM0_WIN0_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes IRAM0_WIN0_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN0_MASK 0x00000001
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN0_POS 0
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN0_DECL 0

/*
 * If it is set to be 1 and corresponding IRAM0_WIN1_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes IRAM0_WIN1_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN1_MASK 0x00000002
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN1_POS 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN1_DECL 1

/*
 * If it is set to be 1 and corresponding IRAM0_WIN2_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes IRAM0_WIN2_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN2_MASK 0x00000004
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN2_POS 2
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN2_DECL 2

/*
 * If it is set to be 1 and corresponding IRAM0_WIN3_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes IRAM0_WIN3_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN3_MASK 0x00000008
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN3_POS 3
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_IRAM0_WIN3_DECL 3

/*
 * If it is set to be 1 and corresponding DRAM0_WIN0_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN0_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN0_MASK 0x00000010
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN0_POS 4
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN0_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN0_DECL 4

/*
 * If it is set to be 1 and corresponding DRAM0_WIN1_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN1_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN1_MASK 0x00000020
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN1_POS 5
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN1_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN1_DECL 5

/*
 * If it is set to be 1 and corresponding DRAM0_WIN2_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN2_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN2_MASK 0x00000040
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN2_POS 6
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN2_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN2_DECL 6

/*
 * If it is set to be 1 and corresponding DRAM0_WIN3_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN3_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN3_MASK 0x00000080
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN3_POS 7
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN3_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN3_DECL 7

/*
 * If it is set to be 1 and corresponding DRAM0_WIN4_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN4_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN4_MASK 0x00000100
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN4_POS 8
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN4_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN4_DECL 8

/*
 * If it is set to be 1 and corresponding DRAM0_WIN5_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN5_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN5_MASK 0x00000200
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN5_POS 9
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN5_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN5_DECL 9

/*
 * If it is set to be 1 and corresponding DRAM0_WIN6_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN6_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN6_MASK 0x00000400
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN6_POS 10
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN6_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN6_DECL 10

/*
 * If it is set to be 1 and corresponding DRAM0_WIN7_DENY_PERM bit is 0 then
 * a write access is allowed.
 * Else if it is set to be 0 then a write access is not allowed; a write
 * attempt causes DRAM0_WIN7_DENY_WR asserted in MAC_EXCP_STS2 register
 */
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN7_MASK 0x00000800
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN7_POS 11
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN7_SIZE 1
#define IAXXX_HMD_MAC_WIN_WR_PERM_DRAM0_WIN7_DECL 11

/*** HMD_MAC_EXCP_STS1 (0x40033070) ***/
/*
 */
#define IAXXX_HMD_MAC_EXCP_STS1_ADDR (0x40033070)
#define IAXXX_HMD_MAC_EXCP_STS1_MASK_VAL 0x03ffffff
#define IAXXX_HMD_MAC_EXCP_STS1_RMASK_VAL 0x03ffffff
#define IAXXX_HMD_MAC_EXCP_STS1_WMASK_VAL 0x03ffffff
#define IAXXX_HMD_MAC_EXCP_STS1_RESET_VAL 0x00000000

/*
 * Set to 1 when IRAM0_DFLT_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_DFLT_DENY_MASK 0x00000001
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_DFLT_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_DFLT_DENY_POS 0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_DFLT_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_DFLT_DENY_DECL 0

/*
 * Set to 1 when DRAM0_DFLT_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_DFLT_DENY_MASK 0x00000002
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_DFLT_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_DFLT_DENY_POS 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_DFLT_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_DFLT_DENY_DECL 1

/*
 * Set to 1 when IRAM0_WIN0_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_MASK 0x00000004
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_POS 2
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_DECL 2

/*
 * Set to 1 when IRAM0_WIN1_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_MASK 0x00000008
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_POS 3
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_DECL 3

/*
 * Set to 1 when IRAM0_WIN2_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_MASK 0x00000010
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_POS 4
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_DECL 4

/*
 * Set to 1 when IRAM0_WIN3_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_MASK 0x00000020
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_POS 5
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_DECL 5

/*
 * Set to 1 when DRAM0_WIN0_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_MASK 0x00000040
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_POS 6
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_DECL 6

/*
 * Set to 1 when DRAM0_WIN1_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_MASK 0x00000080
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_POS 7
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_DECL 7

/*
 * Set to 1 when DRAM0_WIN2_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_MASK 0x00000100
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_POS 8
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_DECL 8

/*
 * Set to 1 when DRAM0_WIN3_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_MASK 0x00000200
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_POS 9
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_DECL 9

/*
 * Set to 1 when DRAM0_WIN4_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_MASK 0x00000400
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_POS 10
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_DECL 10

/*
 * Set to 1 when DRAM0_WIN5_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_MASK 0x00000800
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_POS 11
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_DECL 11

/*
 * Set to 1 when DRAM0_WIN6_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_MASK 0x00001000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_POS 12
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_DECL 12

/*
 * Set to 1 when DRAM0_WIN7_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_MASK 0x00002000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_POS 13
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_DECL 13

/*
 * Set to 1 when IRAM0_WIN0_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_WR_MASK 0x00004000
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_WR_POS 14
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN0_DENY_WR_DECL 14

/*
 * Set to 1 when IRAM0_WIN1_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_WR_MASK 0x00008000
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_WR_POS 15
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN1_DENY_WR_DECL 15

/*
 * Set to 1 when IRAM0_WIN2_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_WR_MASK 0x00010000
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_WR_POS 16
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN2_DENY_WR_DECL 16

/*
 * Set to 1 when IRAM0_WIN3_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_WR_MASK 0x00020000
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_WR_POS 17
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_IRAM0_WIN3_DENY_WR_DECL 17

/*
 * Set to 1 when DRAM0_WIN0_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_WR_MASK 0x00040000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_WR_POS 18
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN0_DENY_WR_DECL 18

/*
 * Set to 1 when DRAM0_WIN1_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_WR_MASK 0x00080000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_WR_POS 19
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN1_DENY_WR_DECL 19

/*
 * Set to 1 when DRAM0_WIN2_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_WR_MASK 0x00100000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_WR_POS 20
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN2_DENY_WR_DECL 20

/*
 * Set to 1 when DRAM0_WIN3_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_WR_MASK 0x00200000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_WR_POS 21
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN3_DENY_WR_DECL 21

/*
 * Set to 1 when DRAM0_WIN4_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_WR_MASK 0x00400000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_WR_POS 22
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN4_DENY_WR_DECL 22

/*
 * Set to 1 when DRAM0_WIN5_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_WR_MASK 0x00800000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_WR_POS 23
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN5_DENY_WR_DECL 23

/*
 * Set to 1 when DRAM0_WIN6_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_WR_MASK 0x01000000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_WR_POS 24
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN6_DENY_WR_DECL 24

/*
 * Set to 1 when DRAM0_WIN7_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_WR_MASK 0x02000000
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_WR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_WR_POS 25
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_WR_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS1_DRAM0_WIN7_DENY_WR_DECL 25

/*** HMD_MAC_EXCP_STS2 (0x40033074) ***/
/*
 */
#define IAXXX_HMD_MAC_EXCP_STS2_ADDR (0x40033074)
#define IAXXX_HMD_MAC_EXCP_STS2_MASK_VAL 0x00003fff
#define IAXXX_HMD_MAC_EXCP_STS2_RMASK_VAL 0x00003fff
#define IAXXX_HMD_MAC_EXCP_STS2_WMASK_VAL 0x00003fff
#define IAXXX_HMD_MAC_EXCP_STS2_RESET_VAL 0x00000000

/*
 * Set to 1 if IRAM0 memory address falls in 2 or more instruction windows.
 * Write 1 to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_PROG_FAULT_MASK 0x00000001
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_PROG_FAULT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_PROG_FAULT_POS 0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_PROG_FAULT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_PROG_FAULT_DECL 0

/*
 * Set to 1 if DRAM0 memory address falls in 2 or more data windows. Write 1
 * to clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_PROG_FAULT_MASK 0x00000002
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_PROG_FAULT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_PROG_FAULT_POS 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_PROG_FAULT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_PROG_FAULT_DECL 1

/*
 * Set to 1 if IRAM0_WIN0_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN0_OFFSET_SAT_MASK 0x00000004
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN0_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN0_OFFSET_SAT_POS 2
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN0_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN0_OFFSET_SAT_DECL 2

/*
 * Set to 1 if IRAM0_WIN1_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN1_OFFSET_SAT_MASK 0x00000008
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN1_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN1_OFFSET_SAT_POS 3
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN1_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN1_OFFSET_SAT_DECL 3

/*
 * Set to 1 if IRAM0_WIN2_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN2_OFFSET_SAT_MASK 0x00000010
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN2_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN2_OFFSET_SAT_POS 4
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN2_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN2_OFFSET_SAT_DECL 4

/*
 * Set to 1 if IRAM0_WIN3_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN3_OFFSET_SAT_MASK 0x00000020
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN3_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN3_OFFSET_SAT_POS 5
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN3_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_IRAM0_WIN3_OFFSET_SAT_DECL 5

/*
 * Set to 1 if DRAM0_WIN0_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN0_OFFSET_SAT_MASK 0x00000040
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN0_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN0_OFFSET_SAT_POS 6
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN0_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN0_OFFSET_SAT_DECL 6

/*
 * Set to 1 if DRAM0_WIN1_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN1_OFFSET_SAT_MASK 0x00000080
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN1_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN1_OFFSET_SAT_POS 7
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN1_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN1_OFFSET_SAT_DECL 7

/*
 * Set to 1 if DRAM0_WIN2_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN2_OFFSET_SAT_MASK 0x00000100
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN2_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN2_OFFSET_SAT_POS 8
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN2_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN2_OFFSET_SAT_DECL 8

/*
 * Set to 1 if DRAM0_WIN3_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN3_OFFSET_SAT_MASK 0x00000200
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN3_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN3_OFFSET_SAT_POS 9
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN3_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN3_OFFSET_SAT_DECL 9

/*
 * Set to 1 if DRAM0_WIN4_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN4_OFFSET_SAT_MASK 0x00000400
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN4_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN4_OFFSET_SAT_POS 10
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN4_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN4_OFFSET_SAT_DECL 10

/*
 * Set to 1 if DRAM0_WIN5_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN5_OFFSET_SAT_MASK 0x00000800
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN5_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN5_OFFSET_SAT_POS 11
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN5_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN5_OFFSET_SAT_DECL 11

/*
 * Set to 1 if DRAM0_WIN6_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN6_OFFSET_SAT_MASK 0x00001000
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN6_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN6_OFFSET_SAT_POS 12
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN6_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN6_OFFSET_SAT_DECL 12

/*
 * Set to 1 if DRAM0_WIN7_OFFSET causes address adder to saturate. Write 1 to
 * clear
 */
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN7_OFFSET_SAT_MASK 0x00002000
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN7_OFFSET_SAT_RESET_VAL 0x0
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN7_OFFSET_SAT_POS 13
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN7_OFFSET_SAT_SIZE 1
#define IAXXX_HMD_MAC_EXCP_STS2_DRAM0_WIN7_OFFSET_SAT_DECL 13

/*** HMD_MAC_IRAM0_EXCP_ADDR (0x40033078) ***/
/*
 */
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR (0x40033078)
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_MASK_VAL 0x803fffff
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_RMASK_VAL 0x803fffff
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_WMASK_VAL 0x80000000
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_RESET_VAL 0x00000000

/*
 * Set to the IRAM0 memory address that causes the first processor exception.
 * This is byte address from processor
 */
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR_MASK 0x003fffff
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR_POS 0
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR_SIZE 22
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_ADDR_DECL (21:0)

/*
 * Writing 1 to this register clears MAC_IRAM0_EXCP_ADDR_ADDR. This bit need
 * to be reset back to 0 for MAC to latch the next exception IRAM0 ADDR
 */
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_CLR_MASK 0x80000000
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_CLR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_CLR_POS 31
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_CLR_SIZE 1
#define IAXXX_HMD_MAC_IRAM0_EXCP_ADDR_CLR_DECL 31

/*** HMD_MAC_DRAM0_EXCP_ADDR (0x4003307c) ***/
/*
 */
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR (0x4003307c)
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_MASK_VAL 0x803fffff
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_RMASK_VAL 0x803fffff
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_WMASK_VAL 0x80000000
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_RESET_VAL 0x00000000

/*
 * Set to the DRAM0 memory address that causes the first processor exception.
 * This is byte address from processor
 */
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR_MASK 0x003fffff
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR_POS 0
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR_SIZE 22
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_ADDR_DECL (21:0)

/*
 * Writing 1 to this register clears MAC_DRAM0_EXCP_ADDR_ADDR. This bit need
 * to be reset back to 0 for MAC to latch the next exception DRAM0 ADDR
 */
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_CLR_MASK 0x80000000
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_CLR_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_CLR_POS 31
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_CLR_SIZE 1
#define IAXXX_HMD_MAC_DRAM0_EXCP_ADDR_CLR_DECL 31

/*** HMD_MAC_DUMMY (0x40033080) ***/
/*
 */
#define IAXXX_HMD_MAC_DUMMY_ADDR (0x40033080)
#define IAXXX_HMD_MAC_DUMMY_MASK_VAL 0xffffffff
#define IAXXX_HMD_MAC_DUMMY_RMASK_VAL 0xffffffff
#define IAXXX_HMD_MAC_DUMMY_WMASK_VAL 0xffffffff
#define IAXXX_HMD_MAC_DUMMY_RESET_VAL 0x00000000

/*
 * Debug register
 */
#define IAXXX_HMD_MAC_DUMMY_MAC_DUMMY_MASK 0xffffffff
#define IAXXX_HMD_MAC_DUMMY_MAC_DUMMY_RESET_VAL 0x0
#define IAXXX_HMD_MAC_DUMMY_MAC_DUMMY_POS 0
#define IAXXX_HMD_MAC_DUMMY_MAC_DUMMY_SIZE 32
#define IAXXX_HMD_MAC_DUMMY_MAC_DUMMY_DECL (31:0)

/*** HMD_PAC_WIN_BYPASS (0x40033084) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_ADDR (0x40033084)
#define IAXXX_HMD_PAC_WIN_BYPASS_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_WIN_BYPASS_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_WIN_BYPASS_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_WIN_BYPASS_RESET_VAL 0x00000fff

/*
 * Bypass PAC for address window 0.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN0_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN0_POS 0
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN0_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN0_DECL 0

/*
 * Bypass PAC for address window 1.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN1_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN1_POS 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN1_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN1_DECL 1

/*
 * Bypass PAC for address window 2.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN2_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN2_POS 2
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN2_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN2_DECL 2

/*
 * Bypass PAC for address window 3.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN3_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN3_POS 3
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN3_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN3_DECL 3

/*
 * Bypass PAC for address window 4.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN4_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN4_POS 4
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN4_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN4_DECL 4

/*
 * Bypass PAC for address window 5.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN5_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN5_POS 5
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN5_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN5_DECL 5

/*
 * Bypass PAC for address window 6.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN6_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN6_POS 6
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN6_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN6_DECL 6

/*
 * Bypass PAC for address window 7.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN7_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN7_POS 7
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN7_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN7_DECL 7

/*
 * Bypass PAC for address window 8.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN8_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN8_POS 8
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN8_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN8_DECL 8

/*
 * Bypass PAC for address window 9.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN9_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN9_POS 9
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN9_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN9_DECL 9

/*
 * Bypass PAC for address window 10.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN10_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN10_POS 10
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN10_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN10_DECL 10

/*
 * Bypass PAC for address window 11.
 */
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN11_RESET_VAL 0x1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN11_POS 11
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN11_SIZE 1
#define IAXXX_HMD_PAC_WIN_BYPASS_WIN11_DECL 11

/*** HMD_PAC_WIN0_RANGE (0x40033088) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN0_RANGE_ADDR (0x40033088)
#define IAXXX_HMD_PAC_WIN0_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN0_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN0_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN0_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window0 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN0_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN0_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN0_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN0_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN0_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window0 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window0 when PAC_WIN0_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN0_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN0_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN0_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN0_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN0_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN0_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN1_RANGE (0x4003308c) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN1_RANGE_ADDR (0x4003308c)
#define IAXXX_HMD_PAC_WIN1_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN1_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN1_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN1_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window1 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN1_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN1_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN1_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN1_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN1_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window1 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window1 when PAC_WIN1_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN1_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN1_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN1_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN1_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN1_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN1_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN2_RANGE (0x40033090) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN2_RANGE_ADDR (0x40033090)
#define IAXXX_HMD_PAC_WIN2_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN2_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN2_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN2_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window2 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN2_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN2_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN2_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN2_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN2_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window2 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window2 when PAC_WIN2_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN2_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN2_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN2_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN2_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN2_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN2_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN3_RANGE (0x40033094) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN3_RANGE_ADDR (0x40033094)
#define IAXXX_HMD_PAC_WIN3_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN3_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN3_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN3_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window3 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN3_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN3_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN3_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN3_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN3_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window3 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window3 when PAC_WIN3_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN3_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN3_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN3_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN3_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN3_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN3_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN4_RANGE (0x40033098) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN4_RANGE_ADDR (0x40033098)
#define IAXXX_HMD_PAC_WIN4_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN4_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN4_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN4_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window4 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN4_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN4_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN4_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN4_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN4_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window4 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window4 when PAC_WIN4_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN4_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN4_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN4_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN4_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN4_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN4_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN5_RANGE (0x4003309c) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN5_RANGE_ADDR (0x4003309c)
#define IAXXX_HMD_PAC_WIN5_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN5_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN5_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN5_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window5 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN5_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN5_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN5_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN5_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN5_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window5 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window5 when PAC_WIN5_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN5_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN5_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN5_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN5_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN5_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN5_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN6_RANGE (0x400330a0) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN6_RANGE_ADDR (0x400330a0)
#define IAXXX_HMD_PAC_WIN6_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN6_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN6_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN6_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window6 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN6_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN6_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN6_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN6_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN6_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window6 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window6 when PAC_WIN6_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN6_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN6_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN6_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN6_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN6_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN6_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN7_RANGE (0x400330a4) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN7_RANGE_ADDR (0x400330a4)
#define IAXXX_HMD_PAC_WIN7_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN7_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN7_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN7_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window7 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN7_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN7_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN7_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN7_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN7_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window7 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window7 when PAC_WIN7_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN7_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN7_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN7_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN7_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN7_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN7_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN8_RANGE (0x400330a8) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN8_RANGE_ADDR (0x400330a8)
#define IAXXX_HMD_PAC_WIN8_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN8_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN8_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN8_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window8 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN8_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN8_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN8_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN8_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN8_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window8 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window8 when PAC_WIN8_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN8_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN8_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN8_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN8_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN8_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN8_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN9_RANGE (0x400330ac) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN9_RANGE_ADDR (0x400330ac)
#define IAXXX_HMD_PAC_WIN9_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN9_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN9_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN9_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window9 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN9_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN9_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN9_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN9_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN9_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window9 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window9 when PAC_WIN9_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN9_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN9_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN9_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN9_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN9_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN9_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN10_RANGE (0x400330b0) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN10_RANGE_ADDR (0x400330b0)
#define IAXXX_HMD_PAC_WIN10_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN10_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN10_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN10_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window10 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN10_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN10_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN10_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN10_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN10_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window10 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window10 when PAC_WIN10_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN10_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN10_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN10_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN10_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN10_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN10_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN11_RANGE (0x400330b4) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN11_RANGE_ADDR (0x400330b4)
#define IAXXX_HMD_PAC_WIN11_RANGE_MASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN11_RANGE_RMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN11_RANGE_WMASK_VAL 0xffff7fff
#define IAXXX_HMD_PAC_WIN11_RANGE_RESET_VAL 0x00000000

/*
 * These 15 bits set the address window11 base for in-bound AHB address
 * bits[(24:10)]. This number is included in the address comparison
 * The in-bound AHB address's top 7 bits [(31:25)] are fixed: DMAC=7'b0101_000;
 * GLBL_MEM=7'b0101_100; HMD=7'b1010_011; DMX=7'b1010_100
 */
#define IAXXX_HMD_PAC_WIN11_RANGE_BASE_MASK 0x00007fff
#define IAXXX_HMD_PAC_WIN11_RANGE_BASE_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN11_RANGE_BASE_POS 0
#define IAXXX_HMD_PAC_WIN11_RANGE_BASE_SIZE 15
#define IAXXX_HMD_PAC_WIN11_RANGE_BASE_DECL (14:0)

/*
 * These 16 bits set the address window11 bound for in-bound AHB address
 * bits[(24:10)]. This number is excluded in the address comparison
 * An address is in a window11 when PAC_WIN11_RANGE.BOUND > {1'b0,
 * AHB_HADDR[(24:10)]} and AHB_HADDR[(24:10)] >= PAC_WIN11_RANGE.BASE and an
 * internal AHB_HSEL is asserted and AHB_ADDR[(31:25)] match the system
 * address's top 7 bits
 */
#define IAXXX_HMD_PAC_WIN11_RANGE_BOUND_MASK 0xffff0000
#define IAXXX_HMD_PAC_WIN11_RANGE_BOUND_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN11_RANGE_BOUND_POS 16
#define IAXXX_HMD_PAC_WIN11_RANGE_BOUND_SIZE 16
#define IAXXX_HMD_PAC_WIN11_RANGE_BOUND_DECL (31:16)

/*** HMD_PAC_WIN_DFLT_DENY_PERM (0x400330b8) ***/
/*
 */
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_ADDR (0x400330b8)
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_MASK_VAL 0x0000001a
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_RMASK_VAL 0x0000001a
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_WMASK_VAL 0x0000001a
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_RESET_VAL 0x00000000

/*
 * This bit determines if any out-of-address-windows access from DMX is
 * denied or not
 * If this bit is 0: An access from DMX out-of-address-windows is passed
 * along
 * Else if this bit is 1: Any access from DMX out-of-address-windows causes
 * DMX_WIN_DFLT_DENY_EXCP to be asserted in <a
 * href="#Edradour.HMD.PAC_EXCP_STS">PAC_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMX_WIN_DFLT_DENY_MASK 0x00000002
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMX_WIN_DFLT_DENY_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMX_WIN_DFLT_DENY_POS 1
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMX_WIN_DFLT_DENY_SIZE 1
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMX_WIN_DFLT_DENY_DECL 1

/*
 * This bit determines if any out-of-address-windows access from DMAC_M1 is
 * denied or not
 * If this bit is 0: An access from DMAC_M1 out-of-address-windows is passed
 * along
 * Else if this bit is 1: Any access from DMAC_M1 out-of-address-windows
 * causes DMAC_M1_WIN_DFLT_DENY_EXCP to be asserted in <a
 * href="#Edradour.HMD.PAC_EXCP_STS">PAC_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMAC_M1_WIN_DFLT_DENY_MASK 0x00000008
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMAC_M1_WIN_DFLT_DENY_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMAC_M1_WIN_DFLT_DENY_POS 3
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMAC_M1_WIN_DFLT_DENY_SIZE 1
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DMAC_M1_WIN_DFLT_DENY_DECL 3

/*
 * This bit determines if any out-of-address-windows access from DEBUG is
 * denied or not
 * If this bit is 0: An access from DEBUG out-of-address-windows is passed
 * along
 * Else if this bit is 1: Any access from DEBUG out-of-address-windows causes
 * DEBUG_WIN_DFLT_DENY_EXCP to be asserted in <a
 * href="#Edradour.HMD.PAC_EXCP_STS">PAC_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DEBUG_WIN_DFLT_DENY_MASK 0x00000010
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DEBUG_WIN_DFLT_DENY_RESET_VAL 0x0
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DEBUG_WIN_DFLT_DENY_POS 4
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DEBUG_WIN_DFLT_DENY_SIZE 1
#define IAXXX_HMD_PAC_WIN_DFLT_DENY_PERM_DEBUG_WIN_DFLT_DENY_DECL 4

/*** HMD_PAC_DMX_WIN_DENY_PERM (0x400330bc) ***/
/*
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_ADDR (0x400330bc)
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_RESET_VAL 0x00000000

/*
 * If this bit is set to 0 then:
 * Read access within address window0 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window0 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN0_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN0_DECL 0

/*
 * If this bit is set to 0 then:
 * Read access within address window1 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window1 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN1_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN1_DECL 1

/*
 * If this bit is set to 0 then:
 * Read access within address window2 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window2 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN2_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN2_DECL 2

/*
 * If this bit is set to 0 then:
 * Read access within address window3 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window3 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN3_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN3_DECL 3

/*
 * If this bit is set to 0 then:
 * Read access within address window4 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window4 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN4_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN4_DECL 4

/*
 * If this bit is set to 0 then:
 * Read access within address window5 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window5 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN5_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN5_DECL 5

/*
 * If this bit is set to 0 then:
 * Read access within address window6 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window6 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN6_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN6_DECL 6

/*
 * If this bit is set to 0 then:
 * Read access within address window7 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window7 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN7_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN7_DECL 7

/*
 * If this bit is set to 0 then:
 * Read access within address window8 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window8 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN8_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN8_DECL 8

/*
 * If this bit is set to 0 then:
 * Read access within address window9 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window9 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN9_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN9_DECL 9

/*
 * If this bit is set to 0 then:
 * Read access within address window10 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window10 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN10_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN10_DECL 10

/*
 * If this bit is set to 0 then:
 * Read access within address window11 from DMX is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMX_WIN_WR_PERM">PAC_DMX_WIN_WR_PERM</a> register
 * If this bit is set to 1 then :
 * Any access within address window11 from DMX is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMX. WIN11_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMX_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_DENY_PERM_WIN11_DECL 11

/*** HMD_PAC_DMX_WIN_WR_PERM (0x400330c0) ***/
/*
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_ADDR (0x400330c0)
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_RESET_VAL 0x00000000

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN0_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN0_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN0_DECL 0

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN1_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN1_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN1_DECL 1

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN2_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN2_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN2_DECL 2

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN3_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN3_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN3_DECL 3

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN4_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN4_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN4_DECL 4

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN5_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN5_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN5_DECL 5

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN6_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN6_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN6_DECL 6

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN7_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN7_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN7_DECL 7

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN8_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN8_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN8_DECL 8

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN9_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN9_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN9_DECL 9

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN10_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN10_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN10_DECL 10

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN11_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMX_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMX_WIN_DENY_PERM">PAC_DMX_WIN11_DENY_PERM</a> bit
 * is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DMX_WIN_WR_PERM_WIN11_DECL 11

/*** HMD_PAC_DMAC_M1_WIN_DENY_PERM (0x400330c4) ***/
/*
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_ADDR (0x400330c4)
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_RESET_VAL 0x00000000

/*
 * If this bit is set to 0 then:
 * Read access within address window0 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window0 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN0_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN0_DECL 0

/*
 * If this bit is set to 0 then:
 * Read access within address window1 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window1 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN1_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN1_DECL 1

/*
 * If this bit is set to 0 then:
 * Read access within address window2 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window2 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN2_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN2_DECL 2

/*
 * If this bit is set to 0 then:
 * Read access within address window3 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window3 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN3_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN3_DECL 3

/*
 * If this bit is set to 0 then:
 * Read access within address window4 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window4 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN4_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN4_DECL 4

/*
 * If this bit is set to 0 then:
 * Read access within address window5 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window5 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN5_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN5_DECL 5

/*
 * If this bit is set to 0 then:
 * Read access within address window6 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window6 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN6_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN6_DECL 6

/*
 * If this bit is set to 0 then:
 * Read access within address window7 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window7 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN7_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN7_DECL 7

/*
 * If this bit is set to 0 then:
 * Read access within address window8 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window8 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN8_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN8_DECL 8

/*
 * If this bit is set to 0 then:
 * Read access within address window9 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window9 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN9_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN9_DECL 9

/*
 * If this bit is set to 0 then:
 * Read access within address window10 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window10 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN10_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN10_DECL 10

/*
 * If this bit is set to 0 then:
 * Read access within address window11 from DMAC_M1 is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_WR_PERM">PAC_DMAC_M1_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window11 from DMAC_M1 is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DMAC_M1. WIN11_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_DENY_PERM_WIN11_DECL 11

/*** HMD_PAC_DMAC_M1_WIN_WR_PERM (0x400330c8) ***/
/*
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_ADDR (0x400330c8)
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_RESET_VAL 0x00000000

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN0_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN0_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN0_DECL 0

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN1_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN1_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN1_DECL 1

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN2_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN2_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN2_DECL 2

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN3_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN3_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN3_DECL 3

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN4_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN4_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN4_DECL 4

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN5_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN5_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN5_DECL 5

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN6_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN6_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN6_DECL 6

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN7_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN7_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN7_DECL 7

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN8_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN8_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN8_DECL 8

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN9_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN9_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN9_DECL 9

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN10_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN10_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN10_DECL 10

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN11_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DMAC_M1_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DMAC_M1_WIN_DENY_PERM">PAC_DMAC_M1_WIN11_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_WIN_WR_PERM_WIN11_DECL 11

/*** HMD_PAC_DEBUG_WIN_DENY_PERM (0x400330cc) ***/
/*
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_ADDR (0x400330cc)
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_RESET_VAL 0x00000000

/*
 * If this bit is set to 0 then:
 * Read access within address window0 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window0 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN0_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN0_DECL 0

/*
 * If this bit is set to 0 then:
 * Read access within address window1 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window1 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN1_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN1_DECL 1

/*
 * If this bit is set to 0 then:
 * Read access within address window2 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window2 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN2_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN2_DECL 2

/*
 * If this bit is set to 0 then:
 * Read access within address window3 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window3 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN3_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN3_DECL 3

/*
 * If this bit is set to 0 then:
 * Read access within address window4 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window4 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN4_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN4_DECL 4

/*
 * If this bit is set to 0 then:
 * Read access within address window5 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window5 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN5_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN5_DECL 5

/*
 * If this bit is set to 0 then:
 * Read access within address window6 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window6 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN6_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN6_DECL 6

/*
 * If this bit is set to 0 then:
 * Read access within address window7 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window7 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN7_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN7_DECL 7

/*
 * If this bit is set to 0 then:
 * Read access within address window8 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window8 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN8_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN8_DECL 8

/*
 * If this bit is set to 0 then:
 * Read access within address window9 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window9 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN9_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN9_DECL 9

/*
 * If this bit is set to 0 then:
 * Read access within address window10 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window10 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN10_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN10_DECL 10

/*
 * If this bit is set to 0 then:
 * Read access within address window11 from DEBUG is allowed;
 * Write access is determined by the corresponding bit in <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_WR_PERM">PAC_DEBUG_WIN_WR_PERM</a>
 * register
 * If this bit is set to 1 then :
 * Any access within address window11 from DEBUG is not propaged
 * Write access will not be allowed and read access will return data
 * 0xbadacc55 back to DEBUG. WIN11_DENY_EXCP is asserted in <a
 * href="#Edradour.HMD.PAC_HMD_EXCP_STS">PAC_DEBUG_EXCP_STS</a> register
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_DENY_PERM_WIN11_DECL 11

/*** HMD_PAC_DEBUG_WIN_WR_PERM (0x400330d0) ***/
/*
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_ADDR (0x400330d0)
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_MASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_RMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WMASK_VAL 0x00000fff
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_RESET_VAL 0x00000000

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN0_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN0_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN0_MASK 0x00000001
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN0_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN0_POS 0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN0_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN0_DECL 0

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN1_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN1_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN1_MASK 0x00000002
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN1_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN1_POS 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN1_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN1_DECL 1

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN2_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN2_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN2_MASK 0x00000004
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN2_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN2_POS 2
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN2_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN2_DECL 2

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN3_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN3_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN3_MASK 0x00000008
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN3_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN3_POS 3
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN3_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN3_DECL 3

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN4_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN4_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN4_MASK 0x00000010
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN4_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN4_POS 4
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN4_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN4_DECL 4

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN5_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN5_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN5_MASK 0x00000020
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN5_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN5_POS 5
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN5_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN5_DECL 5

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN6_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN6_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN6_MASK 0x00000040
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN6_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN6_POS 6
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN6_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN6_DECL 6

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN7_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN7_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN7_MASK 0x00000080
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN7_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN7_POS 7
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN7_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN7_DECL 7

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN8_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN8_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN8_MASK 0x00000100
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN8_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN8_POS 8
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN8_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN8_DECL 8

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN9_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN9_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN9_MASK 0x00000200
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN9_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN9_POS 9
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN9_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN9_DECL 9

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN10_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN10_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN10_MASK 0x00000400
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN10_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN10_POS 10
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN10_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN10_DECL 10

/*
 * if this bit is set to 0 then:
 * Any write access is not allowed. A write attempt causes WIN11_DENY_WR_EXCP
 * asserted in <a href="#Edradour.HMD.PAC_EXCP_STS">PAC_DEBUG_EXCP_STS</a>
 * register
 * If this bit is set to 1 and corresponding <a
 * href="#Edradour.HMD.PAC_DEBUG_WIN_DENY_PERM">PAC_DEBUG_WIN11_DENY_PERM</a>
 * bit is 0 then:
 * Write access is allowed.
 */
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN11_MASK 0x00000800
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN11_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN11_POS 11
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN11_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_WIN_WR_PERM_WIN11_DECL 11

/*** HMD_PAC_EXCP_STS (0x400330d4) ***/
/*
 */
#define IAXXX_HMD_PAC_EXCP_STS_ADDR (0x400330d4)
#define IAXXX_HMD_PAC_EXCP_STS_MASK_VAL 0x0000003a
#define IAXXX_HMD_PAC_EXCP_STS_RMASK_VAL 0x0000003a
#define IAXXX_HMD_PAC_EXCP_STS_WMASK_VAL 0x0000003a
#define IAXXX_HMD_PAC_EXCP_STS_RESET_VAL 0x00000000

/*
 * Set to 1 when DMX_WIN_DFLT_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_EXCP_STS_DMX_WIN_DFLT_DENY_EXCP_MASK 0x00000002
#define IAXXX_HMD_PAC_EXCP_STS_DMX_WIN_DFLT_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_STS_DMX_WIN_DFLT_DENY_EXCP_POS 1
#define IAXXX_HMD_PAC_EXCP_STS_DMX_WIN_DFLT_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_EXCP_STS_DMX_WIN_DFLT_DENY_EXCP_DECL 1

/*
 * Set to 1 when DMAC_M1_WIN_DFLT_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_EXCP_STS_DMAC_M1_WIN_DFLT_DENY_EXCP_MASK 0x00000008
#define IAXXX_HMD_PAC_EXCP_STS_DMAC_M1_WIN_DFLT_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_STS_DMAC_M1_WIN_DFLT_DENY_EXCP_POS 3
#define IAXXX_HMD_PAC_EXCP_STS_DMAC_M1_WIN_DFLT_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_EXCP_STS_DMAC_M1_WIN_DFLT_DENY_EXCP_DECL 3

/*
 * Set to 1 when DEBUG_WIN_DFLT_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_EXCP_STS_DEBUG_WIN_DFLT_DENY_EXCP_MASK 0x00000010
#define IAXXX_HMD_PAC_EXCP_STS_DEBUG_WIN_DFLT_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_STS_DEBUG_WIN_DFLT_DENY_EXCP_POS 4
#define IAXXX_HMD_PAC_EXCP_STS_DEBUG_WIN_DFLT_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_EXCP_STS_DEBUG_WIN_DFLT_DENY_EXCP_DECL 4

/*
 * Set to 1 when programmed windows are overlapped. Write 1 to clear
 */
#define IAXXX_HMD_PAC_EXCP_STS_WIN_PROG_FAULT_EXCP_MASK 0x00000020
#define IAXXX_HMD_PAC_EXCP_STS_WIN_PROG_FAULT_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_STS_WIN_PROG_FAULT_EXCP_POS 5
#define IAXXX_HMD_PAC_EXCP_STS_WIN_PROG_FAULT_EXCP_SIZE 1
#define IAXXX_HMD_PAC_EXCP_STS_WIN_PROG_FAULT_EXCP_DECL 5

/*** HMD_PAC_DMX_EXCP_STS (0x400330d8) ***/
/*
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_ADDR (0x400330d8)
#define IAXXX_HMD_PAC_DMX_EXCP_STS_MASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMX_EXCP_STS_RMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMX_EXCP_STS_RESET_VAL 0x00000000

/*
 * Set to 1 when WIN0_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_DENY_EXCP_MASK 0x00000001
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_DENY_EXCP_POS 0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_DENY_EXCP_DECL 0

/*
 * Set to 1 when WIN1_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_DENY_EXCP_MASK 0x00000002
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_DENY_EXCP_POS 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_DENY_EXCP_DECL 1

/*
 * Set to 1 when WIN2_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_DENY_EXCP_MASK 0x00000004
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_DENY_EXCP_POS 2
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_DENY_EXCP_DECL 2

/*
 * Set to 1 when WIN3_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_DENY_EXCP_MASK 0x00000008
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_DENY_EXCP_POS 3
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_DENY_EXCP_DECL 3

/*
 * Set to 1 when WIN4_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_DENY_EXCP_MASK 0x00000010
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_DENY_EXCP_POS 4
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_DENY_EXCP_DECL 4

/*
 * Set to 1 when WIN5_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_DENY_EXCP_MASK 0x00000020
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_DENY_EXCP_POS 5
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_DENY_EXCP_DECL 5

/*
 * Set to 1 when WIN6_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_DENY_EXCP_MASK 0x00000040
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_DENY_EXCP_POS 6
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_DENY_EXCP_DECL 6

/*
 * Set to 1 when WIN7_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_DENY_EXCP_MASK 0x00000080
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_DENY_EXCP_POS 7
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_DENY_EXCP_DECL 7

/*
 * Set to 1 when WIN8_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_DENY_EXCP_MASK 0x00000100
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_DENY_EXCP_POS 8
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_DENY_EXCP_DECL 8

/*
 * Set to 1 when WIN9_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_DENY_EXCP_MASK 0x00000200
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_DENY_EXCP_POS 9
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_DENY_EXCP_DECL 9

/*
 * Set to 1 when WIN10_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_DENY_EXCP_MASK 0x00000400
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_DENY_EXCP_POS 10
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_DENY_EXCP_DECL 10

/*
 * Set to 1 when WIN11_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_DENY_EXCP_MASK 0x00000800
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_DENY_EXCP_POS 11
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_DENY_EXCP_DECL 11

/*
 * Set to 1 when WIN0_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_WR_DENY_EXCP_MASK 0x00001000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_WR_DENY_EXCP_POS 12
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN0_WR_DENY_EXCP_DECL 12

/*
 * Set to 1 when WIN1_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_WR_DENY_EXCP_MASK 0x00002000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_WR_DENY_EXCP_POS 13
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN1_WR_DENY_EXCP_DECL 13

/*
 * Set to 1 when WIN2_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_WR_DENY_EXCP_MASK 0x00004000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_WR_DENY_EXCP_POS 14
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN2_WR_DENY_EXCP_DECL 14

/*
 * Set to 1 when WIN3_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_WR_DENY_EXCP_MASK 0x00008000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_WR_DENY_EXCP_POS 15
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN3_WR_DENY_EXCP_DECL 15

/*
 * Set to 1 when WIN4_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_WR_DENY_EXCP_MASK 0x00010000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_WR_DENY_EXCP_POS 16
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN4_WR_DENY_EXCP_DECL 16

/*
 * Set to 1 when WIN5_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_WR_DENY_EXCP_MASK 0x00020000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_WR_DENY_EXCP_POS 17
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN5_WR_DENY_EXCP_DECL 17

/*
 * Set to 1 when WIN6_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_WR_DENY_EXCP_MASK 0x00040000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_WR_DENY_EXCP_POS 18
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN6_WR_DENY_EXCP_DECL 18

/*
 * Set to 1 when WIN7_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_WR_DENY_EXCP_MASK 0x00080000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_WR_DENY_EXCP_POS 19
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN7_WR_DENY_EXCP_DECL 19

/*
 * Set to 1 when WIN8_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_WR_DENY_EXCP_MASK 0x00100000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_WR_DENY_EXCP_POS 20
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN8_WR_DENY_EXCP_DECL 20

/*
 * Set to 1 when WIN9_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_WR_DENY_EXCP_MASK 0x00200000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_WR_DENY_EXCP_POS 21
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN9_WR_DENY_EXCP_DECL 21

/*
 * Set to 1 when WIN10_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_WR_DENY_EXCP_MASK 0x00400000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_WR_DENY_EXCP_POS 22
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN10_WR_DENY_EXCP_DECL 22

/*
 * Set to 1 when WIN11_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_WR_DENY_EXCP_MASK 0x00800000
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_WR_DENY_EXCP_POS 23
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMX_EXCP_STS_WIN11_WR_DENY_EXCP_DECL 23

/*** HMD_PAC_DMAC_M1_EXCP_STS (0x400330dc) ***/
/*
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_ADDR (0x400330dc)
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_MASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_RMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_RESET_VAL 0x00000000

/*
 * Set to 1 when WIN0_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_DENY_EXCP_MASK 0x00000001
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_DENY_EXCP_POS 0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_DENY_EXCP_DECL 0

/*
 * Set to 1 when WIN1_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_DENY_EXCP_MASK 0x00000002
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_DENY_EXCP_POS 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_DENY_EXCP_DECL 1

/*
 * Set to 1 when WIN2_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_DENY_EXCP_MASK 0x00000004
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_DENY_EXCP_POS 2
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_DENY_EXCP_DECL 2

/*
 * Set to 1 when WIN3_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_DENY_EXCP_MASK 0x00000008
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_DENY_EXCP_POS 3
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_DENY_EXCP_DECL 3

/*
 * Set to 1 when WIN4_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_DENY_EXCP_MASK 0x00000010
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_DENY_EXCP_POS 4
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_DENY_EXCP_DECL 4

/*
 * Set to 1 when WIN5_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_DENY_EXCP_MASK 0x00000020
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_DENY_EXCP_POS 5
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_DENY_EXCP_DECL 5

/*
 * Set to 1 when WIN6_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_DENY_EXCP_MASK 0x00000040
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_DENY_EXCP_POS 6
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_DENY_EXCP_DECL 6

/*
 * Set to 1 when WIN7_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_DENY_EXCP_MASK 0x00000080
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_DENY_EXCP_POS 7
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_DENY_EXCP_DECL 7

/*
 * Set to 1 when WIN8_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_DENY_EXCP_MASK 0x00000100
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_DENY_EXCP_POS 8
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_DENY_EXCP_DECL 8

/*
 * Set to 1 when WIN9_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_DENY_EXCP_MASK 0x00000200
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_DENY_EXCP_POS 9
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_DENY_EXCP_DECL 9

/*
 * Set to 1 when WIN10_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_DENY_EXCP_MASK 0x00000400
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_DENY_EXCP_POS 10
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_DENY_EXCP_DECL 10

/*
 * Set to 1 when WIN11_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_DENY_EXCP_MASK 0x00000800
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_DENY_EXCP_POS 11
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_DENY_EXCP_DECL 11

/*
 * Set to 1 when WIN0_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_WR_DENY_EXCP_MASK 0x00001000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_WR_DENY_EXCP_POS 12
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN0_WR_DENY_EXCP_DECL 12

/*
 * Set to 1 when WIN1_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_WR_DENY_EXCP_MASK 0x00002000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_WR_DENY_EXCP_POS 13
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN1_WR_DENY_EXCP_DECL 13

/*
 * Set to 1 when WIN2_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_WR_DENY_EXCP_MASK 0x00004000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_WR_DENY_EXCP_POS 14
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN2_WR_DENY_EXCP_DECL 14

/*
 * Set to 1 when WIN3_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_WR_DENY_EXCP_MASK 0x00008000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_WR_DENY_EXCP_POS 15
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN3_WR_DENY_EXCP_DECL 15

/*
 * Set to 1 when WIN4_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_WR_DENY_EXCP_MASK 0x00010000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_WR_DENY_EXCP_POS 16
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN4_WR_DENY_EXCP_DECL 16

/*
 * Set to 1 when WIN5_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_WR_DENY_EXCP_MASK 0x00020000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_WR_DENY_EXCP_POS 17
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN5_WR_DENY_EXCP_DECL 17

/*
 * Set to 1 when WIN6_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_WR_DENY_EXCP_MASK 0x00040000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_WR_DENY_EXCP_POS 18
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN6_WR_DENY_EXCP_DECL 18

/*
 * Set to 1 when WIN7_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_WR_DENY_EXCP_MASK 0x00080000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_WR_DENY_EXCP_POS 19
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN7_WR_DENY_EXCP_DECL 19

/*
 * Set to 1 when WIN8_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_WR_DENY_EXCP_MASK 0x00100000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_WR_DENY_EXCP_POS 20
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN8_WR_DENY_EXCP_DECL 20

/*
 * Set to 1 when WIN9_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_WR_DENY_EXCP_MASK 0x00200000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_WR_DENY_EXCP_POS 21
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN9_WR_DENY_EXCP_DECL 21

/*
 * Set to 1 when WIN10_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_WR_DENY_EXCP_MASK 0x00400000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_WR_DENY_EXCP_POS 22
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN10_WR_DENY_EXCP_DECL 22

/*
 * Set to 1 when WIN11_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_WR_DENY_EXCP_MASK 0x00800000
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_WR_DENY_EXCP_POS 23
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DMAC_M1_EXCP_STS_WIN11_WR_DENY_EXCP_DECL 23

/*** HMD_PAC_DEBUG_EXCP_STS (0x400330e0) ***/
/*
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_ADDR (0x400330e0)
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_MASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_RMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WMASK_VAL 0x00ffffff
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_RESET_VAL 0x00000000

/*
 * Set to 1 when WIN0_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_DENY_EXCP_MASK 0x00000001
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_DENY_EXCP_POS 0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_DENY_EXCP_DECL 0

/*
 * Set to 1 when WIN1_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_DENY_EXCP_MASK 0x00000002
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_DENY_EXCP_POS 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_DENY_EXCP_DECL 1

/*
 * Set to 1 when WIN2_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_DENY_EXCP_MASK 0x00000004
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_DENY_EXCP_POS 2
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_DENY_EXCP_DECL 2

/*
 * Set to 1 when WIN3_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_DENY_EXCP_MASK 0x00000008
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_DENY_EXCP_POS 3
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_DENY_EXCP_DECL 3

/*
 * Set to 1 when WIN4_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_DENY_EXCP_MASK 0x00000010
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_DENY_EXCP_POS 4
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_DENY_EXCP_DECL 4

/*
 * Set to 1 when WIN5_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_DENY_EXCP_MASK 0x00000020
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_DENY_EXCP_POS 5
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_DENY_EXCP_DECL 5

/*
 * Set to 1 when WIN6_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_DENY_EXCP_MASK 0x00000040
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_DENY_EXCP_POS 6
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_DENY_EXCP_DECL 6

/*
 * Set to 1 when WIN7_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_DENY_EXCP_MASK 0x00000080
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_DENY_EXCP_POS 7
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_DENY_EXCP_DECL 7

/*
 * Set to 1 when WIN8_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_DENY_EXCP_MASK 0x00000100
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_DENY_EXCP_POS 8
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_DENY_EXCP_DECL 8

/*
 * Set to 1 when WIN9_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_DENY_EXCP_MASK 0x00000200
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_DENY_EXCP_POS 9
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_DENY_EXCP_DECL 9

/*
 * Set to 1 when WIN10_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_DENY_EXCP_MASK 0x00000400
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_DENY_EXCP_POS 10
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_DENY_EXCP_DECL 10

/*
 * Set to 1 when WIN11_DENY_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_DENY_EXCP_MASK 0x00000800
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_DENY_EXCP_POS 11
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_DENY_EXCP_DECL 11

/*
 * Set to 1 when WIN0_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_WR_DENY_EXCP_MASK 0x00001000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_WR_DENY_EXCP_POS 12
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN0_WR_DENY_EXCP_DECL 12

/*
 * Set to 1 when WIN1_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_WR_DENY_EXCP_MASK 0x00002000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_WR_DENY_EXCP_POS 13
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN1_WR_DENY_EXCP_DECL 13

/*
 * Set to 1 when WIN2_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_WR_DENY_EXCP_MASK 0x00004000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_WR_DENY_EXCP_POS 14
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN2_WR_DENY_EXCP_DECL 14

/*
 * Set to 1 when WIN3_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_WR_DENY_EXCP_MASK 0x00008000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_WR_DENY_EXCP_POS 15
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN3_WR_DENY_EXCP_DECL 15

/*
 * Set to 1 when WIN4_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_WR_DENY_EXCP_MASK 0x00010000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_WR_DENY_EXCP_POS 16
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN4_WR_DENY_EXCP_DECL 16

/*
 * Set to 1 when WIN5_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_WR_DENY_EXCP_MASK 0x00020000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_WR_DENY_EXCP_POS 17
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN5_WR_DENY_EXCP_DECL 17

/*
 * Set to 1 when WIN6_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_WR_DENY_EXCP_MASK 0x00040000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_WR_DENY_EXCP_POS 18
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN6_WR_DENY_EXCP_DECL 18

/*
 * Set to 1 when WIN7_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_WR_DENY_EXCP_MASK 0x00080000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_WR_DENY_EXCP_POS 19
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN7_WR_DENY_EXCP_DECL 19

/*
 * Set to 1 when WIN8_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_WR_DENY_EXCP_MASK 0x00100000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_WR_DENY_EXCP_POS 20
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN8_WR_DENY_EXCP_DECL 20

/*
 * Set to 1 when WIN9_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_WR_DENY_EXCP_MASK 0x00200000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_WR_DENY_EXCP_POS 21
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN9_WR_DENY_EXCP_DECL 21

/*
 * Set to 1 when WIN10_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_WR_DENY_EXCP_MASK 0x00400000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_WR_DENY_EXCP_POS 22
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN10_WR_DENY_EXCP_DECL 22

/*
 * Set to 1 when WIN11_WR_EXCP is asserted. Write 1 to clear
 */
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_WR_DENY_EXCP_MASK 0x00800000
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_WR_DENY_EXCP_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_WR_DENY_EXCP_POS 23
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_WR_DENY_EXCP_SIZE 1
#define IAXXX_HMD_PAC_DEBUG_EXCP_STS_WIN11_WR_DENY_EXCP_DECL 23

/*** HMD_PAC_EXCP_LATCH (0x400330e4) ***/
/*
 */
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR (0x400330e4)
#define IAXXX_HMD_PAC_EXCP_LATCH_MASK_VAL 0xffffffff
#define IAXXX_HMD_PAC_EXCP_LATCH_RMASK_VAL 0xffffffff
#define IAXXX_HMD_PAC_EXCP_LATCH_WMASK_VAL 0x80000000
#define IAXXX_HMD_PAC_EXCP_LATCH_RESET_VAL 0x43c00000

/*
 * Set to the system address from AHB bridge, [(31:10)] that causes the first
 * processor exception.
 */
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR_MASK 0x003fffff
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR_POS 0
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR_SIZE 22
#define IAXXX_HMD_PAC_EXCP_LATCH_ADDR_DECL (21:0)

/*
 * These 4 bits records the AHB master ID that causes the first processor
 * exception:
 * HMD=4'b0100; DMX=4'b0101; DMA_M0=4'b0110, DMA_M1=4'b0111;
 * These bits are reset and cleared to be 4'b1111. When it is 4'b1111 it
 * means no exception has occurred since last reset or clear
 */
#define IAXXX_HMD_PAC_EXCP_LATCH_HMASTER_ID_MASK 0x03c00000
#define IAXXX_HMD_PAC_EXCP_LATCH_HMASTER_ID_RESET_VAL 0xf
#define IAXXX_HMD_PAC_EXCP_LATCH_HMASTER_ID_POS 22
#define IAXXX_HMD_PAC_EXCP_LATCH_HMASTER_ID_SIZE 4
#define IAXXX_HMD_PAC_EXCP_LATCH_HMASTER_ID_DECL (25:22)

/*
 * These 5 bits records the AHB window number that causes the first processor
 * exception:
 * win0=5'b00000; win1=5'b00001; win2=5'b00010; ..., win11=5'b01011
 * out_of_all_windows=5'b01111
 * These bits are reset and cleared to be 5'b10000. When these bits are
 * 5'b100000, it means no exception has occurred since last reset of clear
 * The valid read-back value is: 5'b00000 through 5'b01011, 5'b01111 and
 * 5'b10000
 */
#define IAXXX_HMD_PAC_EXCP_LATCH_WIN_MASK 0x7c000000
#define IAXXX_HMD_PAC_EXCP_LATCH_WIN_RESET_VAL 0x10
#define IAXXX_HMD_PAC_EXCP_LATCH_WIN_POS 26
#define IAXXX_HMD_PAC_EXCP_LATCH_WIN_SIZE 5
#define IAXXX_HMD_PAC_EXCP_LATCH_WIN_DECL (30:26)

/*
 * Write 1 to this register to clear PAC_EXCP_LATCH.ADDR,
 * PAC_EXCP_LATCH.HMASTER_ID,PAC_EXCP_LATCH.WIN. This bit need to be reset
 * back to 0 for PAC to latch the next exception ADDR, HMASTER_ID and WIN
 */
#define IAXXX_HMD_PAC_EXCP_LATCH_CLR_MASK 0x80000000
#define IAXXX_HMD_PAC_EXCP_LATCH_CLR_RESET_VAL 0x0
#define IAXXX_HMD_PAC_EXCP_LATCH_CLR_POS 31
#define IAXXX_HMD_PAC_EXCP_LATCH_CLR_SIZE 1
#define IAXXX_HMD_PAC_EXCP_LATCH_CLR_DECL 31

/*** HMD_PAC_DUMMY (0x400330e8) ***/
/*
 */
#define IAXXX_HMD_PAC_DUMMY_ADDR (0x400330e8)
#define IAXXX_HMD_PAC_DUMMY_MASK_VAL 0xffffffff
#define IAXXX_HMD_PAC_DUMMY_RMASK_VAL 0xffffffff
#define IAXXX_HMD_PAC_DUMMY_WMASK_VAL 0xffffffff
#define IAXXX_HMD_PAC_DUMMY_RESET_VAL 0x00000000

/*
 * Debug register
 */
#define IAXXX_HMD_PAC_DUMMY_PAC_DUMMY_MASK 0xffffffff
#define IAXXX_HMD_PAC_DUMMY_PAC_DUMMY_RESET_VAL 0x0
#define IAXXX_HMD_PAC_DUMMY_PAC_DUMMY_POS 0
#define IAXXX_HMD_PAC_DUMMY_PAC_DUMMY_SIZE 32
#define IAXXX_HMD_PAC_DUMMY_PAC_DUMMY_DECL (31:0)

/*** HMD_MEM_RELOC_POOL_TN_RAM_0 (0x400330ec) ***/
/*
 * This register is used by HMD to relocate POOL_TN_RAM_0 memory (8 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f1fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x1fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x1fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_TN_RAM_0
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR (0x400330ec)
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_RESET_VAL 0x00000000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20009fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fdfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fdfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x207fffff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR_RANGE_RESET_VAL 0x0
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_0_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_TN_RAM_1 (0x400330f0) ***/
/*
 * This register is used by HMD to relocate POOL_TN_RAM_1 memory (8 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f1fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x1fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x1fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_TN_RAM_1
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR (0x400330f0)
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_RESET_VAL 0x00002000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20009fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fdfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fdfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x207fffff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR_RANGE_RESET_VAL 0x1
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_1_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_TN_RAM_2 (0x400330f4) ***/
/*
 * This register is used by HMD to relocate POOL_TN_RAM_2 memory (8 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f1fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x1fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x1fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_TN_RAM_2
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR (0x400330f4)
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_RESET_VAL 0x00004000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20009fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fdfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fdfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x207fffff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR_RANGE_RESET_VAL 0x2
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_2_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_TN_RAM_3 (0x400330f8) ***/
/*
 * This register is used by HMD to relocate POOL_TN_RAM_3 memory (8 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f1fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x1fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x1fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_TN_RAM_3
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR (0x400330f8)
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_RESET_VAL 0x00006000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20009fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fdfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fdfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x207fffff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR_RANGE_RESET_VAL 0x3
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_TN_RAM_3_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_SM_RAM_0 (0x400330fc) ***/
/*
 * This register is used by HMD to relocate POOL_SM_RAM_0 memory (16 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f3fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x3fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x3fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_SM_RAM_0
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR (0x400330fc)
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_RESET_VAL 0x00008000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fffff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20401fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20801fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR_RANGE_RESET_VAL 0x4
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_0_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_SM_RAM_1 (0x40033100) ***/
/*
 * This register is used by HMD to relocate POOL_SM_RAM_1 memory (16 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f3fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x3fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x3fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_SM_RAM_1
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR (0x40033100)
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_RESET_VAL 0x0000c000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fffff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20401fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20801fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR_RANGE_RESET_VAL 0x6
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_1_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_SM_RAM_2 (0x40033104) ***/
/*
 * This register is used by HMD to relocate POOL_SM_RAM_2 memory (16 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f3fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x3fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x3fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_SM_RAM_2
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR (0x40033104)
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_RESET_VAL 0x00010000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fffff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20401fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20801fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR_RANGE_RESET_VAL 0x8
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_2_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_SM_RAM_3 (0x40033108) ***/
/*
 * This register is used by HMD to relocate POOL_SM_RAM_3 memory (16 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f3fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x3fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x3fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_SM_RAM_3
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR (0x40033108)
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_RESET_VAL 0x00014000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x2000dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x203fffff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x207fffff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20401fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20801fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR_RANGE_RESET_VAL 0xa
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_SM_RAM_3_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_LG_RAM_0 (0x4003310c) ***/
/*
 * This register is used by HMD to relocate POOL_LG_RAM_0 memory (32 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f7fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x7fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x7fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_LG_RAM_0
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR (0x4003310c)
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_RESET_VAL 0x00018000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x20013fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20015fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x20403fff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x20803fff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20405fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20805fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR_RANGE_RESET_VAL 0xc
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_0_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_LG_RAM_1 (0x40033110) ***/
/*
 * This register is used by HMD to relocate POOL_LG_RAM_1 memory (32 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f7fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x7fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x7fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_LG_RAM_1
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR (0x40033110)
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_RESET_VAL 0x00020000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x20013fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20015fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x20403fff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x20803fff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20405fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20805fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR_RANGE_RESET_VAL 0x10
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_1_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_LG_RAM_2 (0x40033114) ***/
/*
 * This register is used by HMD to relocate POOL_LG_RAM_2 memory (32 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f7fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x7fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x7fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_LG_RAM_2
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR (0x40033114)
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_RESET_VAL 0x00028000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x20013fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20015fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x20403fff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x20803fff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20405fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20805fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR_RANGE_RESET_VAL 0x14
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_2_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_LG_RAM_3 (0x40033118) ***/
/*
 * This register is used by HMD to relocate POOL_LG_RAM_3 memory (32 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207f7fff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0x7fff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0x7fff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access POOL_LG_RAM_3
 * correctly, SW needs to program the ADDR_RANGE field of this register to a
 * value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR (0x40033118)
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_RESET_VAL 0x00030000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x2000ffff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20011fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x20013fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x20015fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x20403fff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x20803fff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x20405fff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x20805fff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR_RANGE_RESET_VAL 0x18
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_LG_RAM_3_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_00 (0x4003311c) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_00 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_00 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR (0x4003311c)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_RESET_VAL 0x00038000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR_RANGE_RESET_VAL 0x1c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_00_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_01 (0x40033120) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_01 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_01 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR (0x40033120)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_RESET_VAL 0x00048000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR_RANGE_RESET_VAL 0x24
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_01_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_02 (0x40033124) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_02 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_02 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR (0x40033124)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_RESET_VAL 0x00058000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR_RANGE_RESET_VAL 0x2c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_02_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_03 (0x40033128) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_03 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_03 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR (0x40033128)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_RESET_VAL 0x00068000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR_RANGE_RESET_VAL 0x34
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_03_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_04 (0x4003312c) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_04 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_04 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR (0x4003312c)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_RESET_VAL 0x00078000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR_RANGE_RESET_VAL 0x3c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_04_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_05 (0x40033130) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_05 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_05 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR (0x40033130)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_RESET_VAL 0x00088000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR_RANGE_RESET_VAL 0x44
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_05_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_06 (0x40033134) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_06 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_06 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR (0x40033134)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_RESET_VAL 0x00098000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR_RANGE_RESET_VAL 0x4c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_06_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_07 (0x40033138) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_07 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_07 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR (0x40033138)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_RESET_VAL 0x000a8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR_RANGE_RESET_VAL 0x54
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_07_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_08 (0x4003313c) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_08 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_08 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR (0x4003313c)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_RESET_VAL 0x000b8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR_RANGE_RESET_VAL 0x5c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_08_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_09 (0x40033140) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_09 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_09 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR (0x40033140)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_RESET_VAL 0x000c8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR_RANGE_RESET_VAL 0x64
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_09_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_10 (0x40033144) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_10 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_10 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR (0x40033144)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_RESET_VAL 0x000d8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR_RANGE_RESET_VAL 0x6c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_10_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_11 (0x40033148) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_11 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_11 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR (0x40033148)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_RESET_VAL 0x000e8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR_RANGE_RESET_VAL 0x74
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_11_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_12 (0x4003314c) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_12 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_12 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR (0x4003314c)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_RESET_VAL 0x000f8000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR_RANGE_RESET_VAL 0x7c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_12_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_13 (0x40033150) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_13 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_13 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR (0x40033150)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_RESET_VAL 0x00108000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR_RANGE_RESET_VAL 0x84
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_13_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_14 (0x40033154) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_14 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_14 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR (0x40033154)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_RESET_VAL 0x00118000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR_RANGE_RESET_VAL 0x8c
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_14_ADDR_RANGE_DECL (21:13)

/*** HMD_MEM_RELOC_POOL_HG_RAM_15 (0x40033158) ***/
/*
 * This register is used by HMD to relocate POOL_HG_RAM_15 memory (64 KB)
 * within 4 MB address space through one of its interfaces.
 *
 The register field ADDR_RANGE is aligned so that SW can write 32-bit
 * memory address directly to this register and correct bits will be written
 * to this field. For example, if the 2 MB address range for the tile is
 * 0x20600000 - 0x207fffff, and if it is to be located within address range
 * 0x207f0000 - 0x207fffff, SW can write a value of 0x207f0000 to this
 * register and 0x1f8 will be written to field ADDR_RANGE.
 *
 0x207f0000 = 0010_0000_01 <11_1111_000> 0_0000_0000_0000
 *
 0x1f8 = 11_1111_000
 *
 Address range is obtained by substituting value for $val below, where $val
 * is the value written to the ADDR_RANGE field.
 *
 For DRAM0 interface, address range = (0x20000000 + ($val * 0x2000)) -
 * (0x20000000 + ($val * 0x2000) + 0xffff)
 * For IRAM interface, address range = (0x20400000 + ($val * 0x2000)) -
 * (0x20400000 + ($val * 0x2000) + 0xffff)
 *
 To reduce HW, read data busses from all dedicated memories and allocated
 * POOL (SM, LG, and HG) memories are OR-ed together. To access
 * POOL_HG_RAM_15 correctly, SW needs to program the ADDR_RANGE field of this
 * register to a value such that
 *   1) It is unique, compared to the address ranges of dedicated memories of
 * HMD and other POOL (SM, LG, and HG) memories allocated to it. Having
 * overlapping addresses for more than one memory can generate incorrect
 * data.
 *   2) It is not programmed to its highest value (0x1ff). Doing so will wrap
 * the other half of the memory to the top address.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR (0x40033158)
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_MASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_RMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_WMASK_VAL 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_RESET_VAL 0x00128000

/*
 * 0x0:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x1:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x2:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x3:
 *   For DRAM0 interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x4:
 *   For DRAM0 interface, relocate to address range 0x20008000 - 0x20017fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x5:
 *   For DRAM0 interface, relocate to address range 0x2000a000 - 0x20019fff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x6:
 *   For DRAM0 interface, relocate to address range 0x2000c000 - 0x2001bfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * 0x7:
 *   For DRAM0 interface, relocate to address range 0x2000e000 - 0x2001dfff.
 *   For IRAM interface, this value relocates to dedicated memory address
 * space. DO NOT USE.
 * ...
 * ...
 * ...
 * 0x1fe:
 *   For DRAM0 interface, relocate to address range 0x203fc000 - 0x2040bfff.
 *   For IRAM interface, relocate to address range 0x207fc000 - 0x2080bfff.
 * 0x1ff:
 *   For DRAM0 interface, relocate to address range 0x203fe000 - 0x2040dfff.
 *   For IRAM interface, relocate to address range 0x207fe000 - 0x2080dfff.
 */
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR_RANGE_MASK 0x003fe000
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR_RANGE_RESET_VAL 0x94
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR_RANGE_POS 13
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR_RANGE_SIZE 9
#define IAXXX_HMD_MEM_RELOC_POOL_HG_RAM_15_ADDR_RANGE_DECL (21:13)

/*** HMD_HMD_DRAM0_RAM_0_CLK_HW_CG (0x4003315c) ***/
/*
 * Hardware control enable for hmd_dram0_ram_0_clk_o. <br>This clock is
 * sourced from hmd_mem_lpx_clk_i.<br>DO NOT USE OVERRIDES unless suggested
 * by VLSI. <br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is gated if there are no
 * access to hmd_dram0_ram_0
 */
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_ADDR (0x4003315c)
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_HMD_DRAM0_RAM_0_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_HMD_IRAM0_RAM_0_CLK_HW_CG (0x40033160) ***/
/*
 * Hardware control enable for hmd_iram0_ram_0_clk_o. <br>This clock is
 * sourced from hmd_mem_lpx_clk_i.<br>DO NOT USE OVERRIDES unless suggested
 * by VLSI. <br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is gated if there are no
 * access to hmd_iram0_ram_0
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_ADDR (0x40033160)
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_HMD_IRAM0_RAM_0_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_HMD_IRAM0_RAM_1_CLK_HW_CG (0x40033164) ***/
/*
 * Hardware control enable for hmd_iram0_ram_1_clk_o. <br>This clock is
 * sourced from hmd_mem_lpx_clk_i.<br>DO NOT USE OVERRIDES unless suggested
 * by VLSI. <br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is gated if there are no
 * access to hmd_iram0_ram_1
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_ADDR (0x40033164)
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_HMD_IRAM0_RAM_1_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_PD4_APB_SYNC_LPX_CLK_HW_CG (0x40033168) ***/
/*
 * Hardware controlled enable for apb_sync_lpx_clk. Clock is sourced from
 * pd4_lpx_clk. <br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PD4 registers (PAC/MSW/CNR) or debug registers
 */
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_ADDR (0x40033168)
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_PD4_APB_SYNC_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_PD4_DBG_APB_LPX_CLK_HW_CG (0x4003316c) ***/
/*
 * Hardware Controlled enable for dbg_apb_lpx_clk. This clock is sourced from
 * pd4_lpx_clk. It is required to clear the OVERRIDE after successful
 * boot-up. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated when one of
 * these conditions is met: a) AHB masters access PD4 debug registers b)
 * Clock Stretch request
 */
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_ADDR (0x4003316c)
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000003

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x1
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_PD4_DBG_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_PD4_PAC_LPX_CLK_HW_CG (0x40033170) ***/
/*
 * Hardware controlled enable for pac_lpx_clk. This clock is sourced from
 * pd4_lpx_clk.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if there is
 * Inbound access to the processor
 */
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_ADDR (0x40033170)
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_PD4_PAC_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_PD4_REG_APB_LPX_CLK_HW_CG (0x40033174) ***/
/*
 * Hardware Controlled enable for reg_apb_lpx_clk. This clock is sourced from
 * pd4_lpx_clk. It may be required to set OVERRIDE for debug by
 * debugger.<br><br>When EN = 0, Clock will be cut regardless of Hardware
 * Control and HW_OVRD configuration<br>When EN = 1, Clock will be supplied
 * based on the Hardware Control condition<br><br>NOTE:<br>DO NOT SET HW_OVRD
 * = 1 or Modify EN Bit unless suggested by VLSI<br>For cases, where HW_OVRD
 * = 1 on Reset, SW is supposed to clear them after successful bootup
 * INTERNAL: <br><br>HW Control Condition:<br>Clock is ungated if AHB masters
 * access PD4 registers (MAC/PAC/MSW)
 */
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_ADDR (0x40033174)
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_MASK_VAL 0x00000003
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_RMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_WMASK_VAL 0x00000003
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_RESET_VAL 0x00000001

/*
 * Enable for clock gate
 */
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_EN_MASK 0x00000001
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_EN_RESET_VAL 0x1
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_EN_POS 0
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_EN_SIZE 1
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_EN_DECL 0

/*
 * Override HW CTRL
 */
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_HW_OVRD_MASK 0x00000002
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_HW_OVRD_RESET_VAL 0x0
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_HW_OVRD_POS 1
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_HW_OVRD_SIZE 1
#define IAXXX_HMD_PD4_REG_APB_LPX_CLK_HW_CG_HW_OVRD_DECL 1

/*** HMD_SPARE_GATES (0x40033178) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_HMD_SPARE_GATES_ADDR (0x40033178)
#define IAXXX_HMD_SPARE_GATES_MASK_VAL 0xffffffff
#define IAXXX_HMD_SPARE_GATES_RMASK_VAL 0xffffffff
#define IAXXX_HMD_SPARE_GATES_WMASK_VAL 0x0000ffff
#define IAXXX_HMD_SPARE_GATES_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_HMD_SPARE_GATES_FIELD_1_MASK 0x0000ffff
#define IAXXX_HMD_SPARE_GATES_FIELD_1_RESET_VAL 0x0
#define IAXXX_HMD_SPARE_GATES_FIELD_1_POS 0
#define IAXXX_HMD_SPARE_GATES_FIELD_1_SIZE 16
#define IAXXX_HMD_SPARE_GATES_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_HMD_SPARE_GATES_FIELD_2_MASK 0xffff0000
#define IAXXX_HMD_SPARE_GATES_FIELD_2_RESET_VAL 0x0
#define IAXXX_HMD_SPARE_GATES_FIELD_2_POS 16
#define IAXXX_HMD_SPARE_GATES_FIELD_2_SIZE 16
#define IAXXX_HMD_SPARE_GATES_FIELD_2_DECL (31:16)

/* Number of registers in the module */
#define IAXXX_HMD_REG_NUM 95

#endif /* __IAXXX_REGISTER_DEFS_HMD_H__*/
