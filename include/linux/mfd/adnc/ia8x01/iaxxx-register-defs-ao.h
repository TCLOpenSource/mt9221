/*
 * iaxxx-register-defs-ao.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/

#ifndef __IAXXX_REGISTER_DEFS_AO_H__
#define __IAXXX_REGISTER_DEFS_AO_H__

/*** The base address for this set of registers ***/
#define IAXXX_AO_REGS_ADDR (0x40000000)

/*** AO_DED_MEM_PWR_CTRL (0x40000000) ***/
/*
 * This register has bits to control power to the memory core of all
 * dedicated memories of all processors. It also has retention control for
 * them. There is only one bit to power down cores of all memories and one
 * bit to put them into retention, per power domain.
 * Power to the memory periphery is controlled by the sleep state of the
 * power domain in which the memory resides. The sleep state is controlled by
 * <a href="#D4080.AO.SW_PWR_CTRL_SET">AO.SW_PWR_CTRL_SET</a> and <a
 * href="#D4080.AO.SW_PWR_CTRL_CLR">AO.SW_PWR_CTRL_CLR</a> registers.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_ADDR (0x40000000)
#define IAXXX_AO_DED_MEM_PWR_CTRL_MASK_VAL 0x18181818
#define IAXXX_AO_DED_MEM_PWR_CTRL_RMASK_VAL 0x18181818
#define IAXXX_AO_DED_MEM_PWR_CTRL_WMASK_VAL 0x18181818
#define IAXXX_AO_DED_MEM_PWR_CTRL_RESET_VAL 0x18180000

/*
 * 0: Re-apply power to the memory core of all dedicated memories for HMD.
 * 1: Power down the core of all dedicated memories for HMD. All memory
 * contents will be lost.
 * This bit is used along with the HW sleep/wake up state machine.
 * NO_SLEEP = 1: If HMD_MEM_CORE_PWR_DN is 0 then core power is ON and will
 * remain ON. If HMD_MEM_CORE_PWR_DN is 1 then core power is OFF and will
 * remain OFF.
 * NO_SLEEP = 0: If HMD_MEM_CORE_PWR_DN is 0 then core power will remain ON
 * during sleep and wake up. If HMD_MEM_CORE_PWR_DN is 1 then core will be
 * powered OFF during sleep and powered ON after wake up by HW.
 * NOTE: Leave this field at reset value if HMD power domain is software
 * controlled. Core power should be controlled by HMD_MEM_CORE_PWR_DN_OVRRD
 * field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_MASK 0x00000008
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_RESET_VAL 0x0
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_POS 3
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_DECL 3

/*
 * 0: Re-apply power to the memory core of all dedicated memories for DMX.
 * 1: Power down the core of all dedicated memories for DMX. All memory
 * contents will be lost.
 * This bit is used along with the HW sleep/wake up state machine.
 * NO_SLEEP = 1: If DMX_MEM_CORE_PWR_DN is 0 then core power is ON and will
 * remain ON. If DMX_MEM_CORE_PWR_DN is 1 then core power is OFF and will
 * remain OFF.
 * NO_SLEEP = 0: If DMX_MEM_CORE_PWR_DN is 0 then core power will remain ON
 * during sleep and wake up. If DMX_MEM_CORE_PWR_DN is 1 then core will be
 * powered OFF during sleep and powered ON after wake up by HW.
 * NOTE: Leave this field at reset value if DMX power domain is software
 * controlled. Core power should be controlled by DMX_MEM_CORE_PWR_DN_OVRRD
 * field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_MASK 0x00000010
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_RESET_VAL 0x0
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_POS 4
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_DECL 4

/*
 * This OVRRD should be used if a processor power domain is software
 * controlled.
 * 0: Core power is controlled by HMD_MEM_CORE_PWR_DN field.
 * 1: Core power is turned OFF.
 * NOTE: Leave this field at reset value if HMD power domain is hardware
 * controlled. In this case core power should be controlled by
 * HMD_MEM_CORE_PWR_DN field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_OVRRD_MASK 0x00000800
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_OVRRD_RESET_VAL 0x0
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_OVRRD_POS 11
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_OVRRD_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_MEM_CORE_PWR_DN_OVRRD_DECL 11

/*
 * This OVRRD should be used if a processor power domain is software
 * controlled.
 * 0: Core power is controlled by DMX_MEM_CORE_PWR_DN field.
 * 1: Core power is turned OFF.
 * NOTE: Leave this field at reset value if DMX power domain is hardware
 * controlled. In this case core power should be controlled by
 * DMX_MEM_CORE_PWR_DN field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_OVRRD_MASK 0x00001000
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_OVRRD_RESET_VAL 0x0
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_OVRRD_POS 12
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_OVRRD_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_MEM_CORE_PWR_DN_OVRRD_DECL 12

/*
 * 0: Put all dedicated memories for HMD into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take all dedicated memories for HMD out of retention.
 * NO_SLEEP = 1: If HMD_RET_N is 0 then memory is in retention if core power
 * is ON. If HMD_RET_N is 1 then memory is not in retention and contents will
 * be lost.
 * NO_SLEEP = 0: Hardware will assert retention during sleep and remove
 * retention after wake up.
 * Note: Leave this field at reset value if HMD power domain is software
 * controlled. In this case retention could be set by setting HMD_RET_N_OVRRD
 * field to 0.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_MASK 0x00080000
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_RESET_VAL 0x1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_POS 19
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_DECL 19

/*
 * 0: Put all dedicated memories for DMX into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take all dedicated memories for DMX out of retention.
 * NO_SLEEP = 1: If DMX_RET_N is 0 then memory is in retention if core power
 * is ON. If DMX_RET_N is 1 then memory is not in retention and contents will
 * be lost.
 * NO_SLEEP = 0: Hardware will assert retention during sleep and remove
 * retention after wake up.
 * Note: Leave this field at reset value if DMX power domain is software
 * controlled. In this case retention could be set by setting DMX_RET_N_OVRRD
 * field to 0.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_MASK 0x00100000
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_RESET_VAL 0x1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_POS 20
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_DECL 20

/*
 * This OVRRD should be used if a processor power domain is software
 * controlled.
 * 0: Memory is in retention provided MEM_CORE_PWR is left ON. Contents will
 * be retained.
 * 1: Memory is not in retention contents will be lost.
 * Note: Leave this field at reset value if HMD power domain is hardware
 * controlled. If this bit is at 1 then retention is still controlled by
 * HMD_RET_N field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_OVRRD_MASK 0x08000000
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_OVRRD_RESET_VAL 0x1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_OVRRD_POS 27
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_OVRRD_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_HMD_RET_N_OVRRD_DECL 27

/*
 * This OVRRD should be used if a processor power domain is software
 * controlled.
 * 0: Memory is in retention provided MEM_CORE_PWR is left ON. Contents will
 * be retained.
 * 1: Memory is not in retention contents will be lost.
 * Note: Leave this field at reset value if DMX power domain is hardware
 * controlled. If this bit is at 1 then retention is still controlled by
 * DMX_RET_N field.
 */
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_OVRRD_MASK 0x10000000
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_OVRRD_RESET_VAL 0x1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_OVRRD_POS 28
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_OVRRD_SIZE 1
#define IAXXX_AO_DED_MEM_PWR_CTRL_DMX_RET_N_OVRRD_DECL 28

/*** AO_HW_MEM_PWR_CTRL (0x40000004) ***/
/*
 * Power Control for Memories using HW in active mode.
 * There are two levels of granularity in deciding whether a tile is in use
 * or not.
 * i) Coarse level(_WAITI_RET bits)- If a processor for which tile is
 * allocated is in WAITI and no inbound traffic, then that tile is considered
 * to be not in use and will be kept in retention.
 * ii) Fine grain control(_DYN_RET bits)- More than one tile may be allocated
 * to a given procrssor interface but processor may be accessing only one
 * tile at a time and based on spacial locality, there are high chances that
 * processor continues to access the same tile before accessing next tile.
 * So there may be only one tile in use for longer duration. HW detects this
 * condition and keeps the current tile being accessed out of retention and
 * remaining tiles allocated to that interface into retention.
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_ADDR (0x40000004)
#define IAXXX_AO_HW_MEM_PWR_CTRL_MASK_VAL 0x003fc000
#define IAXXX_AO_HW_MEM_PWR_CTRL_RMASK_VAL 0x003fc000
#define IAXXX_AO_HW_MEM_PWR_CTRL_WMASK_VAL 0x003fc000
#define IAXXX_AO_HW_MEM_PWR_CTRL_RESET_VAL 0x003fc000

/*
 * 0: Enable HW control of all memories that are attached to HMD IRAM (both
 * dedicated and pool memories) when processor is in WAITI.
 * When processor is in WIATI and there is no inboud traffic, all memories
 * are that are attached to HMD IRAM go into retention.
 * 1: Disable HW gating of memories that are attached to HMD IRAM when
 * processor is in WAITI
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_WAITI_RET_MASK 0x00004000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_WAITI_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_WAITI_RET_POS 14
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_WAITI_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_WAITI_RET_DECL 14

/*
 * 0: Enable HW control of memories that are attached to HMD IRAM (both
 * dedicated and pool memories)
 * Only current tile that is accessed by HMD IRAM is active while all other
 * tiles attached to HMD IRAM are into retention.
 * It is advisable to disable this feature when inbound traffic is expected
 * on $intf.
 * This is because inbound traffic may be to one tile and processor may be
 * accessing another tile.
 * In this case, tiles switching happen frequently and so frequent tile
 * switching power may be higher than what is saved in retention power.
 * But if processor goes to WAITI and there is inbound access, then this HW
 * gating is advisable to be enabled for power saving
 * 1: Disable HW gating of memories that are attached to HMD IRAM
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_DYN_RET_MASK 0x00008000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_DYN_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_DYN_RET_POS 15
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_DYN_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_IRAM_DYN_RET_DECL 15

/*
 * 0: Enable HW control of all memories that are attached to HMD DRAM0 (both
 * dedicated and pool memories) when processor is in WAITI.
 * When processor is in WIATI and there is no inboud traffic, all memories
 * are that are attached to HMD DRAM0 go into retention.
 * 1: Disable HW gating of memories that are attached to HMD DRAM0 when
 * processor is in WAITI
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_WAITI_RET_MASK 0x00010000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_WAITI_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_WAITI_RET_POS 16
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_WAITI_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_WAITI_RET_DECL 16

/*
 * 0: Enable HW control of memories that are attached to HMD DRAM0 (both
 * dedicated and pool memories)
 * Only current tile that is accessed by HMD DRAM0 is active while all other
 * tiles attached to HMD DRAM0 are into retention.
 * It is advisable to disable this feature when inbound traffic is expected
 * on $intf.
 * This is because inbound traffic may be to one tile and processor may be
 * accessing another tile.
 * In this case, tiles switching happen frequently and so frequent tile
 * switching power may be higher than what is saved in retention power.
 * But if processor goes to WAITI and there is inbound access, then this HW
 * gating is advisable to be enabled for power saving
 * 1: Disable HW gating of memories that are attached to HMD DRAM0
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_DYN_RET_MASK 0x00020000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_DYN_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_DYN_RET_POS 17
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_DYN_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_HMD_DRAM0_DYN_RET_DECL 17

/*
 * 0: Enable HW control of all memories that are attached to DMX IRAM (both
 * dedicated and pool memories) when processor is in WAITI.
 * When processor is in WIATI and there is no inboud traffic, all memories
 * are that are attached to DMX IRAM go into retention.
 * 1: Disable HW gating of memories that are attached to DMX IRAM when
 * processor is in WAITI
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_WAITI_RET_MASK 0x00040000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_WAITI_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_WAITI_RET_POS 18
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_WAITI_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_WAITI_RET_DECL 18

/*
 * 0: Enable HW control of memories that are attached to DMX IRAM (both
 * dedicated and pool memories)
 * Only current tile that is accessed by DMX IRAM is active while all other
 * tiles attached to DMX IRAM are into retention.
 * It is advisable to disable this feature when inbound traffic is expected
 * on $intf.
 * This is because inbound traffic may be to one tile and processor may be
 * accessing another tile.
 * In this case, tiles switching happen frequently and so frequent tile
 * switching power may be higher than what is saved in retention power.
 * But if processor goes to WAITI and there is inbound access, then this HW
 * gating is advisable to be enabled for power saving
 * 1: Disable HW gating of memories that are attached to DMX IRAM
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_DYN_RET_MASK 0x00080000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_DYN_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_DYN_RET_POS 19
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_DYN_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_IRAM_DYN_RET_DECL 19

/*
 * 0: Enable HW control of all memories that are attached to DMX DRAM0 (both
 * dedicated and pool memories) when processor is in WAITI.
 * When processor is in WIATI and there is no inboud traffic, all memories
 * are that are attached to DMX DRAM0 go into retention.
 * 1: Disable HW gating of memories that are attached to DMX DRAM0 when
 * processor is in WAITI
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_WAITI_RET_MASK 0x00100000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_WAITI_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_WAITI_RET_POS 20
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_WAITI_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_WAITI_RET_DECL 20

/*
 * 0: Enable HW control of memories that are attached to DMX DRAM0 (both
 * dedicated and pool memories)
 * Only current tile that is accessed by DMX DRAM0 is active while all other
 * tiles attached to DMX DRAM0 are into retention.
 * It is advisable to disable this feature when inbound traffic is expected
 * on $intf.
 * This is because inbound traffic may be to one tile and processor may be
 * accessing another tile.
 * In this case, tiles switching happen frequently and so frequent tile
 * switching power may be higher than what is saved in retention power.
 * But if processor goes to WAITI and there is inbound access, then this HW
 * gating is advisable to be enabled for power saving
 * 1: Disable HW gating of memories that are attached to DMX DRAM0
 */
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_DYN_RET_MASK 0x00200000
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_DYN_RET_RESET_VAL 0x1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_DYN_RET_POS 21
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_DYN_RET_SIZE 1
#define IAXXX_AO_HW_MEM_PWR_CTRL_DISABLE_DMX_DRAM0_DYN_RET_DECL 21

/*** AO_POOL_SM_TN_RAM_PWR_CTRL (0x40000008) ***/
/*
 * This register has bits to control power to all small and tiny pool RAMs
 * individually. It also has retention control for them.
 * Power to the memory periphery is controlled by the sleep state of power
 * domain 8 (PD8), where the memory resides. The sleep state is controlled by
 * <a href="#D4080.AO.SW_PWR_CTRL_SET">AO.SW_PWR_CTRL_SET</a> and <a
 * href="#D4080.AO.SW_PWR_CTRL_CLR">AO.SW_PWR_CTRL_CLR</a> registers.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_ADDR (0x40000008)
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MASK_VAL 0x00ff0001
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_RMASK_VAL 0x00ff0001
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_WMASK_VAL 0x00ff0001
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_RESET_VAL 0x00ff0001

/*
 * 0: Re-apply power to the memory core of all small and tiny pool RAM.
 * 1: Power down the core of all small and tiny pool RAM. All memory contents
 * will be lost.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MEM_CORE_PWR_DN_MASK 0x00000001
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MEM_CORE_PWR_DN_POS 0
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_MEM_CORE_PWR_DN_DECL 0

/*
 * 0: Put tiny pool RAM POOL_TN_RAM_0 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take tiny pool RAM POOL_TN_RAM_0 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_0_RET_N_MASK 0x00010000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_0_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_0_RET_N_POS 16
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_0_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_0_RET_N_DECL 16

/*
 * 0: Put tiny pool RAM POOL_TN_RAM_1 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take tiny pool RAM POOL_TN_RAM_1 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_1_RET_N_MASK 0x00020000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_1_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_1_RET_N_POS 17
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_1_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_1_RET_N_DECL 17

/*
 * 0: Put tiny pool RAM POOL_TN_RAM_2 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take tiny pool RAM POOL_TN_RAM_2 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_2_RET_N_MASK 0x00040000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_2_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_2_RET_N_POS 18
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_2_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_2_RET_N_DECL 18

/*
 * 0: Put tiny pool RAM POOL_TN_RAM_3 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take tiny pool RAM POOL_TN_RAM_3 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_3_RET_N_MASK 0x00080000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_3_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_3_RET_N_POS 19
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_3_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_3_RET_N_DECL 19

/*
 * 0: Put small pool RAM POOL_SM_RAM_4 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take small pool RAM POOL_SM_RAM_4 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_4_RET_N_MASK 0x00100000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_4_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_4_RET_N_POS 20
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_4_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_4_RET_N_DECL 20

/*
 * 0: Put small pool RAM POOL_SM_RAM_5 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take small pool RAM POOL_SM_RAM_5 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_5_RET_N_MASK 0x00200000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_5_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_5_RET_N_POS 21
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_5_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_5_RET_N_DECL 21

/*
 * 0: Put small pool RAM POOL_SM_RAM_6 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take small pool RAM POOL_SM_RAM_6 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_6_RET_N_MASK 0x00400000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_6_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_6_RET_N_POS 22
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_6_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_6_RET_N_DECL 22

/*
 * 0: Put small pool RAM POOL_SM_RAM_7 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take small pool RAM POOL_SM_RAM_7 out of retention.
 */
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_7_RET_N_MASK 0x00800000
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_7_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_7_RET_N_POS 23
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_7_RET_N_SIZE 1
#define IAXXX_AO_POOL_SM_TN_RAM_PWR_CTRL_7_RET_N_DECL 23

/*** AO_POOL_LG_RAM_PWR_CTRL (0x4000000c) ***/
/*
 * This register has bits to control power to all large pool RAMs
 * individually. It also has retention control for them.
 * Power to the memory periphery is controlled by the sleep state of power
 * domain 8 (PD8), where the memory resides. The sleep state is controlled by
 * <a href="#D4080.AO.SW_PWR_CTRL_SET">AO.SW_PWR_CTRL_SET</a> and <a
 * href="#D4080.AO.SW_PWR_CTRL_CLR">AO.SW_PWR_CTRL_CLR</a> registers.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_ADDR (0x4000000c)
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MASK_VAL 0x000f0001
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_RMASK_VAL 0x000f0001
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_WMASK_VAL 0x000f0001
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_RESET_VAL 0x000f0001

/*
 * 0: Re-apply power to the memory core of all 4 large pool RAM POOL_LG_RAM.
 * 1: Power down the core of all 4 large pool RAM POOL_LG_RAM. All memory
 * contents will be lost.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MEM_CORE_PWR_DN_MASK 0x00000001
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MEM_CORE_PWR_DN_POS 0
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_MEM_CORE_PWR_DN_DECL 0

/*
 * 0: Put large pool RAM POOL_LG_RAM_0 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take large pool RAM POOL_LG_RAM_0 out of retention.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_0_RET_N_MASK 0x00010000
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_0_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_0_RET_N_POS 16
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_0_RET_N_SIZE 1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_0_RET_N_DECL 16

/*
 * 0: Put large pool RAM POOL_LG_RAM_1 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take large pool RAM POOL_LG_RAM_1 out of retention.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_1_RET_N_MASK 0x00020000
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_1_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_1_RET_N_POS 17
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_1_RET_N_SIZE 1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_1_RET_N_DECL 17

/*
 * 0: Put large pool RAM POOL_LG_RAM_2 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take large pool RAM POOL_LG_RAM_2 out of retention.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_2_RET_N_MASK 0x00040000
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_2_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_2_RET_N_POS 18
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_2_RET_N_SIZE 1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_2_RET_N_DECL 18

/*
 * 0: Put large pool RAM POOL_LG_RAM_3 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take large pool RAM POOL_LG_RAM_3 out of retention.
 */
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_3_RET_N_MASK 0x00080000
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_3_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_3_RET_N_POS 19
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_3_RET_N_SIZE 1
#define IAXXX_AO_POOL_LG_RAM_PWR_CTRL_3_RET_N_DECL 19

/*** AO_POOL_HG_RAM_PWR_CTRL (0x40000010) ***/
/*
 * This register has bits to control power to all huge pool RAMs
 * individually. It also has retention control for them.
 * Power to the memory periphery is controlled by the sleep state of power
 * domain 8 (PD8), where the memory resides. The sleep state is controlled by
 * <a href="#D4080.AO.SW_PWR_CTRL_SET">AO.SW_PWR_CTRL_SET</a> and <a
 * href="#D4080.AO.SW_PWR_CTRL_CLR">AO.SW_PWR_CTRL_CLR</a> registers.
 * NOTE: IF PD3/PD4 are put to sleep, we will ignore the cm4/hmd/dmx related
 * register bits and the sctrl sequencer will handle them in hardware.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_ADDR (0x40000010)
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_MASK_VAL 0xffff000f
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_RMASK_VAL 0xffff000f
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_WMASK_VAL 0xffff000f
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_RESET_VAL 0xffff000f

/*
 * 0: Re-apply power to the memory core of huge pool RAM POOL_HG_RAM_((3:0)).
 * 1: Power down the core of huge pool RAM POOL_HG_RAM_((3:0)). All memory
 * contents will be lost.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_MEM_CORE_PWR_DN_MASK 0x00000001
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_MEM_CORE_PWR_DN_POS 0
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_MEM_CORE_PWR_DN_DECL 0

/*
 * 0: Re-apply power to the memory core of huge pool RAM POOL_HG_RAM_((7:4)).
 * 1: Power down the core of huge pool RAM POOL_HG_RAM_((7:4)). All memory
 * contents will be lost.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_MEM_CORE_PWR_DN_MASK 0x00000002
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_MEM_CORE_PWR_DN_POS 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_MEM_CORE_PWR_DN_DECL 1

/*
 * 0: Re-apply power to the memory core of huge pool RAM POOL_HG_RAM_((11:8)).
 * 1: Power down the core of huge pool RAM POOL_HG_RAM_((11:8)). All memory
 * contents will be lost.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_MEM_CORE_PWR_DN_MASK 0x00000004
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_MEM_CORE_PWR_DN_POS 2
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_MEM_CORE_PWR_DN_DECL 2

/*
 * 0: Re-apply power to the memory core of huge pool RAM POOL_HG_RAM_((15:12)).
 * 1: Power down the core of huge pool RAM POOL_HG_RAM_((15:12)). All memory
 * contents will be lost.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_MEM_CORE_PWR_DN_MASK 0x00000008
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_MEM_CORE_PWR_DN_POS 3
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_MEM_CORE_PWR_DN_DECL 3

/*
 * 0: Put huge pool RAM POOL_HG_RAM_0 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_0 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_RET_N_MASK 0x00010000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_RET_N_POS 16
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_0_RET_N_DECL 16

/*
 * 0: Put huge pool RAM POOL_HG_RAM_1 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_1 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_RET_N_MASK 0x00020000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_RET_N_POS 17
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_1_RET_N_DECL 17

/*
 * 0: Put huge pool RAM POOL_HG_RAM_2 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_2 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_RET_N_MASK 0x00040000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_RET_N_POS 18
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_2_RET_N_DECL 18

/*
 * 0: Put huge pool RAM POOL_HG_RAM_3 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_3 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_RET_N_MASK 0x00080000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_RET_N_POS 19
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_3_RET_N_DECL 19

/*
 * 0: Put huge pool RAM POOL_HG_RAM_4 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_4 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_4_RET_N_MASK 0x00100000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_4_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_4_RET_N_POS 20
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_4_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_4_RET_N_DECL 20

/*
 * 0: Put huge pool RAM POOL_HG_RAM_5 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_5 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_5_RET_N_MASK 0x00200000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_5_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_5_RET_N_POS 21
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_5_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_5_RET_N_DECL 21

/*
 * 0: Put huge pool RAM POOL_HG_RAM_6 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_6 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_6_RET_N_MASK 0x00400000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_6_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_6_RET_N_POS 22
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_6_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_6_RET_N_DECL 22

/*
 * 0: Put huge pool RAM POOL_HG_RAM_7 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_7 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_7_RET_N_MASK 0x00800000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_7_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_7_RET_N_POS 23
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_7_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_7_RET_N_DECL 23

/*
 * 0: Put huge pool RAM POOL_HG_RAM_8 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_8 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_8_RET_N_MASK 0x01000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_8_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_8_RET_N_POS 24
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_8_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_8_RET_N_DECL 24

/*
 * 0: Put huge pool RAM POOL_HG_RAM_9 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_9 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_9_RET_N_MASK 0x02000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_9_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_9_RET_N_POS 25
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_9_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_9_RET_N_DECL 25

/*
 * 0: Put huge pool RAM POOL_HG_RAM_10 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_10 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_10_RET_N_MASK 0x04000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_10_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_10_RET_N_POS 26
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_10_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_10_RET_N_DECL 26

/*
 * 0: Put huge pool RAM POOL_HG_RAM_11 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_11 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_11_RET_N_MASK 0x08000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_11_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_11_RET_N_POS 27
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_11_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_11_RET_N_DECL 27

/*
 * 0: Put huge pool RAM POOL_HG_RAM_12 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_12 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_12_RET_N_MASK 0x10000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_12_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_12_RET_N_POS 28
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_12_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_12_RET_N_DECL 28

/*
 * 0: Put huge pool RAM POOL_HG_RAM_13 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_13 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_13_RET_N_MASK 0x20000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_13_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_13_RET_N_POS 29
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_13_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_13_RET_N_DECL 29

/*
 * 0: Put huge pool RAM POOL_HG_RAM_14 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_14 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_14_RET_N_MASK 0x40000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_14_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_14_RET_N_POS 30
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_14_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_14_RET_N_DECL 30

/*
 * 0: Put huge pool RAM POOL_HG_RAM_15 into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take huge pool RAM POOL_HG_RAM_15 out of retention.
 */
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_15_RET_N_MASK 0x80000000
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_15_RET_N_RESET_VAL 0x1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_15_RET_N_POS 31
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_15_RET_N_SIZE 1
#define IAXXX_AO_POOL_HG_RAM_PWR_CTRL_15_RET_N_DECL 31

/*** AO_GLBL_MEM_PWR_CTRL (0x40000014) ***/
/*
 * This register has bits to control power to all global memories
 * individually. It also has retention control for them.
 * Power to the memory periphery is controlled by the sleep state of power
 * domain 8 (PD8), where the memory resides. The sleep state is controlled by
 * <a href="#D4080.AO.SW_PWR_CTRL_SET">AO.SW_PWR_CTRL_SET</a> and <a
 * href="#D4080.AO.SW_PWR_CTRL_CLR">AO.SW_PWR_CTRL_CLR</a> registers.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_ADDR (0x40000014)
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_MASK_VAL 0x00070003
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_RMASK_VAL 0x00070003
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_WMASK_VAL 0x00070003
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_RESET_VAL 0x00070002

/*
 * 0: Re-apply power to the memory core of global trace RAM GLBL_ETB_RAM.
 * 1: Power down the core of global trace RAM GLBL_ETB_RAM. All memory
 * contents will be lost.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_MEM_CORE_PWR_DN_MASK 0x00000001
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_MEM_CORE_PWR_DN_RESET_VAL 0x0
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_MEM_CORE_PWR_DN_POS 0
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_MEM_CORE_PWR_DN_DECL 0

/*
 * 0: Re-apply power to the memory core of all 2 global RAM GLBL_MEM_RAM.
 * 1: Power down the core of all 2 global RAM GLBL_MEM_RAM. All memory
 * contents will be lost.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_MEM_CORE_PWR_DN_MASK 0x00000002
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_MEM_CORE_PWR_DN_RESET_VAL 0x1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_MEM_CORE_PWR_DN_POS 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_MEM_CORE_PWR_DN_SIZE 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_MEM_CORE_PWR_DN_DECL 1

/*
 * 0: Put global trace RAM GLBL_ETB_RAM into retention. It is a low power
 * state in which memory contents are preserved.
 * 1: Take global trace RAM GLBL_ETB_RAM out of retention.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_RET_N_MASK 0x00010000
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_RET_N_RESET_VAL 0x1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_RET_N_POS 16
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_RET_N_SIZE 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_ETB_RAM_0_RET_N_DECL 16

/*
 * 0: Put global RAM GLBL_MEM_RAM_0 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take global RAM GLBL_MEM_RAM_0 out of retention.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_0_RET_N_MASK 0x00020000
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_0_RET_N_RESET_VAL 0x1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_0_RET_N_POS 17
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_0_RET_N_SIZE 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_0_RET_N_DECL 17

/*
 * 0: Put global RAM GLBL_MEM_RAM_1 into retention. It is a low power state
 * in which memory contents are preserved.
 * 1: Take global RAM GLBL_MEM_RAM_1 out of retention.
 */
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_1_RET_N_MASK 0x00040000
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_1_RET_N_RESET_VAL 0x1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_1_RET_N_POS 18
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_1_RET_N_SIZE 1
#define IAXXX_AO_GLBL_MEM_PWR_CTRL_GLBL_MEM_RAM_1_RET_N_DECL 18

/*** AO_MEM_ELEC_CTRL (0x40000018) ***/
/*
 * This register is used to configure internal read and write margins for
 * memories. There is one control for all ROMs and one control for all RAMs
 * on the chip.
 * It is also used to adjust source bias voltage for memories when in
 * retention mode, which controls retention voltage and leakage.
 */
#define IAXXX_AO_MEM_ELEC_CTRL_ADDR (0x40000018)
#define IAXXX_AO_MEM_ELEC_CTRL_MASK_VAL 0x000001ff
#define IAXXX_AO_MEM_ELEC_CTRL_RMASK_VAL 0x000001ff
#define IAXXX_AO_MEM_ELEC_CTRL_WMASK_VAL 0x000001ff
#define IAXXX_AO_MEM_ELEC_CTRL_RESET_VAL 0x00000112

/*
 * This field is used to select read and write margins for all ROMs on the
 * chip.
 * <pre>
 *        +--------------------+-------+-------+
 *        | Recommended Margin |       |       |
 *        |      Settings      | RM[1] | RM[0] |
 *        +--------------------+-------+-------+
 *        |    VDD > 0.90 V    |   1   |   0   |
 *        |   VDD <= 0.90 V    |   0   |   1   |
 *        +--------------------+-------+-------+
 *
   +-------+-------+------------------------------+
 *   | RM[1] | RM[0] | Internal Read Timing Margins |
 *   +-------+-------+------------------------------+
 *   |   0   |   0   |         Slowest Read         |
 *   |   0   |   1   |           Slow Read          |
 *   |   1   |   0   |          Normal Read         |
 *   |   1   |   1   |           Fast Read          |
 *   +-------+-------+------------------------------+
 * </pre>
 */
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_ROM_MASK 0x00000003
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_ROM_RESET_VAL 0x2
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_ROM_POS 0
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_ROM_SIZE 2
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_ROM_DECL (1:0)

/*
 * This field is used to select read and write margins for all SRAMs on the
 * chip.
 * <pre>
 *         +--------------------+-----+----+----+
 *         | Recommended Margin |     |    |    |
 *         |      Settings      | RWM | RM | WM |
 *         +--------------------+-----+----+----+
 *         |    VDD > 0.90 V    |  1  | 0  | 0  |
 *         |   VDD <= 0.90 V    |  0  | 1  | 1  |
 *         +--------------------+-----+----+----+
 *
   +-----+-----+-----+------------------------------+
 *   | RWM | RM  | WM  | Internal Read Timing Margins |
 *   +-----+-----+-----+------------------------------+
 *   |  0  |  0  |  0  | Slowest Read, Slowest Write  |
 *   |  0  |  0  |  1  |   Slowest Read, Slow Write   |
 *   |  0  |  1  |  0  |   Slow Read, Slowest Write   |
 *   |  0  |  1  |  1  |    Slow Read, Slow Write     |
 *   |  1  |  0  |  0  |  Normal Read, Normal Write   |
 *   |  1  |  0  |  1  |   Normal Read, Fast Write    |
 *   |  1  |  1  |  0  |   Fast Read, Normal Write    |
 *   |  1  |  1  |  1  |    Fast Read, Fast Write     |
 *   +-----+-----+-----+------------------------------+
 * </pre>
 */
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_RAM_MASK 0x0000001c
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_RAM_RESET_VAL 0x4
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_RAM_POS 2
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_RAM_SIZE 3
#define IAXXX_AO_MEM_ELEC_CTRL_RD_WR_MARGIN_ADJ_RAM_DECL (4:2)

/*
 * This field is used to select retention voltage and leakage values for all
 * PD8 memories. Memories in all other PDs are programmed to a fixed value
 * (4'b1111). The following table gives a comparison of retention voltage and
 * leakage for different values of BTRIM.
 * <pre>
 *           +-------+-------------+---------+
 *           |       |  Retention  |         |
 *           | Value | Voltage (V) | Leakage |
 *           +-------+-------------+---------+
 *           | 0000  |    0.756    |  Least  |
 *           |  ...  |     ...     |   ...   |
 *           | 1111  |    0.556    |   Most  |
 *           +-------+-------------+---------+
 * </pre>
 */
#define IAXXX_AO_MEM_ELEC_CTRL_PD8_BTRIM_MASK 0x000001e0
#define IAXXX_AO_MEM_ELEC_CTRL_PD8_BTRIM_RESET_VAL 0x8
#define IAXXX_AO_MEM_ELEC_CTRL_PD8_BTRIM_POS 5
#define IAXXX_AO_MEM_ELEC_CTRL_PD8_BTRIM_SIZE 4
#define IAXXX_AO_MEM_ELEC_CTRL_PD8_BTRIM_DECL (8:5)

/*** AO_MPLL_CTRL (0x4000001c) ***/
/*
 */
#define IAXXX_AO_MPLL_CTRL_ADDR (0x4000001c)
#define IAXXX_AO_MPLL_CTRL_MASK_VAL 0x0fffffff
#define IAXXX_AO_MPLL_CTRL_RMASK_VAL 0x0fffffff
#define IAXXX_AO_MPLL_CTRL_WMASK_VAL 0x07ffffff
#define IAXXX_AO_MPLL_CTRL_RESET_VAL 0x00000050

/*
 * Reference divide value (1 to 16)
 */
#define IAXXX_AO_MPLL_CTRL_REFDIV_MASK 0x0000000f
#define IAXXX_AO_MPLL_CTRL_REFDIV_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_REFDIV_POS 0
#define IAXXX_AO_MPLL_CTRL_REFDIV_SIZE 4
#define IAXXX_AO_MPLL_CTRL_REFDIV_DECL (3:0)

/*
 * PLL Feedback divider (Valid values 4 to 781)
 */
#define IAXXX_AO_MPLL_CTRL_FBDIV_MASK 0x00003ff0
#define IAXXX_AO_MPLL_CTRL_FBDIV_RESET_VAL 0x5
#define IAXXX_AO_MPLL_CTRL_FBDIV_POS 4
#define IAXXX_AO_MPLL_CTRL_FBDIV_SIZE 10
#define IAXXX_AO_MPLL_CTRL_FBDIV_DECL (13:4)

/*
 * PLL post divide 1 setting (1 to 16). Total post divide is
 * POSTDIV1*POSTDIV2. Actual divide value is POSTDIV1+1. Example: divide-by-1
 * = 4'b0000, divide-by-16 = 4'b1111
 */
#define IAXXX_AO_MPLL_CTRL_POSTDIV1_MASK 0x0003c000
#define IAXXX_AO_MPLL_CTRL_POSTDIV1_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_POSTDIV1_POS 14
#define IAXXX_AO_MPLL_CTRL_POSTDIV1_SIZE 4
#define IAXXX_AO_MPLL_CTRL_POSTDIV1_DECL (17:14)

/*
 * PLL post divide 2 setting (1 to 16). Total post divide is
 * POSTDIV1*POSTDIV2. Actual divide value is POSTDIV2+1. Example: divide-by-1
 * = 4'b0000, divide-by-16 = 4'b1111
 */
#define IAXXX_AO_MPLL_CTRL_POSTDIV2_MASK 0x003c0000
#define IAXXX_AO_MPLL_CTRL_POSTDIV2_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_POSTDIV2_POS 18
#define IAXXX_AO_MPLL_CTRL_POSTDIV2_SIZE 4
#define IAXXX_AO_MPLL_CTRL_POSTDIV2_DECL (21:18)

/*
 * Power down for PLL. Active high. If this bit is 0 then PLL power down is
 * sequenced by SCTRL. If this bit is 1 then PLL is powered down and SCTRL
 * output is ignored.
 */
#define IAXXX_AO_MPLL_CTRL_PD_MASK 0x00400000
#define IAXXX_AO_MPLL_CTRL_PD_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_PD_POS 22
#define IAXXX_AO_MPLL_CTRL_PD_SIZE 1
#define IAXXX_AO_MPLL_CTRL_PD_DECL 22

/*
 * Post divide power down. Active high.
 */
#define IAXXX_AO_MPLL_CTRL_FOUTPD_MASK 0x00800000
#define IAXXX_AO_MPLL_CTRL_FOUTPD_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_FOUTPD_POS 23
#define IAXXX_AO_MPLL_CTRL_FOUTPD_SIZE 1
#define IAXXX_AO_MPLL_CTRL_FOUTPD_DECL 23

/*
 * VCO rate output clock power down. Active high.
 */
#define IAXXX_AO_MPLL_CTRL_FOUTVCOPD_MASK 0x01000000
#define IAXXX_AO_MPLL_CTRL_FOUTVCOPD_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_FOUTVCOPD_POS 24
#define IAXXX_AO_MPLL_CTRL_FOUTVCOPD_SIZE 1
#define IAXXX_AO_MPLL_CTRL_FOUTVCOPD_DECL 24

/*
 * VCO Range selection and selection of predivider RANGE.
 * VCO range: 0 => 28MHz to 140MHz
 *            1 => 120MHz to 600MHz
 */
#define IAXXX_AO_MPLL_CTRL_RANGE_MASK 0x02000000
#define IAXXX_AO_MPLL_CTRL_RANGE_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_RANGE_POS 25
#define IAXXX_AO_MPLL_CTRL_RANGE_SIZE 1
#define IAXXX_AO_MPLL_CTRL_RANGE_DECL 25

/*
 * FREF is bypassed to FOUT.
 */
#define IAXXX_AO_MPLL_CTRL_BYPASS_MASK 0x04000000
#define IAXXX_AO_MPLL_CTRL_BYPASS_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_BYPASS_POS 26
#define IAXXX_AO_MPLL_CTRL_BYPASS_SIZE 1
#define IAXXX_AO_MPLL_CTRL_BYPASS_DECL 26

/*
 * Lock signal. Indicates no cycle slips between the feedback clock and FPFD
 * for 256 consectutive cycles.
 */
#define IAXXX_AO_MPLL_CTRL_LOCK_MASK 0x08000000
#define IAXXX_AO_MPLL_CTRL_LOCK_RESET_VAL 0x0
#define IAXXX_AO_MPLL_CTRL_LOCK_POS 27
#define IAXXX_AO_MPLL_CTRL_LOCK_SIZE 1
#define IAXXX_AO_MPLL_CTRL_LOCK_DECL 27

/*** AO_MPLL_PLLC (0x40000020) ***/
/*
 */
#define IAXXX_AO_MPLL_PLLC_ADDR (0x40000020)
#define IAXXX_AO_MPLL_PLLC_MASK_VAL 0x0000001f
#define IAXXX_AO_MPLL_PLLC_RMASK_VAL 0x0000001f
#define IAXXX_AO_MPLL_PLLC_WMASK_VAL 0x0000001f
#define IAXXX_AO_MPLL_PLLC_RESET_VAL 0x00000000

/*
 * When high, the on-the-fly frequency change mode is eanbled; the PLL
 * frequency can be changed on the fly.
 */
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_MODE_MASK 0x00000001
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_MODE_RESET_VAL 0x0
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_MODE_POS 0
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_MODE_SIZE 1
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_MODE_DECL 0

/*
 * Clock gate enable for MPLL FOUT output clock coming into the PLLC module
 */
#define IAXXX_AO_MPLL_PLLC_FOUT_CGEN_MASK 0x00000002
#define IAXXX_AO_MPLL_PLLC_FOUT_CGEN_RESET_VAL 0x0
#define IAXXX_AO_MPLL_PLLC_FOUT_CGEN_POS 1
#define IAXXX_AO_MPLL_PLLC_FOUT_CGEN_SIZE 1
#define IAXXX_AO_MPLL_PLLC_FOUT_CGEN_DECL 1

/*
 * Clock gate enable for MPLL FREF input clock coming into the PLLC module
 */
#define IAXXX_AO_MPLL_PLLC_FREF_CGEN_MASK 0x00000004
#define IAXXX_AO_MPLL_PLLC_FREF_CGEN_RESET_VAL 0x0
#define IAXXX_AO_MPLL_PLLC_FREF_CGEN_POS 2
#define IAXXX_AO_MPLL_PLLC_FREF_CGEN_SIZE 1
#define IAXXX_AO_MPLL_PLLC_FREF_CGEN_DECL 2

/*
 * When high the content of AO.MPLL_CTRL.REFDIV and AO.MPLL_CTRL.FBDIV is
 * provided to the PLL
 * if both AO.MPLL_PLLC.ON_THE_FLY_MODE and AO.MPLL_PLLC.FREF_CGEN are high
 */
#define IAXXX_AO_MPLL_PLLC_LOAD_REF_FB_DIV_MASK 0x00000008
#define IAXXX_AO_MPLL_PLLC_LOAD_REF_FB_DIV_RESET_VAL 0x0
#define IAXXX_AO_MPLL_PLLC_LOAD_REF_FB_DIV_POS 3
#define IAXXX_AO_MPLL_PLLC_LOAD_REF_FB_DIV_SIZE 1
#define IAXXX_AO_MPLL_PLLC_LOAD_REF_FB_DIV_DECL 3

/*
 * Writing a "1" to this register generates a pulse used to transfer the
 * content of
 * AO.MPLL_CTRL.POSTDIV1 and AO.MPLL_CTRL.POSTDIV2 to the MPLL. This takes
 * effect only
 * if both AO.MPLL_PLLC.ON_THE_FLY_MODE and AO.MPLL_PLLC.FOUT_CGEN are high
 */
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_FOUTPD_MASK 0x00000010
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_FOUTPD_RESET_VAL 0x0
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_FOUTPD_POS 4
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_FOUTPD_SIZE 1
#define IAXXX_AO_MPLL_PLLC_ON_THE_FLY_FOUTPD_DECL 4

/*** AO_APLL_PLLC (0x40000024) ***/
/*
 */
#define IAXXX_AO_APLL_PLLC_ADDR (0x40000024)
#define IAXXX_AO_APLL_PLLC_MASK_VAL 0x0000001f
#define IAXXX_AO_APLL_PLLC_RMASK_VAL 0x0000001f
#define IAXXX_AO_APLL_PLLC_WMASK_VAL 0x0000001f
#define IAXXX_AO_APLL_PLLC_RESET_VAL 0x00000000

/*
 * When high, the on-the-fly frequency change mode is eanbled; the PLL
 * frequency can be changed on the fly.
 */
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_MODE_MASK 0x00000001
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_MODE_RESET_VAL 0x0
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_MODE_POS 0
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_MODE_SIZE 1
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_MODE_DECL 0

/*
 * Clock gate enable for MPLL FOUT output clock coming into the PLLC module
 */
#define IAXXX_AO_APLL_PLLC_FOUT_CGEN_MASK 0x00000002
#define IAXXX_AO_APLL_PLLC_FOUT_CGEN_RESET_VAL 0x0
#define IAXXX_AO_APLL_PLLC_FOUT_CGEN_POS 1
#define IAXXX_AO_APLL_PLLC_FOUT_CGEN_SIZE 1
#define IAXXX_AO_APLL_PLLC_FOUT_CGEN_DECL 1

/*
 * Clock gate enable for MPLL FREF input clock coming into the PLLC module
 */
#define IAXXX_AO_APLL_PLLC_FREF_CGEN_MASK 0x00000004
#define IAXXX_AO_APLL_PLLC_FREF_CGEN_RESET_VAL 0x0
#define IAXXX_AO_APLL_PLLC_FREF_CGEN_POS 2
#define IAXXX_AO_APLL_PLLC_FREF_CGEN_SIZE 1
#define IAXXX_AO_APLL_PLLC_FREF_CGEN_DECL 2

/*
 * When high the content of AO.APLL_CTRL.REFDIV and AO.APLL_CTRL.FBDIV is
 * provided to the PLL
 * if both AO.APLL_PLLC.ON_THE_FLY_MODE and AO.APLL_PLLC.FREF_CGEN are high
 */
#define IAXXX_AO_APLL_PLLC_LOAD_REF_FB_DIV_MASK 0x00000008
#define IAXXX_AO_APLL_PLLC_LOAD_REF_FB_DIV_RESET_VAL 0x0
#define IAXXX_AO_APLL_PLLC_LOAD_REF_FB_DIV_POS 3
#define IAXXX_AO_APLL_PLLC_LOAD_REF_FB_DIV_SIZE 1
#define IAXXX_AO_APLL_PLLC_LOAD_REF_FB_DIV_DECL 3

/*
 * Writing a "1" to this register generates a pulse used to transfer the
 * content of
 * AO.APLL_CTRL.POSTDIV1 and AO.APLL_CTRL.POSTDIV2 to the MPLL. This takes
 * effect only
 * if both AO.APLL_PLLC.ON_THE_FLY_MODE and AO.APLL_PLLC.FOUT_CGEN are high
 */
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_FOUTPD_MASK 0x00000010
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_FOUTPD_RESET_VAL 0x0
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_FOUTPD_POS 4
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_FOUTPD_SIZE 1
#define IAXXX_AO_APLL_PLLC_ON_THE_FLY_FOUTPD_DECL 4

/*** AO_APLL_CTRL (0x40000028) ***/
/*
 */
#define IAXXX_AO_APLL_CTRL_ADDR (0x40000028)
#define IAXXX_AO_APLL_CTRL_MASK_VAL 0x0fffffff
#define IAXXX_AO_APLL_CTRL_RMASK_VAL 0x0fffffff
#define IAXXX_AO_APLL_CTRL_WMASK_VAL 0x07ffffff
#define IAXXX_AO_APLL_CTRL_RESET_VAL 0x01c00050

/*
 * Reference divide value (1 to 16)
 */
#define IAXXX_AO_APLL_CTRL_REFDIV_MASK 0x0000000f
#define IAXXX_AO_APLL_CTRL_REFDIV_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_REFDIV_POS 0
#define IAXXX_AO_APLL_CTRL_REFDIV_SIZE 4
#define IAXXX_AO_APLL_CTRL_REFDIV_DECL (3:0)

/*
 * PLL Feedback divider (Valid values 4 to 781)
 */
#define IAXXX_AO_APLL_CTRL_FBDIV_MASK 0x00003ff0
#define IAXXX_AO_APLL_CTRL_FBDIV_RESET_VAL 0x5
#define IAXXX_AO_APLL_CTRL_FBDIV_POS 4
#define IAXXX_AO_APLL_CTRL_FBDIV_SIZE 10
#define IAXXX_AO_APLL_CTRL_FBDIV_DECL (13:4)

/*
 * PLL post divide 1 setting (1 to 16). Total post divide is
 * POSTDIV1*POSTDIV2. Actual divide value is POSTDIV1+1. Example: divide-by-1
 * = 4'b0000, divide-by-16 = 4'b1111
 */
#define IAXXX_AO_APLL_CTRL_POSTDIV1_MASK 0x0003c000
#define IAXXX_AO_APLL_CTRL_POSTDIV1_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_POSTDIV1_POS 14
#define IAXXX_AO_APLL_CTRL_POSTDIV1_SIZE 4
#define IAXXX_AO_APLL_CTRL_POSTDIV1_DECL (17:14)

/*
 * PLL post divide 2 setting (1 to 16). Total post divide is
 * POSTDIV1*POSTDIV2. Actual divide value is POSTDIV2+1. Example: divide-by-1
 * = 4'b0000, divide-by-16 = 4'b1111
 */
#define IAXXX_AO_APLL_CTRL_POSTDIV2_MASK 0x003c0000
#define IAXXX_AO_APLL_CTRL_POSTDIV2_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_POSTDIV2_POS 18
#define IAXXX_AO_APLL_CTRL_POSTDIV2_SIZE 4
#define IAXXX_AO_APLL_CTRL_POSTDIV2_DECL (21:18)

/*
 * PLL Power down. Active high.
 */
#define IAXXX_AO_APLL_CTRL_PD_MASK 0x00400000
#define IAXXX_AO_APLL_CTRL_PD_RESET_VAL 0x1
#define IAXXX_AO_APLL_CTRL_PD_POS 22
#define IAXXX_AO_APLL_CTRL_PD_SIZE 1
#define IAXXX_AO_APLL_CTRL_PD_DECL 22

/*
 * Post divide power down. Active high.
 */
#define IAXXX_AO_APLL_CTRL_FOUTPD_MASK 0x00800000
#define IAXXX_AO_APLL_CTRL_FOUTPD_RESET_VAL 0x1
#define IAXXX_AO_APLL_CTRL_FOUTPD_POS 23
#define IAXXX_AO_APLL_CTRL_FOUTPD_SIZE 1
#define IAXXX_AO_APLL_CTRL_FOUTPD_DECL 23

/*
 * VCO rate output clock power down. Active high.
 */
#define IAXXX_AO_APLL_CTRL_FOUTVCOPD_MASK 0x01000000
#define IAXXX_AO_APLL_CTRL_FOUTVCOPD_RESET_VAL 0x1
#define IAXXX_AO_APLL_CTRL_FOUTVCOPD_POS 24
#define IAXXX_AO_APLL_CTRL_FOUTVCOPD_SIZE 1
#define IAXXX_AO_APLL_CTRL_FOUTVCOPD_DECL 24

/*
 * VCO Range selection and selection of predivider RANGE.
 * VCO range: 1'b0 28MHz to 140MHz
 *            1'b1 120MHz to 600MHz
 */
#define IAXXX_AO_APLL_CTRL_RANGE_MASK 0x02000000
#define IAXXX_AO_APLL_CTRL_RANGE_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_RANGE_POS 25
#define IAXXX_AO_APLL_CTRL_RANGE_SIZE 1
#define IAXXX_AO_APLL_CTRL_RANGE_DECL 25

/*
 * FREF is bypassed to FOUT.
 */
#define IAXXX_AO_APLL_CTRL_BYPASS_MASK 0x04000000
#define IAXXX_AO_APLL_CTRL_BYPASS_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_BYPASS_POS 26
#define IAXXX_AO_APLL_CTRL_BYPASS_SIZE 1
#define IAXXX_AO_APLL_CTRL_BYPASS_DECL 26

/*
 * Lock signal. Indicates no cycle slips between the feedback clock and FPFD
 * for 256 consectutive cycles.
 */
#define IAXXX_AO_APLL_CTRL_LOCK_MASK 0x08000000
#define IAXXX_AO_APLL_CTRL_LOCK_RESET_VAL 0x0
#define IAXXX_AO_APLL_CTRL_LOCK_POS 27
#define IAXXX_AO_APLL_CTRL_LOCK_SIZE 1
#define IAXXX_AO_APLL_CTRL_LOCK_DECL 27

/*** AO_OSC_CTRL (0x4000002c) ***/
/*
 */
#define IAXXX_AO_OSC_CTRL_ADDR (0x4000002c)
#define IAXXX_AO_OSC_CTRL_MASK_VAL 0x000003ff
#define IAXXX_AO_OSC_CTRL_RMASK_VAL 0x000003ff
#define IAXXX_AO_OSC_CTRL_WMASK_VAL 0x000003ff
#define IAXXX_AO_OSC_CTRL_RESET_VAL 0x00000040

/*
 * Trim to set noiminal frequency to adjust for process variations. Provides
 * roughly 0.25% steps in output frequency.
 */
#define IAXXX_AO_OSC_CTRL_ADJ_MASK 0x0000007f
#define IAXXX_AO_OSC_CTRL_ADJ_RESET_VAL 0x40
#define IAXXX_AO_OSC_CTRL_ADJ_POS 0
#define IAXXX_AO_OSC_CTRL_ADJ_SIZE 7
#define IAXXX_AO_OSC_CTRL_ADJ_DECL (6:0)

/*
 * Asynchronous Output Clock Power down. Active high.
 */
#define IAXXX_AO_OSC_CTRL_FOUTPD_MASK 0x00000080
#define IAXXX_AO_OSC_CTRL_FOUTPD_RESET_VAL 0x0
#define IAXXX_AO_OSC_CTRL_FOUTPD_POS 7
#define IAXXX_AO_OSC_CTRL_FOUTPD_SIZE 1
#define IAXXX_AO_OSC_CTRL_FOUTPD_DECL 7

/*
 * Select nominal output frequency: 1'b0 --> 43.008 MHz
 *                                  1'b1 --> 172.032 MHz
 */
#define IAXXX_AO_OSC_CTRL_MODE_MASK 0x00000100
#define IAXXX_AO_OSC_CTRL_MODE_RESET_VAL 0x0
#define IAXXX_AO_OSC_CTRL_MODE_POS 8
#define IAXXX_AO_OSC_CTRL_MODE_SIZE 1
#define IAXXX_AO_OSC_CTRL_MODE_DECL 8

/*
 * Oscillator Power down. Active high.
 */
#define IAXXX_AO_OSC_CTRL_PD_MASK 0x00000200
#define IAXXX_AO_OSC_CTRL_PD_RESET_VAL 0x0
#define IAXXX_AO_OSC_CTRL_PD_POS 9
#define IAXXX_AO_OSC_CTRL_PD_SIZE 1
#define IAXXX_AO_OSC_CTRL_PD_DECL 9

/*** AO_CLK_CFG (0x40000030) ***/
/*
 * The Clock Configuration register sets pad directions for clock and frame
 * sync in the pcm passthru module and enables data output for the audio
 * ports and codec interface signals.
 */
#define IAXXX_AO_CLK_CFG_ADDR (0x40000030)
#define IAXXX_AO_CLK_CFG_MASK_VAL 0x33001c7f
#define IAXXX_AO_CLK_CFG_RMASK_VAL 0x33001c7f
#define IAXXX_AO_CLK_CFG_WMASK_VAL 0x33001c7f
#define IAXXX_AO_CLK_CFG_RESET_VAL 0x00000000

/*
 * Pcm Port clock output enable for PCM_PORT0_CLK in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT0_CLK_OE_MASK 0x00000001
#define IAXXX_AO_CLK_CFG_PCM_PORT0_CLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT0_CLK_OE_POS 0
#define IAXXX_AO_CLK_CFG_PCM_PORT0_CLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT0_CLK_OE_DECL 0

/*
 * Pcm Port clock output enable for PCM_PORT1_CLK in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT1_CLK_OE_MASK 0x00000002
#define IAXXX_AO_CLK_CFG_PCM_PORT1_CLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT1_CLK_OE_POS 1
#define IAXXX_AO_CLK_CFG_PCM_PORT1_CLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT1_CLK_OE_DECL 1

/*
 * Pcm Port clock output enable for PCM_PORT2_CLK in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT2_CLK_OE_MASK 0x00000004
#define IAXXX_AO_CLK_CFG_PCM_PORT2_CLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT2_CLK_OE_POS 2
#define IAXXX_AO_CLK_CFG_PCM_PORT2_CLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT2_CLK_OE_DECL 2

/*
 * Pcm Port frame sync output enable for pin PORTPORT0_FS in the pcm passthru
 * module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT0_FS_OE_MASK 0x00000008
#define IAXXX_AO_CLK_CFG_PCM_PORT0_FS_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT0_FS_OE_POS 3
#define IAXXX_AO_CLK_CFG_PCM_PORT0_FS_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT0_FS_OE_DECL 3

/*
 * Pcm Port frame sync output enable for pin PORTPORT1_FS in the pcm passthru
 * module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT1_FS_OE_MASK 0x00000010
#define IAXXX_AO_CLK_CFG_PCM_PORT1_FS_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT1_FS_OE_POS 4
#define IAXXX_AO_CLK_CFG_PCM_PORT1_FS_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT1_FS_OE_DECL 4

/*
 * Pcm Port frame sync output enable for pin PORTPORT2_FS in the pcm passthru
 * module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT2_FS_OE_MASK 0x00000020
#define IAXXX_AO_CLK_CFG_PCM_PORT2_FS_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT2_FS_OE_POS 5
#define IAXXX_AO_CLK_CFG_PCM_PORT2_FS_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT2_FS_OE_DECL 5

/*
 * CDC_MCLK output enable.
 */
#define IAXXX_AO_CLK_CFG_CDC_MCLK_OE_MASK 0x00000040
#define IAXXX_AO_CLK_CFG_CDC_MCLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_CDC_MCLK_OE_POS 6
#define IAXXX_AO_CLK_CFG_CDC_MCLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_CDC_MCLK_OE_DECL 6

/*
 * 0: Tri-state PCM_PORT0_DO pin;
 * 1: enable PCM_PORT0_DO as an output buffer in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT0_DO_OE_MASK 0x00000400
#define IAXXX_AO_CLK_CFG_PCM_PORT0_DO_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT0_DO_OE_POS 10
#define IAXXX_AO_CLK_CFG_PCM_PORT0_DO_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT0_DO_OE_DECL 10

/*
 * 0: Tri-state PCM_PORT1_DO pin;
 * 1: enable PCM_PORT1_DO as an output buffer in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT1_DO_OE_MASK 0x00000800
#define IAXXX_AO_CLK_CFG_PCM_PORT1_DO_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT1_DO_OE_POS 11
#define IAXXX_AO_CLK_CFG_PCM_PORT1_DO_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT1_DO_OE_DECL 11

/*
 * 0: Tri-state PCM_PORT2_DO pin;
 * 1: enable PCM_PORT2_DO as an output buffer in the pcm passthru module.
 */
#define IAXXX_AO_CLK_CFG_PCM_PORT2_DO_OE_MASK 0x00001000
#define IAXXX_AO_CLK_CFG_PCM_PORT2_DO_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_PCM_PORT2_DO_OE_POS 12
#define IAXXX_AO_CLK_CFG_PCM_PORT2_DO_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_PCM_PORT2_DO_OE_DECL 12

/*
 * 0: Tri-state DMIC0_CLK pin;
 * 1: enable DMIC0_CLK as an output buffer in the pdm passthru module.
 */
#define IAXXX_AO_CLK_CFG_DMIC0_CLK_OE_MASK 0x01000000
#define IAXXX_AO_CLK_CFG_DMIC0_CLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_DMIC0_CLK_OE_POS 24
#define IAXXX_AO_CLK_CFG_DMIC0_CLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_DMIC0_CLK_OE_DECL 24

/*
 * 0: Tri-state DMIC1_CLK pin;
 * 1: enable DMIC1_CLK as an output buffer in the pdm passthru module.
 */
#define IAXXX_AO_CLK_CFG_DMIC1_CLK_OE_MASK 0x02000000
#define IAXXX_AO_CLK_CFG_DMIC1_CLK_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_DMIC1_CLK_OE_POS 25
#define IAXXX_AO_CLK_CFG_DMIC1_CLK_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_DMIC1_CLK_OE_DECL 25

/*
 * 0: Tri-state DMIC0_DO pin;
 * 1: enable DMIC0_DO as an output buffer in the pdm passthru module.
 */
#define IAXXX_AO_CLK_CFG_DMIC0_DO_OE_MASK 0x10000000
#define IAXXX_AO_CLK_CFG_DMIC0_DO_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_DMIC0_DO_OE_POS 28
#define IAXXX_AO_CLK_CFG_DMIC0_DO_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_DMIC0_DO_OE_DECL 28

/*
 * 0: Tri-state DMIC1_DO pin;
 * 1: enable DMIC1_DO as an output buffer in the pdm passthru module.
 */
#define IAXXX_AO_CLK_CFG_DMIC1_DO_OE_MASK 0x20000000
#define IAXXX_AO_CLK_CFG_DMIC1_DO_OE_RESET_VAL 0x0
#define IAXXX_AO_CLK_CFG_DMIC1_DO_OE_POS 29
#define IAXXX_AO_CLK_CFG_DMIC1_DO_OE_SIZE 1
#define IAXXX_AO_CLK_CFG_DMIC1_DO_OE_DECL 29

/*** AO_DFLT_FUNC_SEL_PCM_PORT (0x40000034) ***/
/*
 * This register is used to program below pads to select their PCM functions.
 * When PD8 is in sleep mode, IO_CTRL registers cannot be programmed since
 * they are in PD8. The function then selected for below pads is the reset
 * default function (GPIO). In such a situation, this register can be used to
 * put these ports in PCM pass-through mode.
 *
 Note that this register overrides any function selected through IO_CTRL
 * registers, even when PD8 is awake. It is also not reset when PD8 comes out
 * of sleep. SW has to explicitly write a '0' to the corresponding port bit
 * to disable PCM functions and let the function selection through IO_CTRL
 * take effect. It is supposed to be used only when PD8 is shut off and some
 * ports are to be used for PCM pass-through. It should be disabled when PD8
 * comes out of sleep.
 *
 SW must ensute that any port is not configured in both the modes (PCM and
 * PDM) at any given point of time.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_ADDR (0x40000034)
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_MASK_VAL 0x0000001f
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_RMASK_VAL 0x0000001f
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_WMASK_VAL 0x0000001f
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_RESET_VAL 0x00000000

/*
 * PORTA : PORTA_CLK, PORTA_FS, PORTA_DI, PORTA_DO
 *
 0: Selects functions for PORTA as indicated by the IO_CTRL registers for
 * PORTA.
 * 1: Selects PCM functions local_pcm_ports (BCLK, FS, DR and DT) for Port
 * PORTA.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTA_MASK 0x00000001
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTA_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTA_POS 0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTA_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTA_DECL 0

/*
 * PORTB : PORTB_CLK, PORTB_FS, PORTB_DI, PORTB_DO
 *
 0: Selects functions for PORTB as indicated by the IO_CTRL registers for
 * PORTB.
 * 1: Selects PCM functions local_pcm_ports (BCLK, FS, DR and DT) for Port
 * PORTB.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTB_MASK 0x00000002
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTB_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTB_POS 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTB_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTB_DECL 1

/*
 * PORTC : PORTC_CLK, PORTC_FS, PORTC_DI, PORTC_DO
 *
 0: Selects functions for PORTC as indicated by the IO_CTRL registers for
 * PORTC.
 * 1: Selects PCM functions local_pcm_ports (BCLK, FS, DR and DT) for Port
 * PORTC.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTC_MASK 0x00000004
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTC_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTC_POS 2
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTC_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_PORTC_DECL 2

/*
 * COMMB : COMMB_0, COMMB_1, COMMB_2, COMMB_3
 *
 0: Selects functions for COMMB as indicated by the IO_CTRL registers for
 * COMMB.
 * 1: Selects PCM functions local_pcm_ports (BCLK, FS, DR and DT) for Port
 * COMMB.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_COMMB_MASK 0x00000008
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_COMMB_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_COMMB_POS 3
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_COMMB_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_COMMB_DECL 3

/*
 * GPIO : GPIO_0, GPIO_1, WAKE, IRQ
 *
 0: Selects functions for GPIO as indicated by the IO_CTRL registers for
 * GPIO.
 * 1: Selects PCM functions local_pcm_ports (BCLK, FS, DR and DT) for Port
 * GPIO.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_GPIO_MASK 0x00000010
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_GPIO_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_GPIO_POS 4
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_GPIO_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PCM_PORT_GPIO_DECL 4

/*** AO_DFLT_FUNC_SEL_PDM_PORT (0x40000038) ***/
/*
 * This register is used to program below pads to select their PDM functions.
 * When PD8 is in sleep mode, IO_CTRL registers cannot be programmed since
 * they are in PD8. The function then selected for below pads is the reset
 * default function (GPIO). In such a situation, this register can be used to
 * put these ports in PDM pass-through mode.
 *
 Note that this register overrides any function selected through IO_CTRL
 * registers, even when PD8 is awake. It is also not reset when PD8 comes out
 * of sleep. SW has to explicitly write a '0' to the corresponding port bit
 * to disable PDM functions and let the function selection through IO_CTRL
 * take effect. It is supposed to be used only when PD8 is shut off and some
 * ports are to be used for PDM pass-through. It should be disabled when PD8
 * comes out of sleep.
 *
 SW must ensute that any port is not configured in both the modes (PCM and
 * PDM) at any given point of time.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_ADDR (0x40000038)
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_MASK_VAL 0x000003ff
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_RMASK_VAL 0x000003ff
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WMASK_VAL 0x000003ff
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_RESET_VAL 0x00000000

/*
 * PORTA_CLK_FS : PORTA_CLK, PORTA_FS
 *
 0: Selects functions for PORTA_CLK_FS as indicated by the IO_CTRL
 * registers for PORTA_CLK_FS.
 * 1: Selects PDM functions local_pdm_ports (CLK_OUT and DATA_OUT
 * respectively) for Port PORTA_CLK_FS.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_CLK_FS_MASK 0x00000001
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_CLK_FS_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_CLK_FS_POS 0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_CLK_FS_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_CLK_FS_DECL 0

/*
 * PORTA_DI_DO : PORTA_DI, PORTA_DO
 *
 0: Selects functions for PORTA_DI_DO as indicated by the IO_CTRL registers
 * for PORTA_DI_DO.
 * 1: Selects PDM functions local_pdm_ports (DATA_IN and CLK_IN respectively)
 * for Port PORTA_DI_DO.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_DI_DO_MASK 0x00000002
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_DI_DO_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_DI_DO_POS 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_DI_DO_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTA_DI_DO_DECL 1

/*
 * PORTB_CLK_FS : PORTB_CLK, PORTB_FS
 *
 0: Selects functions for PORTB_CLK_FS as indicated by the IO_CTRL
 * registers for PORTB_CLK_FS.
 * 1: Selects PDM functions local_pdm_ports (CLK_OUT and DATA_OUT
 * respectively) for Port PORTB_CLK_FS.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_CLK_FS_MASK 0x00000004
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_CLK_FS_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_CLK_FS_POS 2
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_CLK_FS_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_CLK_FS_DECL 2

/*
 * PORTB_DI_DO : PORTB_DI, PORTB_DO
 *
 0: Selects functions for PORTB_DI_DO as indicated by the IO_CTRL registers
 * for PORTB_DI_DO.
 * 1: Selects PDM functions local_pdm_ports (DATA_IN and CLK_IN respectively)
 * for Port PORTB_DI_DO.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_DI_DO_MASK 0x00000008
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_DI_DO_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_DI_DO_POS 3
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_DI_DO_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTB_DI_DO_DECL 3

/*
 * PORTC_CLK_FS : PORTC_CLK, PORTC_FS
 *
 0: Selects functions for PORTC_CLK_FS as indicated by the IO_CTRL
 * registers for PORTC_CLK_FS.
 * 1: Selects PDM functions local_pdm_ports (CLK_OUT and DATA_OUT
 * respectively) for Port PORTC_CLK_FS.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_CLK_FS_MASK 0x00000010
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_CLK_FS_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_CLK_FS_POS 4
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_CLK_FS_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_CLK_FS_DECL 4

/*
 * PORTC_DI_DO : PORTC_DI, PORTC_DO
 *
 0: Selects functions for PORTC_DI_DO as indicated by the IO_CTRL registers
 * for PORTC_DI_DO.
 * 1: Selects PDM functions local_pdm_ports (DATA_IN and CLK_IN respectively)
 * for Port PORTC_DI_DO.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_DI_DO_MASK 0x00000020
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_DI_DO_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_DI_DO_POS 5
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_DI_DO_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_PORTC_DI_DO_DECL 5

/*
 * COMMB_0_1 : COMMB_0, COMMB_1
 *
 0: Selects functions for COMMB_0_1 as indicated by the IO_CTRL registers
 * for COMMB_0_1.
 * 1: Selects PDM functions local_pdm_ports (CLK_OUT and DATA_OUT
 * respectively) for Port COMMB_0_1.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_0_1_MASK 0x00000040
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_0_1_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_0_1_POS 6
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_0_1_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_0_1_DECL 6

/*
 * COMMB_2_3 : COMMB_2, COMMB_3
 *
 0: Selects functions for COMMB_2_3 as indicated by the IO_CTRL registers
 * for COMMB_2_3.
 * 1: Selects PDM functions local_pdm_ports (DATA_IN and CLK_IN respectively)
 * for Port COMMB_2_3.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_2_3_MASK 0x00000080
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_2_3_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_2_3_POS 7
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_2_3_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_COMMB_2_3_DECL 7

/*
 * GPIO_0_1 : GPIO_0, GPIO_1
 *
 0: Selects functions for GPIO_0_1 as indicated by the IO_CTRL registers
 * for GPIO_0_1.
 * 1: Selects PDM functions local_pdm_ports (CLK_OUT and DATA_OUT
 * respectively) for Port GPIO_0_1.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_GPIO_0_1_MASK 0x00000100
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_GPIO_0_1_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_GPIO_0_1_POS 8
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_GPIO_0_1_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_GPIO_0_1_DECL 8

/*
 * WAKE_IRQ : WAKE, IRQ
 *
 0: Selects functions for WAKE_IRQ as indicated by the IO_CTRL registers
 * for WAKE_IRQ.
 * 1: Selects PDM functions local_pdm_ports (DATA_IN and CLK_IN respectively)
 * for Port WAKE_IRQ.
 */
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WAKE_IRQ_MASK 0x00000200
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WAKE_IRQ_RESET_VAL 0x0
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WAKE_IRQ_POS 9
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WAKE_IRQ_SIZE 1
#define IAXXX_AO_DFLT_FUNC_SEL_PDM_PORT_WAKE_IRQ_DECL 9

/*** AO_PCM_PASSTHROUGH0 (0x4000003c) ***/
/*
 * The PCM Passthrough 0 register enables pcm data pass-through operation
 * (pcm_pt) from an input port to an output port.
 * By default, each port would loop its input back to its output, but
 * pass-through is disabled.  Note that there are 3 pcm_pt ports from pads
 * which are used for passthru functions, and in the D4080, these pcm_pt pins
 * can come from various actual IO PADS.
 */
#define IAXXX_AO_PCM_PASSTHROUGH0_ADDR (0x4000003c)
#define IAXXX_AO_PCM_PASSTHROUGH0_MASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH0_RMASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH0_WMASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH0_RESET_VAL 0x00000024

/*
 * In order to enable this route, enable PCM_DT_PASS_EN_PORT0 (see
 * PCM_PASSTHROUGH2 register).
 * Otherwise, no output will be driven or enabled in passthru mode.
 * 0b00: Drive pcm_pt0_dt pin from pcm_pt0_dr pin
 * 0b01: Drive pcm_pt0_dt pin from pcm_pt1_dr pin
 * 0b10: Drive pcm_pt0_dt pin from pcm_pt2_dr pin
 */
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_0_MASK 0x00000003
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_0_RESET_VAL 0x0
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_0_POS 0
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_0_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_0_DECL (1:0)

/*
 * In order to enable this route, enable PCM_DT_PASS_EN_PORT1 (see
 * PCM_PASSTHROUGH2 register).
 * Otherwise, no output will be driven or enabled in passthru mode.
 * 0b00: Drive pcm_pt1_dt pin from pcm_pt0_dr pin
 * 0b01: Drive pcm_pt1_dt pin from pcm_pt1_dr pin
 * 0b10: Drive pcm_pt1_dt pin from pcm_pt2_dr pin
 */
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_1_MASK 0x0000000c
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_1_RESET_VAL 0x1
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_1_POS 2
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_1_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_1_DECL (3:2)

/*
 * In order to enable this route, enable PCM_DT_PASS_EN_PORT2 (see
 * PCM_PASSTHROUGH2 register).
 * Otherwise, no output will be driven or enabled in passthru mode.
 * 0b00: Drive pcm_pt2_dt pin from pcm_pt0_dr pin
 * 0b01: Drive pcm_pt2_dt pin from pcm_pt1_dr pin
 * 0b10: Drive pcm_pt2_dt pin from pcm_pt2_dr pin
 */
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_2_MASK 0x00000030
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_2_RESET_VAL 0x2
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_2_POS 4
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_2_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH0_DT_2_DECL (5:4)

/*** AO_PCM_PASSTHROUGH1 (0x40000040) ***/
/*
 * The PCM Passhthrough 1 register enables clock, and frame sync pass-through
 * operation (pcm_pt) from any input port to any output port.
 * By default, each port would loop its input back to its output, but
 * pass-through is disabled.  Note that there are 3 pcm pcm_pt from pads
 * which are used for passthru functions, and in the D4080, these pcm_pt pins
 * can come from various actual IO PADS.
 */
#define IAXXX_AO_PCM_PASSTHROUGH1_ADDR (0x40000040)
#define IAXXX_AO_PCM_PASSTHROUGH1_MASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH1_RMASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH1_WMASK_VAL 0x0000003f
#define IAXXX_AO_PCM_PASSTHROUGH1_RESET_VAL 0x00000024

/*
 * 0b00: Both pcm_pt0_bclk/pcm_pt0_fs are not driven from the pcm passthrough
 * mode (need to be driven by some other mode). Use pcm_pt0_bclk/pcm_pt0_fs
 * for pass-through select signal synchronization that selects the output
 * data to pcm_pt0_dr.
 *
 0b01: If all of CF_1/CF_2 are NOT 0b00, drive pcm_pt0_bclk/pcm_pt0_fs pins
 * from pcm_pt1_bclk/pcm_pt1_fs pins. Use pcm_pt1_bclk/pcm_pt1_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt0_bclk/pcm_pt0_fs is determined by
 * register CLK_CFG bit[0]/bit[3];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt0_bclk/pcm_pt0_fs pin
 * are disabled as outputs.
 *
 0b10: If all of CF_1/CF_2 are NOT 0b00, drive pcm_pt0_bclk/pcm_pt0_fs pins
 * from pcm_pt2_bclk/pcm_pt2_fs pins. Use pcm_pt2_bclk/pcm_pt2_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt0_bclk/pcm_pt0_fs is determined by
 * register CLK_CFG bit[0]/bit[3];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt0_bclk/pcm_pt0_fs are
 * disabled as outputs.
 */
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_0_MASK 0x00000003
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_0_RESET_VAL 0x0
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_0_POS 0
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_0_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_0_DECL (1:0)

/*
 * 0b00: If all of CF_0/CF_2 are NOT 0b01, drive pcm_pt1_bclk/pcm_pt1_fs pins
 * from pcm_pt0_bclk/pcm_pt0_fs pins. Use pcm_pt0_bclk/pcm_pt0_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt1_bclk/pcm_pt1_fs is determined by
 * register CLK_CFG bit[1]/bit[4];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt1_bclk/pcm_pt1_fs pin
 * are disabled as outputs.
 *
 0b01: Both pcm_pt1_bclk/pcm_pt1_fs are not driven from the pcm passthrough
 * mode (need to be driven by some other mode). Use pcm_pt1_bclk/pcm_pt1_fs
 * for pass-through select signal synchronization that selects the output
 * data to pcm_pt1_dr.
 *
 0b10: If all of CF_0/CF_2 are NOT 0b01, drive pcm_pt1_bclk/pcm_pt1_fs pins
 * from pcm_pt2_bclk/pcm_pt2_fs pins. Use pcm_pt2_bclk/pcm_pt2_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt1_bclk/pcm_pt1_fs is determined by
 * register CLK_CFG bit[1]/bit[4];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt1_bclk/pcm_pt1_fs are
 * disabled as outputs.
 */
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_1_MASK 0x0000000c
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_1_RESET_VAL 0x1
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_1_POS 2
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_1_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_1_DECL (3:2)

/*
 * 0b00: If all of CF_0/CF_1 are NOT 0b10, drive pcm_pt2_bclk/pcm_pt2_fs pins
 * from pcm_pt0_bclk/pcm_pt0_fs pins. Use pcm_pt0_bclk/pcm_pt0_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt2_bclk/pcm_pt2_fs is determined by
 * register CLK_CFG bit[2]/bit[5];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt2_bclk/pcm_pt2_fs pin
 * disabled as outputs.
 *
 0b01: If all of CF_0/CF_1 are NOT 0b10, drive pcm_pt2_bclk/pcm_pt2_fs pins
 * from pcm_pt1_bclk/pcm_pt1_fs pins. Use pcm_pt1_bclk/pcm_pt1_fs for
 * pass-through select signal synchronization that selects the output data to
 * pcm_pt0_dr. The direction of the pcm_pt2_bclk/pcm_pt2_fs is determined by
 * register CLK_CFG bit[2]/bit[5];
 *       Else if any of CF_1/CF_2 is set to 0b00, pcm_pt2_bclk/pcm_pt2_fs pin
 * disabled as outputs.
 *
 0b10: Both pcm_pt2_bclk/pcm_pt2_fs are not driven from the pcm passthrough
 * mode (need to be driven by some other mode). Use pcm_pt2_bclk/pcm_pt2_fs
 * for pass-through select signal synchronization that selects the output
 * data to pcm_pt2_dr.
 */
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_2_MASK 0x00000030
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_2_RESET_VAL 0x2
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_2_POS 4
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_2_SIZE 2
#define IAXXX_AO_PCM_PASSTHROUGH1_CF_2_DECL (5:4)

/*** AO_PCM_PASSTHROUGH2 (0x40000044) ***/
/*
 * The PCM Passthrough 1 register enables pcm data pass-through operation
 * (pcm_pt) from an input port to an output port.
 * By default, each port would loop its input back to its output, but
 * pass-through is disabled.  Note that there are 3 pcm_pt ports from pads
 * which are used for passthru functions, and in the D4080, these pcm_pt pins
 * can come from various actual IO PADS.
 */
#define IAXXX_AO_PCM_PASSTHROUGH2_ADDR (0x40000044)
#define IAXXX_AO_PCM_PASSTHROUGH2_MASK_VAL 0x00000007
#define IAXXX_AO_PCM_PASSTHROUGH2_RMASK_VAL 0x00000007
#define IAXXX_AO_PCM_PASSTHROUGH2_WMASK_VAL 0x00000007
#define IAXXX_AO_PCM_PASSTHROUGH2_RESET_VAL 0x00000000

/*
 * PCM_DT_PASS_EN for ptPORT0.
 */
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT0_DPT_EN_MASK 0x00000001
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT0_DPT_EN_RESET_VAL 0x0
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT0_DPT_EN_POS 0
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT0_DPT_EN_SIZE 1
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT0_DPT_EN_DECL 0

/*
 * PCM_DT_PASS_EN for ptPORT1.
 */
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT1_DPT_EN_MASK 0x00000002
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT1_DPT_EN_RESET_VAL 0x0
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT1_DPT_EN_POS 1
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT1_DPT_EN_SIZE 1
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT1_DPT_EN_DECL 1

/*
 * PCM_DT_PASS_EN for ptPORT2.
 */
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT2_DPT_EN_MASK 0x00000004
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT2_DPT_EN_RESET_VAL 0x0
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT2_DPT_EN_POS 2
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT2_DPT_EN_SIZE 1
#define IAXXX_AO_PCM_PASSTHROUGH2_PCM_PORT2_DPT_EN_DECL 2

/*** AO_PCM_DPT_SYNC (0x40000048) ***/
/*
 * The PCM Direct Pass-Through Synchronization register sets the frame sync
 * polarity, clock polarity, data delay for the ports as well as returning
 * pass-through synchronization status for each port. Supports read/write
 * access except for PCM (PORT2:PORT0)_DPT_STATUS, which is read-only.
 */
#define IAXXX_AO_PCM_DPT_SYNC_ADDR (0x40000048)
#define IAXXX_AO_PCM_DPT_SYNC_MASK_VAL 0x00000fff
#define IAXXX_AO_PCM_DPT_SYNC_RMASK_VAL 0x00000fff
#define IAXXX_AO_PCM_DPT_SYNC_WMASK_VAL 0x000001ff
#define IAXXX_AO_PCM_DPT_SYNC_RESET_VAL 0x00000000

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT0_FS rising edge indicate a frame boundary
 * 1: PCM PORT0_FS falling edge indicate a frame boundary
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_FS_POL_MASK 0x00000001
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_FS_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_FS_POL_POS 0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_FS_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_FS_POL_DECL 0

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT1_FS rising edge indicate a frame boundary
 * 1: PCM PORT1_FS falling edge indicate a frame boundary
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_FS_POL_MASK 0x00000002
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_FS_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_FS_POL_POS 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_FS_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_FS_POL_DECL 1

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT2_FS rising edge indicate a frame boundary
 * 1: PCM PORT2_FS falling edge indicate a frame boundary
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_FS_POL_MASK 0x00000004
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_FS_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_FS_POL_POS 2
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_FS_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_FS_POL_DECL 2

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT0_CLK uses posedge
 * 1: PCM PORT0_CLK uses negedge
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_CLK_POL_MASK 0x00000008
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_CLK_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_CLK_POL_POS 3
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_CLK_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_CLK_POL_DECL 3

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT1_CLK uses posedge
 * 1: PCM PORT1_CLK uses negedge
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_CLK_POL_MASK 0x00000010
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_CLK_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_CLK_POL_POS 4
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_CLK_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_CLK_POL_DECL 4

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT2_CLK uses posedge
 * 1: PCM PORT2_CLK uses negedge
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_CLK_POL_MASK 0x00000020
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_CLK_POL_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_CLK_POL_POS 5
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_CLK_POL_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_CLK_POL_DECL 5

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT0_DI data delay is 0
 * 1: PCM PORT0_DI data delay is 1
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DDLY_MASK 0x00000040
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DDLY_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DDLY_POS 6
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DDLY_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DDLY_DECL 6

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT1_DI data delay is 0
 * 1: PCM PORT1_DI data delay is 1
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DDLY_MASK 0x00000080
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DDLY_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DDLY_POS 7
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DDLY_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DDLY_DECL 7

/*
 * This bit is used when the chip is in hardware pass-through mode.
 * 0: PCM PORT2_DI data delay is 0
 * 1: PCM PORT2_DI data delay is 1
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DDLY_MASK 0x00000100
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DDLY_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DDLY_POS 8
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DDLY_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DDLY_DECL 8

/*
 * This is a read-only register bit. This bit indicates that register
 * PCM_PASSTHROUGH2 bit [0], PCM_PORT0_DPT_EN, is synchronized to the
 * selected PCM PORT_CLK/FS, which can be any of PCM [PORT2:PORT0]_CLK/FS
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DPT_STATUS_MASK 0x00000200
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DPT_STATUS_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DPT_STATUS_POS 9
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DPT_STATUS_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT0_DPT_STATUS_DECL 9

/*
 * This is a read-only register bit. This bit indicates that register
 * PCM_PASSTHROUGH2 bit [1], PCM_PORT1_DPT_EN, is synchronized to the
 * selected PCM PORT_CLK/FS, which can be any of PCM [PORT2:PORT0]_CLK/FS
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DPT_STATUS_MASK 0x00000400
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DPT_STATUS_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DPT_STATUS_POS 10
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DPT_STATUS_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT1_DPT_STATUS_DECL 10

/*
 * This is a read-only register bit. This bit indicates that register
 * PCM_PASSTHROUGH2 bit [2], PCM_PORT2_DPT_EN, is synchronized to the
 * selected PCM PORT_CLK/FS, which can be any of PCM [PORT2:PORT0]_CLK/FS
 */
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DPT_STATUS_MASK 0x00000800
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DPT_STATUS_RESET_VAL 0x0
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DPT_STATUS_POS 11
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DPT_STATUS_SIZE 1
#define IAXXX_AO_PCM_DPT_SYNC_PCM_PORT2_DPT_STATUS_DECL 11

/*** AO_PDM_PASSTHROUGH (0x4000004c) ***/
/*
 * The PDM Passhthrough register enables dmic data pass-through (dmic_pt)
 * from any input pdm input port to pdm output port.  This will allow pdm
 * passthrough through the dmic pins for io, rather than through the PCM
 * passthru.  Note that which pads used for the dmic input and output is
 * something that needs to be configured separately.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_ADDR (0x4000004c)
#define IAXXX_AO_PDM_PASSTHROUGH_MASK_VAL 0x3303030f
#define IAXXX_AO_PDM_PASSTHROUGH_RMASK_VAL 0x3303030f
#define IAXXX_AO_PDM_PASSTHROUGH_WMASK_VAL 0x3303030f
#define IAXXX_AO_PDM_PASSTHROUGH_RESET_VAL 0x00000000

/*
 * 1: Drive dmic_pt0_do from dmic_pt0_di.  Used only in legacy mode.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_0_PASSTHROUGH_MASK 0x00000001
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_0_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_0_PASSTHROUGH_POS 0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_0_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_0_PASSTHROUGH_DECL 0

/*
 * 1: Drive dmic_pt0_do from dmic_pt1_di.  Used only in legacy mode.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_1_PASSTHROUGH_MASK 0x00000002
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_1_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_1_PASSTHROUGH_POS 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_1_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_1_PASSTHROUGH_DECL 1

/*
 * 1: Drive dmic_pt1_do from dmic_pt0_di.  Used only in legacy mode.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_0_PASSTHROUGH_MASK 0x00000004
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_0_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_0_PASSTHROUGH_POS 2
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_0_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_0_PASSTHROUGH_DECL 2

/*
 * 1: Drive dmic_pt1_do from dmic_pt1_di.  Used only in legacy mode.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_1_PASSTHROUGH_MASK 0x00000008
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_1_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_1_PASSTHROUGH_POS 3
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_1_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_1_PASSTHROUGH_DECL 3

/*
 * PDM data for new passhtru mode depends on PDM0_DPT_DATA_SEL 0:dmic_pt0_di
 * and 1:dmic_pt1_di.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_DATA_SEL_MASK 0x00000100
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_DATA_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_DATA_SEL_POS 8
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_DATA_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_DATA_SEL_DECL 8

/*
 * PDM data for new passhtru mode depends on PDM1_DPT_DATA_SEL 0:dmic_pt0_di
 * and 1:dmic_pt1_di.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_DATA_SEL_MASK 0x00000200
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_DATA_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_DATA_SEL_POS 9
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_DATA_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_DATA_SEL_DECL 9

/*
 * PDM data channel select for new passthru mode for dmic_pt0_do.
 * 0: Select L(eft) channel of the muxed PDM data to drive out.
 * 1: Select R(ight) channel of the muxed PDM data to drive out.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CH_SEL_MASK 0x00010000
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CH_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CH_SEL_POS 16
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CH_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CH_SEL_DECL 16

/*
 * PDM data channel select for new passthru mode for dmic_pt1_do.
 * 0: Select L(eft) channel of the muxed PDM data to drive out.
 * 1: Select R(ight) channel of the muxed PDM data to drive out.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CH_SEL_MASK 0x00020000
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CH_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CH_SEL_POS 17
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CH_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CH_SEL_DECL 17

/*
 * PDM data for new passhtru mode depends control for clock, as well as the
 * output timing shapers.  If not using the pdm passthru, this should be
 * programmed to match the TX_AC_0 field in CIC_CLOCK_CTRL register since it
 * controls the timing shaper.
 * 0: Select DMIC0_CLK.
 * 1: Select DMIC1_CLK.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CLK_SEL_MASK 0x01000000
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CLK_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CLK_SEL_POS 24
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CLK_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM0_DPT_CLK_SEL_DECL 24

/*
 * PDM data for new passhtru mode depends control for clock, as well as the
 * output timing shapers.  If not using the pdm passthru, this should be
 * programmed to match the TX_AC_0 field in CIC_CLOCK_CTRL register since it
 * controls the timing shaper.
 * 0: Select DMIC0_CLK.
 * 1: Select DMIC1_CLK.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CLK_SEL_MASK 0x02000000
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CLK_SEL_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CLK_SEL_POS 25
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CLK_SEL_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_PDM1_DPT_CLK_SEL_DECL 25

/*
 * The DMIC0_CLK can be driven out from the source selected in
 * PDM0_DPT_CLK_SEL if this bit is enabled.
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_CLK_PASSTHROUGH_MASK 0x10000000
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_CLK_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_CLK_PASSTHROUGH_POS 28
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_CLK_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC0_CLK_PASSTHROUGH_DECL 28

/*
 * The DMIC1_CLK can be driven out from the source selected in
 * PDM1_DPT_CLK_SEL if this bit is enabled.
 *
 *
 */
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_CLK_PASSTHROUGH_MASK 0x20000000
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_CLK_PASSTHROUGH_RESET_VAL 0x0
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_CLK_PASSTHROUGH_POS 29
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_CLK_PASSTHROUGH_SIZE 1
#define IAXXX_AO_PDM_PASSTHROUGH_DMIC1_CLK_PASSTHROUGH_DECL 29

/*** AO_PDM_DPT_SYNC (0x40000050) ***/
/*
 * The PDM Direct Pass-Through Synchronization enable the new pdm passthru
 * mode for the pdm ports. Supports read/write access except for
 * PDM[(0:1)]_DPT_STATUS, which is read-only.  If using the new pdm passthru,
 * PDM_PASSTHROUGH must have been setup before writing this register
 */
#define IAXXX_AO_PDM_DPT_SYNC_ADDR (0x40000050)
#define IAXXX_AO_PDM_DPT_SYNC_MASK_VAL 0x00000303
#define IAXXX_AO_PDM_DPT_SYNC_RMASK_VAL 0x00000303
#define IAXXX_AO_PDM_DPT_SYNC_WMASK_VAL 0x00000003
#define IAXXX_AO_PDM_DPT_SYNC_RESET_VAL 0x00000000

/*
 * 1: Enable new pdm passthrough mode.
 * 0: Regular pdm passthrough mode.
 */
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_EN_MASK 0x00000001
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_EN_RESET_VAL 0x0
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_EN_POS 0
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_EN_SIZE 1
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_EN_DECL 0

/*
 * 1: Enable new pdm passthrough mode.
 * 0: Regular pdm passthrough mode.
 */
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_EN_MASK 0x00000002
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_EN_RESET_VAL 0x0
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_EN_POS 1
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_EN_SIZE 1
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_EN_DECL 1

/*
 * This is a read-only register bit. This bit indicates that register
 * PDM0_DPT_EN is synchronized to the selected PDM_CLK.
 */
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_STATUS_MASK 0x00000100
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_STATUS_RESET_VAL 0x0
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_STATUS_POS 8
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_STATUS_SIZE 1
#define IAXXX_AO_PDM_DPT_SYNC_PDM0_DPT_STATUS_DECL 8

/*
 * This is a read-only register bit. This bit indicates that register
 * PDM1_DPT_EN is synchronized to the selected PDM_CLK.
 */
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_STATUS_MASK 0x00000200
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_STATUS_RESET_VAL 0x0
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_STATUS_POS 9
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_STATUS_SIZE 1
#define IAXXX_AO_PDM_DPT_SYNC_PDM1_DPT_STATUS_DECL 9

/*** AO_PDM_TIMING (0x40000054) ***/
/*
 * The PCM Timing register provides control for the timing shaper on output
 * pdm signals (output enables and data).
 * There are two shapers, correspondoing to the two pdm outputs: dmic_do0 and
 * dmic_do1 (or dmic_pt0_do and dmic_pt1_do)
 */
#define IAXXX_AO_PDM_TIMING_ADDR (0x40000054)
#define IAXXX_AO_PDM_TIMING_MASK_VAL 0x8fff8fff
#define IAXXX_AO_PDM_TIMING_RMASK_VAL 0x8fff8fff
#define IAXXX_AO_PDM_TIMING_WMASK_VAL 0x8fff8fff
#define IAXXX_AO_PDM_TIMING_RESET_VAL 0x00000000

/*
 * Enable this number of programmable stage delays for the clock portion of
 * the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_CLK_MASK 0x00000007
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_CLK_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_CLK_POS 0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_CLK_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_CLK_DECL (2:0)

/*
 * 1: Enable the base delays for the clock portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_CLK_MASK 0x00000008
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_CLK_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_CLK_POS 3
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_CLK_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_CLK_DECL 3

/*
 * Enable this number of programmable stage delays for the data portion of
 * the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_MASK 0x00000070
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_POS 4
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_DECL (6:4)

/*
 * 1: Enable the base delays for the data portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_MASK 0x00000080
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_POS 7
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_DECL 7

/*
 * Enable this number of programmable stage delays for the data output enable
 * portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_OE_MASK 0x00000700
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_OE_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_OE_POS 8
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_OE_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_ADDTL_STAGES_DATA_OE_DECL (10:8)

/*
 * 1: Enable the base delays for the data output enable portion of the timing
 * shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_OE_MASK 0x00000800
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_OE_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_OE_POS 11
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_OE_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_BASE_DELAYS_DATA_OE_DECL 11

/*
 * 1: Enable the clock timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_CLK_SHAPER_MASK 0x00008000
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_CLK_SHAPER_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_CLK_SHAPER_POS 15
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_CLK_SHAPER_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC0_EN_CLK_SHAPER_DECL 15

/*
 * Enable this number of programmable stage delays for the clock portion of
 * the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_CLK_MASK 0x00070000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_CLK_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_CLK_POS 16
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_CLK_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_CLK_DECL (18:16)

/*
 * 1: Enable the base delays for the clock portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_CLK_MASK 0x00080000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_CLK_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_CLK_POS 19
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_CLK_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_CLK_DECL 19

/*
 * Enable this number of programmable stage delays for the data portion of
 * the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_MASK 0x00700000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_POS 20
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_DECL (22:20)

/*
 * 1: Enable the base delays for the data portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_MASK 0x00800000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_POS 23
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_DECL 23

/*
 * Enable this number of programmable stage delays for the data output enable
 * portion of the timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_OE_MASK 0x07000000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_OE_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_OE_POS 24
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_OE_SIZE 3
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_ADDTL_STAGES_DATA_OE_DECL (26:24)

/*
 * 1: Enable the base delays for the data output enable portion of the timing
 * shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_OE_MASK 0x08000000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_OE_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_OE_POS 27
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_OE_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_BASE_DELAYS_DATA_OE_DECL 27

/*
 * 1: Enable the clock timing shaper.
 */
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_CLK_SHAPER_MASK 0x80000000
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_CLK_SHAPER_RESET_VAL 0x0
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_CLK_SHAPER_POS 31
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_CLK_SHAPER_SIZE 1
#define IAXXX_AO_PDM_TIMING_DMIC1_EN_CLK_SHAPER_DECL 31

/*** AO_EFUSE (0x40000058) ***/
/*
 * This register is used by the SW to access the EFUSE
 */
#define IAXXX_AO_EFUSE_ADDR (0x40000058)
#define IAXXX_AO_EFUSE_MASK_VAL 0x001fffff
#define IAXXX_AO_EFUSE_RMASK_VAL 0x001fffff
#define IAXXX_AO_EFUSE_WMASK_VAL 0x00001fff
#define IAXXX_AO_EFUSE_RESET_VAL 0x00000006

/*
 * This bit is used to enable the control of the EFUSE by the SW
 * 0: The EFUSE SW access is disabled
 * 1: The EFUSE SW access is enabled
 */
#define IAXXX_AO_EFUSE_SW_CTRL_EN_MASK 0x00000001
#define IAXXX_AO_EFUSE_SW_CTRL_EN_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_SW_CTRL_EN_POS 0
#define IAXXX_AO_EFUSE_SW_CTRL_EN_SIZE 1
#define IAXXX_AO_EFUSE_SW_CTRL_EN_DECL 0

/*
 * This bit is used to drive the chip enable, active low, of the EFUSE
 * 0: CSB of the EFUSE is 0 if SW_CTRL_EN is 1
 * 1: CSB of the EFUSE is 1 if SW_CTRL_EN is 1
 */
#define IAXXX_AO_EFUSE_SW_CS_N_MASK 0x00000002
#define IAXXX_AO_EFUSE_SW_CS_N_RESET_VAL 0x1
#define IAXXX_AO_EFUSE_SW_CS_N_POS 1
#define IAXXX_AO_EFUSE_SW_CS_N_SIZE 1
#define IAXXX_AO_EFUSE_SW_CS_N_DECL 1

/*
 * This bit is used to drive the program enable, active low, of the EFUSE
 * 0: PGENB of the EFUSE is 0 if SW_CTRL_EN is 1
 * 1: PGENB of the EFUSE is 1 if SW_CTRL_EN is 1
 */
#define IAXXX_AO_EFUSE_SW_PGEN_N_MASK 0x00000004
#define IAXXX_AO_EFUSE_SW_PGEN_N_RESET_VAL 0x1
#define IAXXX_AO_EFUSE_SW_PGEN_N_POS 2
#define IAXXX_AO_EFUSE_SW_PGEN_N_SIZE 1
#define IAXXX_AO_EFUSE_SW_PGEN_N_DECL 2

/*
 * This bit is used to drive the strobe signali, active high, of the EFUSE
 * 0: STROBE of the EFUSE is 0 if SW_CTRL_EN is 1
 * 1: STROBE of the EFUSE is 1 if SW_CTRL_EN is 1
 */
#define IAXXX_AO_EFUSE_SW_STROBE_MASK 0x00000008
#define IAXXX_AO_EFUSE_SW_STROBE_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_SW_STROBE_POS 3
#define IAXXX_AO_EFUSE_SW_STROBE_SIZE 1
#define IAXXX_AO_EFUSE_SW_STROBE_DECL 3

/*
 * This bit is used to drive the load signali, active high, of the EFUSE
 * 0: LOAD of the EFUSE is 0 if SW_CTRL_EN is 1
 * 1: LOAD of the EFUSE is 1 if SW_CTRL_EN is 1
 */
#define IAXXX_AO_EFUSE_SW_LOAD_MASK 0x00000010
#define IAXXX_AO_EFUSE_SW_LOAD_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_SW_LOAD_POS 4
#define IAXXX_AO_EFUSE_SW_LOAD_SIZE 1
#define IAXXX_AO_EFUSE_SW_LOAD_DECL 4

/*
 * If SW_CTRL_EN is 1 then this register drives the address bus of the EFUSE
 */
#define IAXXX_AO_EFUSE_SW_ADDR_MASK 0x00001fe0
#define IAXXX_AO_EFUSE_SW_ADDR_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_SW_ADDR_POS 5
#define IAXXX_AO_EFUSE_SW_ADDR_SIZE 8
#define IAXXX_AO_EFUSE_SW_ADDR_DECL (12:5)

/*
 * Output data bus of the EFUSE.
 */
#define IAXXX_AO_EFUSE_DOUT_MASK 0x001fe000
#define IAXXX_AO_EFUSE_DOUT_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_DOUT_POS 13
#define IAXXX_AO_EFUSE_DOUT_SIZE 8
#define IAXXX_AO_EFUSE_DOUT_DECL (20:13)

/*** AO_PWR_CTRL (0x4000005c) ***/
/*
 * The power control register initiates sleep mode and software wakeup for
 * pd3/pd4 power domain. Supports write-only access. The AO.PWR_CTRL_STS_CLR
 * register holds the state of the underlying hardware bits.
 */
#define IAXXX_AO_PWR_CTRL_ADDR (0x4000005c)
#define IAXXX_AO_PWR_CTRL_MASK_VAL 0x00000c61
#define IAXXX_AO_PWR_CTRL_RMASK_VAL 0x00000000
#define IAXXX_AO_PWR_CTRL_WMASK_VAL 0x00000000
#define IAXXX_AO_PWR_CTRL_RESET_VAL 0x00000000

/*
 * Read: Always returns 0.
 * Write 0: No function.
 * Write 1: Go to sleep. Master signal to control powering down the chip.
 */
#define IAXXX_AO_PWR_CTRL_SLEEP_MASK 0x00000001
#define IAXXX_AO_PWR_CTRL_SLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_SLEEP_POS 0
#define IAXXX_AO_PWR_CTRL_SLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_SLEEP_DECL 0

/*
 * No sleep for pd4 domain.
 * Read: Always returns 0.
 * Write 0: pd4 will be powered down when AO.PWR_CTRL.SLEEP register bit is
 * set.
 * Write 1: pd4 will stay powered up when AO.PWR_CTRL.SLEEP register bit is
 * set.
 */
#define IAXXX_AO_PWR_CTRL_PD4_NOSLEEP_MASK 0x00000020
#define IAXXX_AO_PWR_CTRL_PD4_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_PD4_NOSLEEP_POS 5
#define IAXXX_AO_PWR_CTRL_PD4_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_PD4_NOSLEEP_DECL 5

/*
 * No sleep for pd5 domain.
 * Read: Always returns 0.
 * Write 0: pd5 will be powered down when AO.PWR_CTRL.SLEEP register bit is
 * set.
 * Write 1: pd5 will stay powered up when AO.PWR_CTRL.SLEEP register bit is
 * set.
 */
#define IAXXX_AO_PWR_CTRL_PD5_NOSLEEP_MASK 0x00000040
#define IAXXX_AO_PWR_CTRL_PD5_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_PD5_NOSLEEP_POS 6
#define IAXXX_AO_PWR_CTRL_PD5_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_PD5_NOSLEEP_DECL 6

/*
 * No sleep for pd8 domain.
 * Read: Always returns 0.
 * Write 0: pd8 will be powered down when AO.PWR_CTRL.SLEEP register bit is
 * set.
 * Write 1: pd8 will stay powered up when AO.PWR_CTRL.SLEEP register bit is
 * set.
 */
#define IAXXX_AO_PWR_CTRL_PD8_NOSLEEP_MASK 0x00000400
#define IAXXX_AO_PWR_CTRL_PD8_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_PD8_NOSLEEP_POS 10
#define IAXXX_AO_PWR_CTRL_PD8_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_PD8_NOSLEEP_DECL 10

/*
 * No sleep for mpll.  Normally would get reset during a sleep wakeup cycle.
 * Read: Always returns 0.
 * Write 0: mpll will have it's PD control asserted when AO.PWR_CTRL.SLEEP
 * register bit is set (so it will be powered-down).
 * Write 1: mpll will NOT have it's PD control asserted when
 * AO.PWR_CTRL.SLEEP register bit is set (so it will not be powered-down).
 */
#define IAXXX_AO_PWR_CTRL_MPLL_NOSLEEP_MASK 0x00000800
#define IAXXX_AO_PWR_CTRL_MPLL_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_MPLL_NOSLEEP_POS 11
#define IAXXX_AO_PWR_CTRL_MPLL_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_MPLL_NOSLEEP_DECL 11

/*** AO_PWR_CTRL_STS_CLR (0x40000060) ***/
/*
 * The power control status and clear register returns sleep mode status when
 * read and can bring domain out of sleep when written with a "1". Supports
 * write-1-to-clear and read access. State of fields is also controlled by
 * hardware and PWR_CTRL register.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_ADDR (0x40000060)
#define IAXXX_AO_PWR_CTRL_STS_CLR_MASK_VAL 0x00020c61
#define IAXXX_AO_PWR_CTRL_STS_CLR_RMASK_VAL 0x00020c61
#define IAXXX_AO_PWR_CTRL_STS_CLR_WMASK_VAL 0x00000001
#define IAXXX_AO_PWR_CTRL_STS_CLR_RESET_VAL 0x00000000

/*
 * Read: Returns the value programmed into the AO.PWR_CTRL.SLEEP bit. This
 * bit is preserved when going to sleep so it is available after coming out
 * of sleep.
 * Write 0: Does nothing.
 * Write 1: Clears entire AO.PWR_CTRL_STS_CLR register (all bits).
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_MASK 0x00000001
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_POS 0
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_DECL 0

/*
 * Read: Returns the value programmed into the AO.PWR_CTRL.PD4_NOSLEEP bit.
 * This bit is preserved when going to sleep so it is available after coming
 * out of sleep.
 * Write 0/1: Does nothing.
 * When AO.PWR_CTRL_STS_CLR.SLEEP bit is set to 1, this bit is cleared.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD4_NOSLEEP_MASK 0x00000020
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD4_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD4_NOSLEEP_POS 5
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD4_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD4_NOSLEEP_DECL 5

/*
 * Read: Returns the value programmed into the AO.PWR_CTRL.PD5_NOSLEEP bit.
 * This bit is preserved when going to sleep so it is available after coming
 * out of sleep.
 * Write 0/1: Does nothing.
 * When AO.PWR_CTRL_STS_CLR.SLEEP bit is set to 1, this bit is cleared.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD5_NOSLEEP_MASK 0x00000040
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD5_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD5_NOSLEEP_POS 6
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD5_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD5_NOSLEEP_DECL 6

/*
 * Read: Returns the value programmed into the AO.PWR_CTRL.PD8_NOSLEEP bit.
 * This bit is preserved when going to sleep so it is available after coming
 * out of sleep.
 * Write 0/1: Does nothing.
 * When AO.PWR_CTRL_STS_CLR.SLEEP bit is set to 1, this bit is cleared.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD8_NOSLEEP_MASK 0x00000400
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD8_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD8_NOSLEEP_POS 10
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD8_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_PD8_NOSLEEP_DECL 10

/*
 * Read: Returns the value programmed into the AO.PWR_CTRL.MPLL_NOSLEEP bit.
 * This bit is preserved when going to sleep so it is available after coming
 * out of sleep.
 * Write 0/1: Does nothing.
 * When AO.PWR_CTRL_STS_CLR.SLEEP bit is set to 1, this bit is cleared.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_MPLL_NOSLEEP_MASK 0x00000800
#define IAXXX_AO_PWR_CTRL_STS_CLR_MPLL_NOSLEEP_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_MPLL_NOSLEEP_POS 11
#define IAXXX_AO_PWR_CTRL_STS_CLR_MPLL_NOSLEEP_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_MPLL_NOSLEEP_DECL 11

/*
 * 1 indicates that the chip has entered "sleep" mode.  Due to no_sleep
 * feature (plus domain controlled via SW_PWR_CTRL_SET), the various power
 * domains may or may not be powered down.  However, in order to leave
 * "sleep" mode, a wakeup event of some sort must occur..
 * 0 indicates that chip in not in "sleep" mode.
 */
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_STS_MASK 0x00020000
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_STS_RESET_VAL 0x0
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_STS_POS 17
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_STS_SIZE 1
#define IAXXX_AO_PWR_CTRL_STS_CLR_SLEEP_STS_DECL 17

/*** AO_GP (0x40000064) ***/
/*
 * General purpose scratchpad register set, maintains state in sleep mode.
 * Supports write-1-to-set access.
 */
#define IAXXX_AO_GP_ADDR (0x40000064)
#define IAXXX_AO_GP_MASK_VAL 0x00000001
#define IAXXX_AO_GP_RMASK_VAL 0x00000000
#define IAXXX_AO_GP_WMASK_VAL 0x00000000
#define IAXXX_AO_GP_RESET_VAL 0x00000000

/*
 * Read: Always returns 0.
 * Write 0: No function.
 * Write 1: Sets the GP_STS_CLR.STATE bit.
 */
#define IAXXX_AO_GP_STATE_MASK 0x00000001
#define IAXXX_AO_GP_STATE_RESET_VAL 0x0
#define IAXXX_AO_GP_STATE_POS 0
#define IAXXX_AO_GP_STATE_SIZE 1
#define IAXXX_AO_GP_STATE_DECL 0

/*** AO_GP_STS_CLR (0x40000068) ***/
/*
 * General purpose scratchpad register status and clear. Supports
 * write-1-to-clear and read access.
 */
#define IAXXX_AO_GP_STS_CLR_ADDR (0x40000068)
#define IAXXX_AO_GP_STS_CLR_MASK_VAL 0x00000001
#define IAXXX_AO_GP_STS_CLR_RMASK_VAL 0x00000001
#define IAXXX_AO_GP_STS_CLR_WMASK_VAL 0x00000001
#define IAXXX_AO_GP_STS_CLR_RESET_VAL 0x00000000

/*
 * 0: Does nothing.
 * 1: Clears AO.GP_STS_CLR.STATE register.
 */
#define IAXXX_AO_GP_STS_CLR_STATE_MASK 0x00000001
#define IAXXX_AO_GP_STS_CLR_STATE_RESET_VAL 0x0
#define IAXXX_AO_GP_STS_CLR_STATE_POS 0
#define IAXXX_AO_GP_STS_CLR_STATE_SIZE 1
#define IAXXX_AO_GP_STS_CLR_STATE_DECL 0

/*** AO_INT_FWD (0x4000006c) ***/
/*
 * This is a legacy module which is instantiated in D4080 but is not
 * connected to the IOs, so it does not function.  The original descriptions
 * are maintained below for completeness.
 * ===========
 * The Interrupt Forwarding control register allows configuration of the
 * interrupt forwarding mechanism. During sleep, this allows D400 to capture
 * an interrupt on the CDC_INT_N pin and drive the INTR_EVNT pin in response,
 * hold the event until software wakes up, and allow software to clear the
 * interrupt and control ownership of the INTR_EVNT pin. Always use ARM to
 * enable interrupt capture. Selection of forwarded codec interrupt or gpio_2
 * to drive INTR_EVNT pin is controlled by the register field
 * IO_CTRL.INTR_EVNT.MUX_SEL.
 */
#define IAXXX_AO_INT_FWD_ADDR (0x4000006c)
#define IAXXX_AO_INT_FWD_MASK_VAL 0x0001000f
#define IAXXX_AO_INT_FWD_RMASK_VAL 0x0001000c
#define IAXXX_AO_INT_FWD_WMASK_VAL 0x0000000f
#define IAXXX_AO_INT_FWD_RESET_VAL 0x00000000

/*
 * Set interrupt forwarding storage register, CAPT. Note that polarity
 * control is separate. If both SET and CLR are 1, invert state of CAPT. Wait
 * at least 4 CLK_IN periods after ARM is deasserted to set this bit.
 * Read: Always returns 0.
 * Write 0: No effect.
 * Write 1: If CLR == 0, set CAPT to 1, else invert state of CAPT.
 */
#define IAXXX_AO_INT_FWD_SET_MASK 0x00000001
#define IAXXX_AO_INT_FWD_SET_RESET_VAL 0x0
#define IAXXX_AO_INT_FWD_SET_POS 0
#define IAXXX_AO_INT_FWD_SET_SIZE 1
#define IAXXX_AO_INT_FWD_SET_DECL 0

/*
 * Clear interrupt forwarding storage register, CAPT. Note that polarity
 * control is separate. If both SET and CLR are 1, invert state of CAPT. Wait
 * at least 4 CLK_IN periods after ARM is deasserted to set this bit.
 * Read: Always returns 0.
 * Write 0: No effect.
 * Write 1: If SET == 0, clear CAPT to 0, else invert state of CAPT.
 */
#define IAXXX_AO_INT_FWD_CLR_MASK 0x00000002
#define IAXXX_AO_INT_FWD_CLR_RESET_VAL 0x0
#define IAXXX_AO_INT_FWD_CLR_POS 1
#define IAXXX_AO_INT_FWD_CLR_SIZE 1
#define IAXXX_AO_INT_FWD_CLR_DECL 1

/*
 * When asserted, this bit forces codec interrupt capture even when pd3/pd4
 * are awake. If this bit is set, hardware will not clear CAPT when CLR is
 * set nor set it when SET is set. Note that although interrupt capture is
 * armed automatically during pd3/pd4 sleep, interrupt capture can miss
 * events if CDC_INT_N wakeup occurs too soon after the processor initiates
 * pd3/pd4 sleep. Wait a minimum of 4 CLK_IN periods after de-asserting ARM
 * before asserting CLR or SET.
 * Write 0: Arm interrupt capture only during pd3/pd4 sleep. Allow SET to set
 * CAPT and CLR to clear CAPT.
 * Write 1: Arm interrupt capture even when pd3/pd4 is awake.
 */
#define IAXXX_AO_INT_FWD_ARM_MASK 0x00000004
#define IAXXX_AO_INT_FWD_ARM_RESET_VAL 0x0
#define IAXXX_AO_INT_FWD_ARM_POS 2
#define IAXXX_AO_INT_FWD_ARM_SIZE 1
#define IAXXX_AO_INT_FWD_ARM_DECL 2

/*
 * Invert polarity of forwarded codec interrupt to INTR_EVNT pin.
 * 0: INTR_EVNT pin is driven high to indicate forwarded interrupt.
 * 1: INTR_EVNT pin is driven low to indicate forwarded interrupt.
 */
#define IAXXX_AO_INT_FWD_INV_POL_MASK 0x00000008
#define IAXXX_AO_INT_FWD_INV_POL_RESET_VAL 0x0
#define IAXXX_AO_INT_FWD_INV_POL_POS 3
#define IAXXX_AO_INT_FWD_INV_POL_SIZE 1
#define IAXXX_AO_INT_FWD_INV_POL_DECL 3

/*
 * Indicates if a codec interrupt occurred during pd3/pd4 sleep. Can be set
 * or cleared also through SET and CLR.
 * 0: No codec interrupt occurred during pd3/pd4 sleep.
 * 1: A codec interrupt occurred during pd3/pd4 sleep.
 */
#define IAXXX_AO_INT_FWD_CAPT_MASK 0x00010000
#define IAXXX_AO_INT_FWD_CAPT_RESET_VAL 0x0
#define IAXXX_AO_INT_FWD_CAPT_POS 16
#define IAXXX_AO_INT_FWD_CAPT_SIZE 1
#define IAXXX_AO_INT_FWD_CAPT_DECL 16

/*** AO_PKG_CFG (0x40000070) ***/
/*
 * The package configuration status register holds identification
 * information, including values read at reset from the eFuse macro. Supports
 * read-only access.
 */
#define IAXXX_AO_PKG_CFG_ADDR (0x40000070)
#define IAXXX_AO_PKG_CFG_MASK_VAL 0xfffffff0
#define IAXXX_AO_PKG_CFG_RMASK_VAL 0xfffffff0
#define IAXXX_AO_PKG_CFG_WMASK_VAL 0x00000000
#define IAXXX_AO_PKG_CFG_RESET_VAL 0xd4080000

/*
 * This field mirrors the register field AO.EFUSE_BOOT.PKG_CFG.
 * Package configuration information. Value of EFUSE[0][(3:0)] loaded at reset
 * before SW boot starts.
 * It gives 16 different package options for the die. Current associations:
 *   0x0: BGA-49 pin package
 *   0x1: eWLB-42 pin package
 *   Other: To be determined
 */
#define IAXXX_AO_PKG_CFG_PKG_CFG_MASK 0x000000f0
#define IAXXX_AO_PKG_CFG_PKG_CFG_RESET_VAL 0x0
#define IAXXX_AO_PKG_CFG_PKG_CFG_POS 4
#define IAXXX_AO_PKG_CFG_PKG_CFG_SIZE 4
#define IAXXX_AO_PKG_CFG_PKG_CFG_DECL (7:4)

/*
 * This field mirrors the register field AO.EFUSE_BOOT.ROM_REV.
 * ROM revision number. Value of EFUSE[0][(7:4)] loaded at reset before SW boot
 * starts.
 * Revision code read from address in the instruction ROM at reset.
 */
#define IAXXX_AO_PKG_CFG_ROM_REV_MASK 0x00000f00
#define IAXXX_AO_PKG_CFG_ROM_REV_RESET_VAL 0x0
#define IAXXX_AO_PKG_CFG_ROM_REV_POS 8
#define IAXXX_AO_PKG_CFG_ROM_REV_SIZE 4
#define IAXXX_AO_PKG_CFG_ROM_REV_DECL (11:8)

/*
 * This field mirrors the register field AO.EFUSE_BOOT.LAYOUT_REV.
 * Die layout revision, incremented for each mask update after initial
 * tapeout. Not incremented for ROM metal changes. Incremented for metal
 * changes to non-ROM parts of the die.
 *   0x0: First revision.
 */
#define IAXXX_AO_PKG_CFG_LAYOUT_REV_MASK 0x0000f000
#define IAXXX_AO_PKG_CFG_LAYOUT_REV_RESET_VAL 0x0
#define IAXXX_AO_PKG_CFG_LAYOUT_REV_POS 12
#define IAXXX_AO_PKG_CFG_LAYOUT_REV_SIZE 4
#define IAXXX_AO_PKG_CFG_LAYOUT_REV_DECL (15:12)

/*
 * System-on-chip architecture type.
 * 0x08: Chelsea
 */
#define IAXXX_AO_PKG_CFG_ARCH_TYPE_MASK 0x00ff0000
#define IAXXX_AO_PKG_CFG_ARCH_TYPE_RESET_VAL 0x8
#define IAXXX_AO_PKG_CFG_ARCH_TYPE_POS 16
#define IAXXX_AO_PKG_CFG_ARCH_TYPE_SIZE 8
#define IAXXX_AO_PKG_CFG_ARCH_TYPE_DECL (23:16)

/*
 * Core processor type running algorithm.
 * 0x4: Delta processor-based products (DMX)
 */
#define IAXXX_AO_PKG_CFG_CORE_TYPE_MASK 0x0f000000
#define IAXXX_AO_PKG_CFG_CORE_TYPE_RESET_VAL 0x4
#define IAXXX_AO_PKG_CFG_CORE_TYPE_POS 24
#define IAXXX_AO_PKG_CFG_CORE_TYPE_SIZE 4
#define IAXXX_AO_PKG_CFG_CORE_TYPE_DECL (27:24)

/*
 * Die type.
 * 0xD: Digital VLSI.
 */
#define IAXXX_AO_PKG_CFG_DIE_TYPE_MASK 0xf0000000
#define IAXXX_AO_PKG_CFG_DIE_TYPE_RESET_VAL 0xd
#define IAXXX_AO_PKG_CFG_DIE_TYPE_POS 28
#define IAXXX_AO_PKG_CFG_DIE_TYPE_SIZE 4
#define IAXXX_AO_PKG_CFG_DIE_TYPE_DECL (31:28)

/*** AO_SW_LOR_0 (0x40000074) ***/
/*
 * The software latch-on-reset register mirrors the values of the
 * latch-on-reset pins read at reset. This is a read-only register.
 */
#define IAXXX_AO_SW_LOR_0_ADDR (0x40000074)
#define IAXXX_AO_SW_LOR_0_MASK_VAL 0x0000003f
#define IAXXX_AO_SW_LOR_0_RMASK_VAL 0x0000003f
#define IAXXX_AO_SW_LOR_0_WMASK_VAL 0x00000000
#define IAXXX_AO_SW_LOR_0_RESET_VAL 0x00000008

/*
 * Value of PORTA_DO pin at exit of reset. It is used to control the I2C
 * address along with I2C_1. Note that this LOR has no hardware function
 * beyond setting this register field.
 * I2C0 I2C1: I2C Address
 *   0 0: 7 bit address 0x3E
 *   0 1: 7 bit address 0x3F
 *   1 0: 10 bit address 0x266
 *   1 1: 10 bit address 0x267
 */
#define IAXXX_AO_SW_LOR_0_I2C_0_MASK 0x00000001
#define IAXXX_AO_SW_LOR_0_I2C_0_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_0_I2C_0_POS 0
#define IAXXX_AO_SW_LOR_0_I2C_0_SIZE 1
#define IAXXX_AO_SW_LOR_0_I2C_0_DECL 0

/*
 * Value of PORTB_DO pin at exit of reset. It is used to control the I2C
 * address along with I2C_0. Note that this LOR has no hardware function
 * beyond setting this register field.
 * I2C0 I2C1: I2C Address
 *   0 0: 7 bit address 0x3E
 *   0 1: 7 bit address 0x3F
 *   1 0: 10 bit address 0x266
 *   1 1: 10 bit address 0x267
 */
#define IAXXX_AO_SW_LOR_0_I2C_1_MASK 0x00000002
#define IAXXX_AO_SW_LOR_0_I2C_1_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_0_I2C_1_POS 1
#define IAXXX_AO_SW_LOR_0_I2C_1_SIZE 1
#define IAXXX_AO_SW_LOR_0_I2C_1_DECL 1

/*
 * Used by HW, indicates IO voltage for hardware if not overridden by eFuse
 * bit.
 * LOR values given in the table.  Note that signaling voltage settings at
 * POC
 * cell are inverted relative to the table below.  PORTC_DO is pulled low on
 * chip at reset,
 * and 1.8V signaling is the default.
 *
 If AO:EFUSE_BOOT.IO_33_LDO_EN == 1, then IO signaling voltage level =
 * VDDIO_LEVEL from LDO
 * Else AO:EFUSE_BOOT.IO_33_LDO_EN == 0, then IO signaling voltage level =
 * AO:SW_LOR_0.IO_33.
 * IO signaling voltage level coding at POC IO cell =
 * 1'b0 : IO level is <= 1.8V
 * 1'b1 : IO signaling level is >=2.5V.
 */
#define IAXXX_AO_SW_LOR_0_IO_33_MASK 0x00000004
#define IAXXX_AO_SW_LOR_0_IO_33_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_0_IO_33_POS 2
#define IAXXX_AO_SW_LOR_0_IO_33_SIZE 1
#define IAXXX_AO_SW_LOR_0_IO_33_DECL 2

/*
 * Used by SBL firmware to configure I/O mux for CTS/RTS controls for UART0.
 * Mapped to AO:SW_LOR_0.CTS_RTS =
 * 1'b0 : do not bring out CTS/RTS controls for UART0;
 * 1'b1 : bring out CTS/RTS controls for UART0.
 */
#define IAXXX_AO_SW_LOR_0_CTS_RTS_MASK 0x00000008
#define IAXXX_AO_SW_LOR_0_CTS_RTS_RESET_VAL 0x1
#define IAXXX_AO_SW_LOR_0_CTS_RTS_POS 3
#define IAXXX_AO_SW_LOR_0_CTS_RTS_SIZE 1
#define IAXXX_AO_SW_LOR_0_CTS_RTS_DECL 3

/*
 * Used by SBL firmware to configure I/O mux and other hardware to boot from
 * external Flash ROM attached to COMMB port.  Mapped to COMMB_1 pin and
 * sw_lor_9 signal.  AO:SW_LOR_0.BOOT_FROM_FLASH_N =
 * 1'b0 : boot from external FLASH ROM after SBL boot:
 * 1'b1 : wait for commands from autodetected interface protocol on COMMA
 * after SBL boot.
 */
#define IAXXX_AO_SW_LOR_0_BOOT_FROM_FLASH_N_MASK 0x00000010
#define IAXXX_AO_SW_LOR_0_BOOT_FROM_FLASH_N_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_0_BOOT_FROM_FLASH_N_POS 4
#define IAXXX_AO_SW_LOR_0_BOOT_FROM_FLASH_N_SIZE 1
#define IAXXX_AO_SW_LOR_0_BOOT_FROM_FLASH_N_DECL 4

/*
 * Value of IRQ pin at exit of reset. Used by HW to select clock source for
 * SBL boot =
 * 1'b0 : use internal Oscillator as clock source;
 * 1'b1 : use CLK_IN pin as clock source.
 */
#define IAXXX_AO_SW_LOR_0_BOOT_CLK_MASK 0x00000020
#define IAXXX_AO_SW_LOR_0_BOOT_CLK_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_0_BOOT_CLK_POS 5
#define IAXXX_AO_SW_LOR_0_BOOT_CLK_SIZE 1
#define IAXXX_AO_SW_LOR_0_BOOT_CLK_DECL 5

/*** AO_SW_LOR_1 (0x40000078) ***/
/*
 */
#define IAXXX_AO_SW_LOR_1_ADDR (0x40000078)
#define IAXXX_AO_SW_LOR_1_MASK_VAL 0x01ffffff
#define IAXXX_AO_SW_LOR_1_RMASK_VAL 0x01ffffff
#define IAXXX_AO_SW_LOR_1_WMASK_VAL 0x00000000
#define IAXXX_AO_SW_LOR_1_RESET_VAL 0x00000000

/*
 * 25 LOR not yet assigned a function
 */
#define IAXXX_AO_SW_LOR_1_0_TO_24_MASK 0x01ffffff
#define IAXXX_AO_SW_LOR_1_0_TO_24_RESET_VAL 0x0
#define IAXXX_AO_SW_LOR_1_0_TO_24_POS 0
#define IAXXX_AO_SW_LOR_1_0_TO_24_SIZE 25
#define IAXXX_AO_SW_LOR_1_0_TO_24_DECL (24:0)

/*** AO_EFUSE_BOOT (0x4000007c) ***/
/*
 * The EFUSE_BOOT register mirrors the contents of the eFuse hard macro which
 * is programmed during the manufacturing test process. Some of the fields
 * are duplicated in the AO.PKG_CFG register, but the EFUSE register gives
 * access to all the bits. Supports read-only access.
 */
#define IAXXX_AO_EFUSE_BOOT_ADDR (0x4000007c)
#define IAXXX_AO_EFUSE_BOOT_MASK_VAL 0x3fffffff
#define IAXXX_AO_EFUSE_BOOT_RMASK_VAL 0x3fffffff
#define IAXXX_AO_EFUSE_BOOT_WMASK_VAL 0x00000000
#define IAXXX_AO_EFUSE_BOOT_RESET_VAL 0x00000000

/*
 * Package configuration information. Value of EFUSE[0][(3:0)] loaded at reset
 * before SW boot starts.
 * It gives 16 different package options for the die. Current associations:
 *   0x0: eS904
 *   0x8: eS954
 *   0x9: eS964
 *   Other: To be determined
 */
#define IAXXX_AO_EFUSE_BOOT_PKG_CFG_MASK 0x0000000f
#define IAXXX_AO_EFUSE_BOOT_PKG_CFG_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_PKG_CFG_POS 0
#define IAXXX_AO_EFUSE_BOOT_PKG_CFG_SIZE 4
#define IAXXX_AO_EFUSE_BOOT_PKG_CFG_DECL (3:0)

/*
 * ROM revision number. Value of EFUSE[0][(7:4)] loaded at reset before SW boot
 * starts.
 * Revision code read from address in the instruction ROM at reset.
 */
#define IAXXX_AO_EFUSE_BOOT_ROM_REV_MASK 0x000000f0
#define IAXXX_AO_EFUSE_BOOT_ROM_REV_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_ROM_REV_POS 4
#define IAXXX_AO_EFUSE_BOOT_ROM_REV_SIZE 4
#define IAXXX_AO_EFUSE_BOOT_ROM_REV_DECL (7:4)

/*
 * Layout revision number. Value of EFUSE[1][(3:0)] loaded at reset before SW
 * boot starts.
 * Die layout revision, incremented for each mask update after initial
 * tapeout. Not incremented for ROM metal changes. Incremented for metal
 * changes to non-ROM parts of the die.
 *   0x0: First revision.
 */
#define IAXXX_AO_EFUSE_BOOT_LAYOUT_REV_MASK 0x00000f00
#define IAXXX_AO_EFUSE_BOOT_LAYOUT_REV_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_LAYOUT_REV_POS 8
#define IAXXX_AO_EFUSE_BOOT_LAYOUT_REV_SIZE 4
#define IAXXX_AO_EFUSE_BOOT_LAYOUT_REV_DECL (11:8)

/*
 * Boot protocol overrides:
 * 4'x0 : Normal SBL boot (check all 3 interfaces)
 * 4'x1: Check I2C0
 * 4'x2: Check SPI0
 * 4'x4: Check UART0
 * 4'x8-4'xF : Check all (same as 0)
 */
#define IAXXX_AO_EFUSE_BOOT_BOOT_OVRRD_MASK 0x0000f000
#define IAXXX_AO_EFUSE_BOOT_BOOT_OVRRD_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_BOOT_OVRRD_POS 12
#define IAXXX_AO_EFUSE_BOOT_BOOT_OVRRD_SIZE 4
#define IAXXX_AO_EFUSE_BOOT_BOOT_OVRRD_DECL (15:12)

/*
 * HMD1A HiFi-3 disable:
 * 1'b0 : HMD1A HiFi-3 register bank is enabled
 * 1'b1 : HMD1A HiFi-3 register bank set is disabled
 */
#define IAXXX_AO_EFUSE_BOOT_HMD_HIFI3_DIS_MASK 0x00010000
#define IAXXX_AO_EFUSE_BOOT_HMD_HIFI3_DIS_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_HMD_HIFI3_DIS_POS 16
#define IAXXX_AO_EFUSE_BOOT_HMD_HIFI3_DIS_SIZE 1
#define IAXXX_AO_EFUSE_BOOT_HMD_HIFI3_DIS_DECL 16

/*
 * Oscillator trim programming status.
 */
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_PG_MASK 0x00020000
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_PG_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_PG_POS 17
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_PG_SIZE 1
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_PG_DECL 17

/*
 * Keep JTAG_EN_N bit set to 0 after SBL boot.
 */
#define IAXXX_AO_EFUSE_BOOT_JTAG_EN_N_MASK 0x00040000
#define IAXXX_AO_EFUSE_BOOT_JTAG_EN_N_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_JTAG_EN_N_POS 18
#define IAXXX_AO_EFUSE_BOOT_JTAG_EN_N_SIZE 1
#define IAXXX_AO_EFUSE_BOOT_JTAG_EN_N_DECL 18

/*
 * HMD1A disable:
 * 1'b0 : HMD1A use is enabled
 * 1'b1 : HMD1A use is disabled
 */
#define IAXXX_AO_EFUSE_BOOT_HMD_DIS_MASK 0x00080000
#define IAXXX_AO_EFUSE_BOOT_HMD_DIS_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_HMD_DIS_POS 19
#define IAXXX_AO_EFUSE_BOOT_HMD_DIS_SIZE 1
#define IAXXX_AO_EFUSE_BOOT_HMD_DIS_DECL 19

/*
 * HMD1A disable:
 * 1'b0 : HMD1A use is enabled
 * 1'b1 : HMD1A use is disabled
 */
#define IAXXX_AO_EFUSE_BOOT_IO_33_LDO_EN_MASK 0x00100000
#define IAXXX_AO_EFUSE_BOOT_IO_33_LDO_EN_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_IO_33_LDO_EN_POS 20
#define IAXXX_AO_EFUSE_BOOT_IO_33_LDO_EN_SIZE 1
#define IAXXX_AO_EFUSE_BOOT_IO_33_LDO_EN_DECL 20

/*
 * Oscillator trim
 */
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_MASK 0x0fe00000
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_POS 21
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_SIZE 7
#define IAXXX_AO_EFUSE_BOOT_OSC_TRIM_DECL (27:21)

/*
 * Flash boot override:
 * 2'b00 : Use sw_lor_9 to determine if boot from flash or not
 * 2'b01 : Force boot from host port (COMMA per eFUse BOOT_OVRRD field)
 * 2'b10 : Force boot from Flash (COMMB from SPI0)
 * 2'b11 : Use sw_lor_9 to determine if boot from flash or not
 */
#define IAXXX_AO_EFUSE_BOOT_FLASH_OVRRD_MASK 0x30000000
#define IAXXX_AO_EFUSE_BOOT_FLASH_OVRRD_RESET_VAL 0x0
#define IAXXX_AO_EFUSE_BOOT_FLASH_OVRRD_POS 28
#define IAXXX_AO_EFUSE_BOOT_FLASH_OVRRD_SIZE 2
#define IAXXX_AO_EFUSE_BOOT_FLASH_OVRRD_DECL (29:28)

/*** AO_SW_PWR_CTRL_SET (0x40000080) ***/
/*
 * The software power control set register removes power to and isolates
 * output signals from pd0, pd4, pd5, pd6, pd7 and pd8 power domains. It also
 * stalls HMD and DMX processors. It supports read and write-1-to-set
 * accesses. It is cleared by writing to the AO.SW_PWR_CTRL_CLR register.
 * NOTE:  It is very important to understand that ALL pds now have software
 * control registers.  However, pd4, pd5 and pd8 (as well as mpll) are
 * special in that those domains also have a hardware control option for
 * powerdown and isolation, in addition to the new software control bits in
 * this register.  For those domains (pd4,pd5,pd8), the fields in this
 * register are effectively combined with the hardware control.  So, pd4,pd5
 * and p8 will be under software control if these bits are set, and hardware
 * control (see the PWR_CTRL register), if they are not.  So in a sense, for
 * pd4,pd5,and pd8, these registers are effectively a software override.
 * VERY IMPORTANT NOTE: pd4 and pd5 contain the system control processors
 * (HMD and DMX).  The fields for those domains in these registers should
 * NEVER be programmed to set all the pd4, and pd5 fields at the same time,
 * or the chip may hang since both control processors would be in software
 * mode (and thus would override the hardware control).  At hard reset,
 * pd5,pd6 and pd8 are not powered down or isolated, since DMX (and HIC
 * interfaces as well as EFUSE) need to be available for ROM boot.  After
 * hard reset, software can bring up the other domains.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ADDR (0x40000080)
#define IAXXX_AO_SW_PWR_CTRL_SET_MASK_VAL 0x31f103f1
#define IAXXX_AO_SW_PWR_CTRL_SET_RMASK_VAL 0x31f103f1
#define IAXXX_AO_SW_PWR_CTRL_SET_WMASK_VAL 0x31f101f1
#define IAXXX_AO_SW_PWR_CTRL_SET_RESET_VAL 0x10910091

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., removes power to pd0 power domain. For all
 * memories in pd0, memory periphery logic is powered down as well. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.PWR_DN_PD0 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD0_MASK 0x00000001
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD0_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD0_POS 0
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD0_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD0_DECL 0

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., removes power to pd4 power domain. For all
 * memories in pd4, memory periphery logic is powered down as well. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.PWR_DN_PD4 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD4_MASK 0x00000010
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD4_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD4_POS 4
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD4_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD4_DECL 4

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., removes power to pd5 power domain. For all
 * memories in pd5, memory periphery logic is powered down as well. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.PWR_DN_PD5 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD5_MASK 0x00000020
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD5_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD5_POS 5
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD5_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD5_DECL 5

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., removes power to pd6 power domain. For all
 * memories in pd6, memory periphery logic is powered down as well. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.PWR_DN_PD6 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD6_MASK 0x00000040
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD6_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD6_POS 6
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD6_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD6_DECL 6

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., removes power to pd7 power domain. For all
 * memories in pd7, memory periphery logic is powered down as well. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.PWR_DN_PD7 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD7_MASK 0x00000080
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD7_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD7_POS 7
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD7_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD7_DECL 7

/*
 * DO NOT WRITE THIS BIT AS CHIP WILL HANG.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD8_MASK 0x00000100
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD8_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD8_POS 8
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD8_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_PD8_DECL 8

/*
 * Returns the power down (sleep) status of mpll. This bit has no functional
 * value and is there for consistency only.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_MPLL_MASK 0x00000200
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_MPLL_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_MPLL_POS 9
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_MPLL_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_PWR_DN_MPLL_DECL 9

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., isolates pd0 power domain output signals. It
 * is cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.ISO_PD0 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD0_MASK 0x00010000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD0_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD0_POS 16
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD0_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD0_DECL 16

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., isolates pd4 power domain output signals. It
 * is cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.ISO_PD4 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD4_MASK 0x00100000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD4_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD4_POS 20
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD4_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD4_DECL 20

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., isolates pd5 power domain output signals. It
 * is cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.ISO_PD5 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD5_MASK 0x00200000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD5_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD5_POS 21
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD5_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD5_DECL 21

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., isolates pd6 power domain output signals. It
 * is cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.ISO_PD6 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD6_MASK 0x00400000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD6_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD6_POS 22
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD6_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD6_DECL 22

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., isolates pd7 power domain output signals. It
 * is cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.ISO_PD7 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD7_MASK 0x00800000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD7_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD7_POS 23
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD7_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD7_DECL 23

/*
 * DO NOT WRITE THIS BIT.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD8_MASK 0x01000000
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD8_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD8_POS 24
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD8_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_ISO_PD8_DECL 24

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., asserts HMD's RunStall and stalls it. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.STALL_HMD bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_HMD_MASK 0x10000000
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_HMD_RESET_VAL 0x1
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_HMD_POS 28
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_HMD_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_HMD_DECL 28

/*
 * Write 0: Does nothing.
 * Write 1: Sets itself - i.e., asserts DMX's RunStall and stalls it. It is
 * cleared by writing a '1' to AO.SW_PWR_CTRL_CLR.STALL_DMX bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_DMX_MASK 0x20000000
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_DMX_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_DMX_POS 29
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_DMX_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_SET_STALL_DMX_DECL 29

/*** AO_SW_PWR_CTRL_CLR (0x40000084) ***/
/*
 * The software power control clear register re-applies power to and removes
 * output signal isolation from pd0, pd2, pd3, pd4, pd5, pd6, pd7 and pd8
 * power domains. It also advancess SSP, HMD and DMX processors by
 * de-asserting their stall signals. It supports read and write-1-to-clear
 * accesses. It is set by writing to the AO.SW_PWR_CTRL_SET register.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ADDR (0x40000084)
#define IAXXX_AO_SW_PWR_CTRL_CLR_MASK_VAL 0x31f103f1
#define IAXXX_AO_SW_PWR_CTRL_CLR_RMASK_VAL 0x31f103f1
#define IAXXX_AO_SW_PWR_CTRL_CLR_WMASK_VAL 0x31f101f1
#define IAXXX_AO_SW_PWR_CTRL_CLR_RESET_VAL 0x00000000

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., re-applies power to pd0 power domain. For
 * all memories in pd0, memory periphery logic is powered on as well. It is
 * set by writing a '1' to AO.SW_PWR_CTRL_SET.PWR_DN_PD0 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD0_MASK 0x00000001
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD0_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD0_POS 0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD0_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD0_DECL 0

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., re-applies power to pd4 power domain. For
 * all memories in pd4, memory periphery logic is powered on as well. It is
 * set by writing a '1' to AO.SW_PWR_CTRL_SET.PWR_DN_PD4 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD4_MASK 0x00000010
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD4_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD4_POS 4
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD4_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD4_DECL 4

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., re-applies power to pd5 power domain. For
 * all memories in pd5, memory periphery logic is powered on as well. It is
 * set by writing a '1' to AO.SW_PWR_CTRL_SET.PWR_DN_PD5 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD5_MASK 0x00000020
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD5_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD5_POS 5
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD5_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD5_DECL 5

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., re-applies power to pd6 power domain. For
 * all memories in pd6, memory periphery logic is powered on as well. It is
 * set by writing a '1' to AO.SW_PWR_CTRL_SET.PWR_DN_PD6 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD6_MASK 0x00000040
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD6_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD6_POS 6
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD6_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD6_DECL 6

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., re-applies power to pd7 power domain. For
 * all memories in pd7, memory periphery logic is powered on as well. It is
 * set by writing a '1' to AO.SW_PWR_CTRL_SET.PWR_DN_PD7 bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD7_MASK 0x00000080
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD7_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD7_POS 7
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD7_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD7_DECL 7

/*
 * DO NOT WRITE THIS BIT.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD8_MASK 0x00000100
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD8_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD8_POS 8
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD8_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_PD8_DECL 8

/*
 * Returns the power down (sleep) status of mpll. This bit has no functional
 * value and is there for consistency only.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_MPLL_MASK 0x00000200
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_MPLL_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_MPLL_POS 9
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_MPLL_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_PWR_DN_MPLL_DECL 9

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd0 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD0
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD0_MASK 0x00010000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD0_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD0_POS 16
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD0_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD0_DECL 16

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd4 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD4
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD4_MASK 0x00100000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD4_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD4_POS 20
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD4_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD4_DECL 20

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd5 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD5
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD5_MASK 0x00200000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD5_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD5_POS 21
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD5_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD5_DECL 21

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd6 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD6
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD6_MASK 0x00400000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD6_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD6_POS 22
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD6_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD6_DECL 22

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd7 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD7
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD7_MASK 0x00800000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD7_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD7_POS 23
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD7_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD7_DECL 23

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., removes isolation from pd8 power domain
 * output signals. It is set by writing a '1' to AO.SW_PWR_CTRL_SET.ISO_PD8
 * bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD8_MASK 0x01000000
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD8_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD8_POS 24
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD8_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_ISO_PD8_DECL 24

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., de-asserts HMD's RunStall and advances it.
 * It is set by writing a '1' to AO.SW_PWR_CTRL_SET.STALL_HMD bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_HMD_MASK 0x10000000
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_HMD_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_HMD_POS 28
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_HMD_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_HMD_DECL 28

/*
 * Write 0: Does nothing.
 * Write 1: Clears itself - i.e., de-asserts DMX's RunStall and advances it.
 * It is set by writing a '1' to AO.SW_PWR_CTRL_SET.STALL_DMX bit.
 */
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_DMX_MASK 0x20000000
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_DMX_RESET_VAL 0x0
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_DMX_POS 29
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_DMX_SIZE 1
#define IAXXX_AO_SW_PWR_CTRL_CLR_STALL_DMX_DECL 29

/*** AO_STATVECTORSEL (0x40000088) ***/
/*
 * Select the alternate reset and interrupt vectors for each processor.
 */
#define IAXXX_AO_STATVECTORSEL_ADDR (0x40000088)
#define IAXXX_AO_STATVECTORSEL_MASK_VAL 0x00000030
#define IAXXX_AO_STATVECTORSEL_RMASK_VAL 0x00000030
#define IAXXX_AO_STATVECTORSEL_WMASK_VAL 0x00000030
#define IAXXX_AO_STATVECTORSEL_RESET_VAL 0x00000000

/*
 * Use alternate vectors for HMD.
 */
#define IAXXX_AO_STATVECTORSEL_HMD_MASK 0x00000010
#define IAXXX_AO_STATVECTORSEL_HMD_RESET_VAL 0x0
#define IAXXX_AO_STATVECTORSEL_HMD_POS 4
#define IAXXX_AO_STATVECTORSEL_HMD_SIZE 1
#define IAXXX_AO_STATVECTORSEL_HMD_DECL 4

/*
 * Use alternate vectors for DMX.
 */
#define IAXXX_AO_STATVECTORSEL_DMX_MASK 0x00000020
#define IAXXX_AO_STATVECTORSEL_DMX_RESET_VAL 0x0
#define IAXXX_AO_STATVECTORSEL_DMX_POS 5
#define IAXXX_AO_STATVECTORSEL_DMX_SIZE 1
#define IAXXX_AO_STATVECTORSEL_DMX_DECL 5

/*** AO_FW_CFG (0x4000008c) ***/
/*
 * Register to preserve sw data over sleep wake up cycle
 */
#define IAXXX_AO_FW_CFG_ADDR (0x4000008c)
#define IAXXX_AO_FW_CFG_MASK_VAL 0xffffffff
#define IAXXX_AO_FW_CFG_RMASK_VAL 0xffffffff
#define IAXXX_AO_FW_CFG_WMASK_VAL 0xffffffff
#define IAXXX_AO_FW_CFG_RESET_VAL 0x00000000

/*
 * TBD by firmware
 */
#define IAXXX_AO_FW_CFG_FW_CFG_MASK 0xffffffff
#define IAXXX_AO_FW_CFG_FW_CFG_RESET_VAL 0x0
#define IAXXX_AO_FW_CFG_FW_CFG_POS 0
#define IAXXX_AO_FW_CFG_FW_CFG_SIZE 32
#define IAXXX_AO_FW_CFG_FW_CFG_DECL (31:0)

/*** AO_JTAG_DBG (0x40000090) ***/
/*
 * This register is used to control JTAG debug mode.
 */
#define IAXXX_AO_JTAG_DBG_ADDR (0x40000090)
#define IAXXX_AO_JTAG_DBG_MASK_VAL 0x00000001
#define IAXXX_AO_JTAG_DBG_RMASK_VAL 0x00000001
#define IAXXX_AO_JTAG_DBG_WMASK_VAL 0x00000001
#define IAXXX_AO_JTAG_DBG_RESET_VAL 0x00000001

/*
 * 0: Turn off JTAG debug mode.
 * 1: Turn on JTAG debug mode.
 */
#define IAXXX_AO_JTAG_DBG_ON_MASK 0x00000001
#define IAXXX_AO_JTAG_DBG_ON_RESET_VAL 0x1
#define IAXXX_AO_JTAG_DBG_ON_POS 0
#define IAXXX_AO_JTAG_DBG_ON_SIZE 1
#define IAXXX_AO_JTAG_DBG_ON_DECL 0

/*** AO_OCD (0x40000094) ***/
/*
 * This register is used to control OCD
 */
#define IAXXX_AO_OCD_ADDR (0x40000094)
#define IAXXX_AO_OCD_MASK_VAL 0x00239878
#define IAXXX_AO_OCD_RMASK_VAL 0x00239878
#define IAXXX_AO_OCD_WMASK_VAL 0x00239878
#define IAXXX_AO_OCD_RESET_VAL 0x00010048

/*
 * Setting this bit to '0' will:
 *   remove the DReset for HMD
 */
#define IAXXX_AO_OCD_HMD_DRESET_MASK 0x00000008
#define IAXXX_AO_OCD_HMD_DRESET_RESET_VAL 0x1
#define IAXXX_AO_OCD_HMD_DRESET_POS 3
#define IAXXX_AO_OCD_HMD_DRESET_SIZE 1
#define IAXXX_AO_OCD_HMD_DRESET_DECL 3

/*
 * Setting this bit to '0' will:
 *   remove the DReset for DMX
 * Software should set this bit to "1" when not in debug mode to save power
 */
#define IAXXX_AO_OCD_DMX_DRESET_MASK 0x00000010
#define IAXXX_AO_OCD_DMX_DRESET_RESET_VAL 0x0
#define IAXXX_AO_OCD_DMX_DRESET_POS 4
#define IAXXX_AO_OCD_DMX_DRESET_SIZE 1
#define IAXXX_AO_OCD_DMX_DRESET_DECL 4

/*
 * Setting this bit to '0' will:
 *   remove the DReset for PD8 (De-asserts the reset to debug components
 * present in PD8)
 * Software should set this bit to "1" when not in debug mode to save power
 */
#define IAXXX_AO_OCD_PD8_DRESET_MASK 0x00000020
#define IAXXX_AO_OCD_PD8_DRESET_RESET_VAL 0x0
#define IAXXX_AO_OCD_PD8_DRESET_POS 5
#define IAXXX_AO_OCD_PD8_DRESET_SIZE 1
#define IAXXX_AO_OCD_PD8_DRESET_DECL 5

/*
 * Setting this bit to '0' will:
 *   remove the TRest for TPIU
 */
#define IAXXX_AO_OCD_TPIU_TRESET_MASK 0x00000040
#define IAXXX_AO_OCD_TPIU_TRESET_RESET_VAL 0x1
#define IAXXX_AO_OCD_TPIU_TRESET_POS 6
#define IAXXX_AO_OCD_TPIU_TRESET_SIZE 1
#define IAXXX_AO_OCD_TPIU_TRESET_DECL 6

/*
 * Setting this bit to '1' will:
 *   force HMD to enable OCD and enter Stopped state at processor reset
 *   1) For this bit to take affect, HMD_DRESET must de-asserted at least 4
 * HMD clock cycles prior to deassertion of PWR_DOMAIN_SOFT_RST,
 * PD4_SOFT_RST.
 *   2) HMD_OCDHALT_ON_RESET must asserted at least 2 HMD clock cycles prior
 * to deassertion of PWR_DOMAIN_SOFT_RST, PD4_SOFT_RST.
 *   Please refer to Tensilica Debug guid for more details.
 */
#define IAXXX_AO_OCD_HMD_OCDHALT_ON_RESET_MASK 0x00000800
#define IAXXX_AO_OCD_HMD_OCDHALT_ON_RESET_RESET_VAL 0x0
#define IAXXX_AO_OCD_HMD_OCDHALT_ON_RESET_POS 11
#define IAXXX_AO_OCD_HMD_OCDHALT_ON_RESET_SIZE 1
#define IAXXX_AO_OCD_HMD_OCDHALT_ON_RESET_DECL 11

/*
 * Setting this bit to '1' will:
 *   force DMX to enable OCD and enter Stopped state at processor reset
 *   1) For this bit to take affect, DMX_DRESET must de-asserted at least 4
 * DMX clock cycles prior to deassertion of PWR_DOMAIN_SOFT_RST,
 * PD5_SOFT_RST.
 *   2) DMX_OCDHALT_ON_RESET must asserted at least 2 DMX clock cycles prior
 * to deassertion of PWR_DOMAIN_SOFT_RST, PD5_SOFT_RST.
 *   Please refer to Tensilica Debug guid for more details.
 */
#define IAXXX_AO_OCD_DMX_OCDHALT_ON_RESET_MASK 0x00001000
#define IAXXX_AO_OCD_DMX_OCDHALT_ON_RESET_RESET_VAL 0x0
#define IAXXX_AO_OCD_DMX_OCDHALT_ON_RESET_POS 12
#define IAXXX_AO_OCD_DMX_OCDHALT_ON_RESET_SIZE 1
#define IAXXX_AO_OCD_DMX_OCDHALT_ON_RESET_DECL 12

/*
 * Setting this bit to '1' will Enables clock for HMD TRAX and debug.
 */
#define IAXXX_AO_OCD_HMD_TRAX_CGEN_MASK 0x00008000
#define IAXXX_AO_OCD_HMD_TRAX_CGEN_RESET_VAL 0x0
#define IAXXX_AO_OCD_HMD_TRAX_CGEN_POS 15
#define IAXXX_AO_OCD_HMD_TRAX_CGEN_SIZE 1
#define IAXXX_AO_OCD_HMD_TRAX_CGEN_DECL 15

/*
 * Setting this bit to '1' will Enables clock for DMX TRAX and debug.
 * Software should set this bit to "0" when not using TRAX and debug.
 */
#define IAXXX_AO_OCD_DMX_TRAX_CGEN_MASK 0x00010000
#define IAXXX_AO_OCD_DMX_TRAX_CGEN_RESET_VAL 0x1
#define IAXXX_AO_OCD_DMX_TRAX_CGEN_POS 16
#define IAXXX_AO_OCD_DMX_TRAX_CGEN_SIZE 1
#define IAXXX_AO_OCD_DMX_TRAX_CGEN_DECL 16

/*
 * Setting this bit to '0' will:
 *   remove the Power on Reset for SWJDP (DAP)
 * Software should set this bit to "1" when not in debug mode to save power
 */
#define IAXXX_AO_OCD_SWJDP_PORESET_MASK 0x00020000
#define IAXXX_AO_OCD_SWJDP_PORESET_RESET_VAL 0x0
#define IAXXX_AO_OCD_SWJDP_PORESET_POS 17
#define IAXXX_AO_OCD_SWJDP_PORESET_SIZE 1
#define IAXXX_AO_OCD_SWJDP_PORESET_DECL 17

/*
 * Setting this bit to '1' makes all DRESETs SW controllable across various
 * power cycles.
 * If not set, PD4/PD5/PD8 DRESET would be HW controlled as part of HW
 * power-down/power-up sequence
 */
#define IAXXX_AO_OCD_RETAIN_DEBUG_SESSION_MASK 0x00200000
#define IAXXX_AO_OCD_RETAIN_DEBUG_SESSION_RESET_VAL 0x0
#define IAXXX_AO_OCD_RETAIN_DEBUG_SESSION_POS 21
#define IAXXX_AO_OCD_RETAIN_DEBUG_SESSION_SIZE 1
#define IAXXX_AO_OCD_RETAIN_DEBUG_SESSION_DECL 21

/*** AO_SCTRL_SEQ_CONTROL (0x40000098) ***/
/*
 * This register is used to bypass counters in the power up or power down
 * sequence.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_ADDR (0x40000098)
#define IAXXX_AO_SCTRL_SEQ_CONTROL_MASK_VAL 0x0c08000e
#define IAXXX_AO_SCTRL_SEQ_CONTROL_RMASK_VAL 0x0c08000e
#define IAXXX_AO_SCTRL_SEQ_CONTROL_WMASK_VAL 0x0c08000e
#define IAXXX_AO_SCTRL_SEQ_CONTROL_RESET_VAL 0x00000000

/*
 * Setting this bit to '1' will:
 *   skip the chip power good counter (by setting the count for it to 1).
 * This counter is a remnant of days where we had an LDO and uLDO which
 * needed make before break.  Might make sense to set for shorter boot times.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_CHIP_PWR_NOT_GOOD_MASK 0x00000002
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_CHIP_PWR_NOT_GOOD_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_CHIP_PWR_NOT_GOOD_POS 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_CHIP_PWR_NOT_GOOD_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_CHIP_PWR_NOT_GOOD_DECL 1

/*
 * Setting this bit to '1' will:
 *   skip the pll warmup counter (by setting the count for it to 1).  If no
 * pll is used, it might make sense to set this for shorter boot times.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_WARMUP_MASK 0x00000004
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_WARMUP_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_WARMUP_POS 2
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_WARMUP_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_WARMUP_DECL 2

/*
 * Setting this bit to '1' will:
 *   skip the pll lock counter (by setting the count for it to 1).  If no pll
 * is used, it might make sense to set this for shorter boot times.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_LOCK_MASK 0x00000008
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_LOCK_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_LOCK_POS 3
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_LOCK_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_PLL_LOCK_DECL 3

/*
 * Setting this bit to '1' will:
 *   skip the uLDO enable counter (by setting the count for it to 1).  This
 * counter is a remnant of days where we had an LDO and uLDO which needed
 * make before break.  Might make sense to set for shorter boot times.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_ULDO_EN_MASK 0x00080000
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_ULDO_EN_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_ULDO_EN_POS 19
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_ULDO_EN_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_SKIP_ULDO_EN_DECL 19

/*
 * Setting this bit to '1' will allow chip to wake up from a PCTRL interrupt
 * that was enabled for HMD. If all PCTRL_HMD_WAKEUP_EN and
 * PCTRL_DMX_WAKEUP_EN are enabled then chip will wake up from either
 * interrupts.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_HMD_WAKEUP_EN_MASK 0x04000000
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_HMD_WAKEUP_EN_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_HMD_WAKEUP_EN_POS 26
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_HMD_WAKEUP_EN_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_HMD_WAKEUP_EN_DECL 26

/*
 * Setting this bit to '1' will allow chip to wake up from a PCTRL interrupt
 * that was enabled for DMX. If all PCTRL_HMD_WAKEUP_EN and
 * PCTRL_DMX_WAKEUP_EN are enabled then chip will wake up from either
 * interrupts.
 */
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_DMX_WAKEUP_EN_MASK 0x08000000
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_DMX_WAKEUP_EN_RESET_VAL 0x0
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_DMX_WAKEUP_EN_POS 27
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_DMX_WAKEUP_EN_SIZE 1
#define IAXXX_AO_SCTRL_SEQ_CONTROL_PCTRL_DMX_WAKEUP_EN_DECL 27

/*** AO_SPARE_GATES (0x4000009c) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_AO_SPARE_GATES_ADDR (0x4000009c)
#define IAXXX_AO_SPARE_GATES_MASK_VAL 0xffffffff
#define IAXXX_AO_SPARE_GATES_RMASK_VAL 0xffffffff
#define IAXXX_AO_SPARE_GATES_WMASK_VAL 0x0000ffff
#define IAXXX_AO_SPARE_GATES_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_AO_SPARE_GATES_FIELD_1_MASK 0x0000ffff
#define IAXXX_AO_SPARE_GATES_FIELD_1_RESET_VAL 0x0
#define IAXXX_AO_SPARE_GATES_FIELD_1_POS 0
#define IAXXX_AO_SPARE_GATES_FIELD_1_SIZE 16
#define IAXXX_AO_SPARE_GATES_FIELD_1_DECL (15:0)

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_AO_SPARE_GATES_FIELD_2_MASK 0xffff0000
#define IAXXX_AO_SPARE_GATES_FIELD_2_RESET_VAL 0x0
#define IAXXX_AO_SPARE_GATES_FIELD_2_POS 16
#define IAXXX_AO_SPARE_GATES_FIELD_2_SIZE 16
#define IAXXX_AO_SPARE_GATES_FIELD_2_DECL (31:16)

/* Number of registers in the module */
#define IAXXX_AO_REG_NUM 40

#endif /* __IAXXX_REGISTER_DEFS_AO_H__*/
